/*

-Procedure icy ( Interfaces to CSPICE from IDL)

-Abstract

   The file contains the coded gateways between CSPICE and IDL.

-Disclaimer

   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
   CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED "AS-IS"
   TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING ANY
   WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A
   PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.

   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA
   BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT
   LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND,
   INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS,
   REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE ADVISED, HAVE
   REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY.

   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF
   THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY
   CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE
   ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.

-Required_Reading

   ICY.REQ

-Keywords

   ICY
   IDL

*/


/*
Standard includes.
*/
#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include <ctype.h>


/*
   IDL, Icy and CSPICE prototypes headers
*/
#include "export.h"
#include "SpiceUsr.h"
#include "SpiceZfc.h"
#include "SpiceZst.h"
#include "SpiceZmc.h"
#include "SpiceCel.h"
#include "icy.h"
#include "zzicy.h"
#include "zzalloc.h"
#include "zzcell.h"
#include "zzerror.h"
#include <string.h>
#include "cspice_params.h"


/*
-Brief_I/O

   Variable  I/O  Description
   --------  ---  --------------------------------------------------
   Argc       I   Number of input arguments.
   Argv_orig I/O  Array of pointers to input arguments.
   Argk       -   Not used.

-Detailed_Input

   Argc           Number of input arguments.

   Argv_orig      Array of pointers to input arguments.

-Detailed_Output

   None.

-Parameters

   See icy.h, zzicy.h

*/

#define  Nx2i          ConstSpiceInt(*)[2]
#define  Nx3i          ConstSpiceInt(*)[3]
#define  Nx2d          ConstSpiceDouble(*)[2]
#define  Nx3d          ConstSpiceDouble(*)[3]
#define  Nx4d          ConstSpiceDouble(*)[4]
#define  Nx6d          ConstSpiceDouble(*)[6]

/*
-Exceptions

   None.

-Files

   None.

-Particulars

   PLEASE DO NOT EDIT THIS FILE. IF YOU MUST EDIT THE FILE, THINK IT THROUGH.

   If you have any questions about this package, feature request, or
   find any problems, please contact:

      Ed Wright, ed.wright@jpl.nasa.gov

   Item 1.

      The interfaces performing the same operations:

      i. Confirm the correct argument count in 'Argc'. An error/usage
      message outputs when the arg count fails to match the expected
      value.

      ii. Check the input argument types. The function zzicy_argcheck()
      tests all required dimensions, allows for "vectorized" extra dimensions,
      performs conversions for us where it can (e.g., INT to LONG, LONG
      to DOUBLE), and complains where it can't (INT to STRUCT?). The
      'argcheck' structure contains the description of the expected argument
      types, sizes, and the status with regards to I/O.

      iii. Set the input arguments for the CSPICE call.

      iv. Call the CSPICE routine.

      v. Execute the appropriate CHECK_CALL_FAILURE macro to check the value
      returned by "failed_c()." If the call returns true, handle the error in
      proper IDL fashion.

      vi. Store any return values in the proper place.

      vii. Check the interface code freed any allocated memory. This
      check queries a counter incremented for each malloc, decremented
      for each free. This count should equal zero on exit from all
      interfaces.

      viii. Return to IDL.

   Item 2.

      zzicy.c contains the "zzicy_argcheck" support routine. This routine
      performs most of the initial processing/allocation for arguments.
      Break it and Icy will not function.

   Item 3.

      There are slight differences among the functions, mostly when dealing
      with arrays (even though IDL allows one to treat scalars and arrays
      in similar fashion, C doesn't!)

   Item 4.

      With regards to memory usage:

      In most input cases, the CSPICE calls use memory assigned by the IDL
      application. String arrays are an exception. An IDL input string
      array must be copied to a CSPICE string array of the proper size.
      The interface allocates the memory needed for the CSPICE copy through
      the calls in zzmalloc.c.

      The zzicy_argcheck routine creates temporary variables as needed
      for arguments. The zzicy_argcleanup routine frees any
      temporary variables.

      Output arguments always require memory allocation by the interface
      routine. Most output arguments have a known or maximum possible size.
      Such args are defined as either scalars or sized arrays. The interface
      allocates the necessary memory via the calls in zzmalloc.c calls for
      those arguments with unknown size requirements till run-time.

      The user must predeclare the size and type of read (OREAD) and read-write
      (RDWRT) arguments prior to an Icy call.

   Item 5.

      The 4xN and 3xN arguments passed the CK writers do not require an
      array transpose operation since the required form for these arrays in IDL
      notation resolves to the correct form for passing to the CSPICE call, i.e.
      Nx4 and Nx3.

   Item 6.

      The use of structure type identifiers in argcheck differs from other
      argument types. As of this Icy implementation, two aspects of structures
      exists as arguments. Structures with a defined, constant size and shape:

         CSPICE_PLANE
         CSPICE_ELLIPSE
         CSPICE_EKATTDSC

      created in 'IDL_load', and the SPICE Windows. The CSPICE_* structures
      type field has the value of the pointer to the structure descriptor;
      the SPICE Window structures have type IDL_MAX_TYPE + 1.

   Item 7.

     A return argument, defined as an array in 'argcheck' but with a
     zero for any dimension, is not allocated memory. Memory
     allocation and management is the responsibility of the user.

     E.g.,

        In the CSPICE_GETFOV interface, the return argument 'bounds'
        is defined as an array with two dimensions with one of those
        dimensions zero.

        { OWRIT, "bounds", (void*)IDL_TYP_DOUBLE,  2, { 3, 0 }, 0}


-Examples

   None.

-Restrictions

   None.

-Literature_References

   External Development Guide for IDL (versions 5.5 - 6.1),
   by Research Systems Inc.

   External Development Guide for IDL (versions 6.3 - 7.0),
   by ITT Inc.

-Author_and_Institution

   E. D. Wright  (JPL)
   N. J. Bachman (JPL)
   S. C. Krening (JPL)

      Based on an earlier work by:

   Ed Santiago  (LANL)

-Version

*/

#define VERSION  "Icy 1.8.0 11-JAN-2017 (EDW) (NJB)"

/*

      New interfaces-

         cspice_ccifrm
         cspice_dasec
         cspice_dlabfs
         cspice_dlafns
         cspice_dskb02
         cspice_dskcls
         cspice_dskd02
         cspice_dskgd
         cspice_dskgtl
         cspice_dski02
         cspice_dskmi2
         cspice_dskn02
         cspice_dskobj
         cspice_dskopn
         cspice_dskp02
         cspice_dskrb2
         cspice_dsksrf
         cspice_dskstl
         cspice_dskv02
         cspice_dskw02
         cspice_dskx02
         cspice_dskxsi
         cspice_dskxv
         cspice_dskz02
         cspice_illum_pl02
         cspice_illum_plid_pl02
         cspice_illumf
         cspice_illumg
         cspice_latsrf
         cspice_limb_pl02
         cspice_limbpt
         cspice_llgrid_pl02
         cspice_lspcn
         cspice_pckcov
         cspice_pckfrm
         cspice_pltar
         cspice_pltexp
         cspice_pltnp
         cspice_pltnrm
         cspice_pltvol
         cspice_srfc2s
         cspice_srfcss
         cspice_srfnrm
         cspice_srfs2c
         cspice_srfscc
         cspice_subpt_pl02
         cspice_subsol_pl02
         cspice_term_pl02
         cspice_termpt

      Unused cspice_removc code removed.

      Eliminated unneeded sizeof calculation for return strings. All
      return string arguments have length RET_ARRAY_LEN.

      The code to return a null terminated string from those
      routines that return a string variable and a 'found' flag, setting
      the string only when found has value true, contained an error.
      The code returned "\n" (newline) rather than "\0". Due to cut and paste
      proliferation, several routines included the error. The offending
      code blocks now read something like,

         if ( *found )
            {
            S_STR_RET_ARGV( 1, name_buf);
            }
         else
            {
            S_STR_RET_ARGV( 1, "\0");
            }

      Eliminate possiblity of array overrun in cspice_bodvar.
      Check added to ensure value of 'values_dim' less-than or equal-to
      RET_ARRAY_LEN prior to memory allocation.

      Corrected bug in cspice_ekpsel. Threshold code failed to
      test 'error' flag. The bug could cause segmentation faults.

      Replaced '\0' for empty return strings with NULL assignment
      to eliminate warning:

         "expression which evaluates to zero treated as a null
         pointer constant of type 'SpiceChar *' (aka 'char *')
         [-Wnon-literal-null-conversion]"

   Icy 1.7.0 19-JUN-2014 (EDW) (SCK)

      New interfaces-

         cspice_dafus
         cspice_dascls   (completely implemented and listed in icy.dlm)
         cspice_dasopr   (completely implemented and listed in icy.dlm)
         cspice_dcyldr
         cspice_dgeodr
         cspice_dlatdr
         cspice_dpgrdr
         cspice_drdcyl
         cspice_drdgeo
         cspice_drdlat
         cspice_drdpgr
         cspice_drdsph
         cspice_dsphdr
         cspice_edterm
         cspice_eqncpv
         cspice_fovray
         cspice_fovtrg
         cspice_gfilum
         cspice_gfpa
         cspice_gfstol
         cspice_invort
         cspice_occult
         cspice_phaseq
         cspice_pxfrm2
         cspice_spkcpo
         cspice_spkcpt
         cspice_spkcvo
         cspice_spkcvt
         cspice_spkpvn
         cspice_spksfs
         cspice_spkw17   (reimplemented)
         cspice_xfmsta

      File spell check.

      The usage description string again includes "Usage: "
      as a prefix, e.g.

         Usage: CSPICE_BODVCD, bodyid, `item`, maxn, VALUES[]

      Corrected bug in cspice_srfxpt interface. Vectorized logic return "found"
      argument declared as SpiceInt (long, size 4 bytes) rather than char
      (size 1 byte) as proper for IDL return.

      Corrected typo in cspice_ckcov usage description. Incorrect argument
      order.

      Replaced all calls to strcpy with strncpy for consistency.

   Icy 1.6.0 03-MAY-2010 (EDW)

      Corrected error in handling of input arrays of logicals.
      The conversion to an array of SpiceBoolean did not function.
      The interfaces:

         cspice_ekacld
         cspice_ekaclc
         cspice_ekacli

      now have 'nlflgs' declared as a IDL_TYP_LONG, replacing
      IDL_TYP_BYTE, to correct the error; other edits applied to zzicy.c
      to accommodate the changed declaration.

      New interfaces-

         cspice_bodc2s
         cspice_dp2hx
         cspice_ducrss
         cspice_dvcrss
         cspice_dvnorm
         cspice_dvsep
         cspice_gfrr
         cspice_hx2dp
         cspice_zzargs - private, used only for argument testing by ticy

      'cspice_define_message_block' call name changed to 'define_message_block'
      to match the name used in that "zzicy.c" compiled with "icy.c."

      Edit to 'cspice_pgrrec' usage string. 'body' now identified
      as a string.

      Renamed the less-than-dignified name 'cspice_argbarf' to
      'zzicy_argerr'.

      Renamed the less-than-dignified name 'cspice_argbarf_cleanup' to
      'zzicy_argcleanup'.

      Renamed the name 'cspice_checkargs' to 'zzicy_argcheck'.

      SPICE cell structures now identified with a type value IDL_MAX_TYPE+1.
      Refer to Particulars Section "Item 6."

   Icy 1.5.0 04-FEB-2009 (EDW)

      Header sections re-ordered to match correct format.

      New interfaces-

         cspice_gfdist
         cspice_gfoclt
         cspice_gfposc
         cspice_gfsep
         cspice_gfsntc
         cspice_gfsubc
         cspice_gfrfov
         cspice_gftfov

      Removed use of the macros:

         S_BOOL_RET_ARGV
         S_INT_RET_ARGV
         S_DBL_RET_ARGV

      Corrected spelling errors.

      Updated the maximum number of allowed call arguments to equal
      ICY_MAXPARAMS, currently 30.

   Icy 1.4.0 12-FEB-2008 (EDW)

      New interfaces-

         cspice_getelm
         cspice_spkw10
         cspice_wncard
         cspice_subpnt
         cspice_subslr
         cspice_dafac
         cspice_dafdc
         cspice_dafec
         cspice_subpnt
         cspice_subslr
         cspice_sincpt

      Vectorized-

         cspice_etcal
         cspice_furnsh
         cspice_unload

      Removed interfaces-

         cspice_spkw15
         cspice_spkw17

      Unnecessary declaration removed as the 'size_SpiceChar' evaluates
      to 1 on currently supported platforms,

         static int     size_SpiceChar = (int) sizeof(SpiceChar);

      Clarified vectorization measure error diagnostic message from

         "must have the same order"

      to

         "must have the same measure of vectorization"

      Altered markers indicating a vectorized string from `_string_`
      to _`string`_ for consistency (apply vectorization to a string
      not apply a string to vectorization).

   Icy 1.3.01 20-NOV-2006 (EDW)(BVS)

      New interfaces-

         1.3
         cspice_appndd
         cspice_appndi
         cspice_badkpv
         cspice_dafgda
         cspice_dascls
         cspice_dasopr
         cspice_inter
         cspice_kclear
         cspice_valid

      Vectorized-

         1.3
         cspice_appndd
         cspice_appndi

      The icy.dlm file lacked an entry for CSPICE_REMOVC. Lack of this
      entry caused a segmentation fault on OS X, Linux, and Windows
      on execution of the .full_reset_session executive command.
      Problem resolved by removing the CSPICE_REMOVC entry from the
      'main_PROC_def' list.

      CSPICE_CELLC, CSPICE_INSRTC were removed from 'main_PROC_def' list
      until instabilities in the ICY character CELL implementation are
      characterized and resolved.

   Icy 1.2.0 07-JAN-2006 (EDW)

      Removed usage routine, replaced with USAGE macro.

      Added use of zzerror, removed parallel code from icy_fail.
      Renamed spice_dlm_barf call with a more dignified name, icy_fail.
      Redeclared all vector loop counters 'i' long from int.

      Replaced macro ALLOC_CHECK with ICY_ALLOC_CHECK to perform
      allocation count check; macro defined in icy.h. Added
      new ICY_ALLOC_CHECK calls to unchecked interfaces.

      Removed all 'register' keywords.

      Corrected use of 'cvals_len' value when allocating
      memory for input sting arrays so that the value used by the
      interface code has value plus one of the user value. This ensures
      each string in a string array has the room to add a null
      terminator.

      Added macros:

         CHECK_CALL_FAILURE_MEM2
         CHECK_CALL_FAILURE_MEM3
         CHECK_CALL_FAILURE_MEM4

      for use with cells.

      Altered  format of pack_cell call:

         cell = pack_cell( 0, tag_offset, Argv );

      to

         pack_cell( &cell, 0, tag_offset, Argv );

      Also, pack/unpack calls now pass cell pointers.

      New interfaces-

         1.2
         cspice_bodvcd
         cspice_diff
         cspice_insrtd
         cspice_insrti
         cspice_qdq2av
         cspice_qxq
         cspice_removd
         cspice_removi
         cspice_sdiff
         cspice_set
         cspice_srfrec
         cspice_union

      Vectorized-

         1.2
         cspice_illum
         cspice_insrti
         cspice_insrtd
         cspice_oscelt
         cspice_removd
         cspice_removi
         cspice_sce2c
         cspice_srfrec
         cspice_srfxpt
         cspice_subpt

   Icy 1.1.0 07-JAN-2005 (EDW)

      Reimplemented cspice_bodvrd using dynamic memory allocation based
      on the input 'maxn' variable. The previous version used a fixed
      size array for output.

      Added logic to return null terminated strings to IDL from those
      routines that return a string variable and a 'found' flag, setting
      the string only when found has value true, e.g.

         if ( *found )
            {
            S_STR_RET_ARGV( 1, name_buf);
            }
         else
            {
            S_STR_RET_ARGV( 1, "\n");
            }

      Added memory check test to cspice_getfov to eliminate memory leak
      on error.

      New interfaces-

         1.1
         cspice_bods2c
         cspice_card
         cspice_celli
         cspice_celld
         cspice_ckcov
         cspice_ckobj
         cspice_dafopw
         cspice_dafrs
         cspice_deltet
         cspice_et2lst
         cspice_lspcn
         cspice_pgrrec
         cspice_recpgr
         cspice_scard
         cspice_size
         cspice_spkcov
         cspice_spkobj
         cspice_ssize
         cspice_wn*d (windows set, 16 routines)

      Vectorized-

         1.1
         cspice_cylrec
         cspice_deltet
         cspice_et2lst
         cspice_et2utc
         cspice_georec
         cspice_latrec
         cspice_pxform
         cspice_pgrrec
         cspice_radrec
         cspice_reccyl
         cspice_recgeo
         cspice_reclat
         cspice_recpgr
         cspice_recrad
         cspice_recsph
         cspice_scdecd
         cspice_scencd
         cspice_scs2e
         cspice_sphrec
         cspice_spkezr
         cspice_spkpos
         cspice_str2et
         cspice_sxform
         cspice_timout

      Corrected 'lenout' expression to 'lenout + 1' for several string
      memory allocations lacking that proper assignment.

      Edited 'dtpool_c' interface to pass a char then copy that char to
      a char* string. Removed the unneeded '\0' assignments and
      related code for output strings.

      Added 'nelts' argument to 'cspice_ekrced' and 'cspice_ekrcei'.

      Moved definition macros to "icy.h." Moved memory allocation
      code to "zzalloc.c."

      Added VERSION keyword to cspice_icy call.

      Added 'cspice_checkargs_cleanup' calls to those blocks with
      'cspice_argbarf' error calls. Failure to include the cleanup
      call can (and usually does) cause memory corruption leading
      to bus errors.

      Edited header and comments.

   Icy 1.0.0 24-FEB-2004 (EDW)

-Index_Entries

   IDL interface Icy

*/


/*
IDL structure definitions.
*/
static void  * s_SpicePlane;
static void  * s_SpiceEllipse;
static void  * s_SpiceEKAttDsc;


/*
A small macro to output the usage string to the user. This function executes
when the number of arguments in an interface command does not equal the
expected value.
*/
#define USAGE(x) IDL_Message(IDL_M_GENERIC, IDL_MSG_LONGJMP, "Usage: "x );


void check_argcheck( int Argc, struct argcheck  *argcheck );


/*

   Interface Entry points. Starting here, we define the stubs used to
   interface IDL to CSPICE.

*/
FUNCTION CSPICE_ICY(int Argc, IDL_VPTR Argv_orig[], char *Argk)
  {

  IDL_VPTR          * Argv;
  struct extra_dims * extra;

  IDL_VPTR            retval_idl;
  ConstSpiceChar    * item;

  struct argcheck argcheck[] =
     {
     { OREAD, "item", (void*)IDL_TYP_STRING,  0, { 0 },    0},
     };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("string  = CSPICE_ICY( `item` )");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables. */
   item = S_STR_ARGV( 0 );

   /*
   Decide what to return based on the value of 'item.'

   retval_date contains the date string of the previous compilation
   of the interface.

   retval_time contains the time string of the previous compilation
   of the interface.
   */
   if (      eqstr_c( "DATE", item ) )
      {
      retval_idl = IDL_StrToSTRING( __DATE__ );
      }
   else if ( eqstr_c( "TIME", item ) )
      {
      retval_idl = IDL_StrToSTRING( __TIME__ );
      }
   else if ( eqstr_c( "VERSION", item ) )
      {
      retval_idl = IDL_StrToSTRING( VERSION  );
      }
   else
      {
      retval_idl = IDL_StrToSTRING( "UNKNOWN" );
      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              appndd_c ( SpiceDouble          item,
                                SpiceCell          * cell  );
*/
PROCEDURE CSPICE_APPNDD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset;
   SpiceDouble            item;
   SpiceCell              cell;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "item", (void*)IDL_TYP_DOUBLE, 0, { 0 }, 1},
      { RDWRT, "cell", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_APPNDD, _item_, (CELL)");
      }


   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[1].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[1]->value.s.arr->data);
   pack_cell( &cell, 1, tag_offset, Argv );

   /* Did the user pass a vector for input? */
   if (extra->ndims == 0)
      {

      item = S_DBL_ARGV( 0 );

      appndd_c ( item, &cell );

      /*
       Test for a SPICE error signal. If found, display an error message to the
       user then return to the IDL application.
       */
      CHECK_CALL_FAILURE_MEM2( cell, SCALAR );
      }
   else
      {
      /* Vector input.*/

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         item = ((SpiceDouble*)(Argv[0]->value.arr->data))[i];

         appndd_c ( item, &cell );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE_MEM2( cell, i );
         }

      }

   /*
   Unpack the data from 'window' to 'Argv'.
   */
   unpack_cell( 1, tag_offset, &cell, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              appndi_c ( SpiceInt             item,
                                SpiceCell          * cell  );
*/
PROCEDURE CSPICE_APPNDI(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset;
   SpiceInt               item;
   SpiceCell              cell;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "item", (void*)IDL_TYP_LONG,   0, { 0 }, 1},
      { RDWRT, "cell", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_APPNDI, _item_, (CELL)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[1].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*)(Argv[1]->value.s.arr->data);
   pack_cell( &cell, 1, tag_offset, Argv );

   /* Did the user pass a vector for input? */
   if (extra->ndims == 0)
      {

      item = S_INT_ARGV( 0 );

      appndi_c ( item, &cell );

      /*
      Test for a SPICE error signal. If found, display an error message to the
      user then return to the IDL application.
      */
      CHECK_CALL_FAILURE_MEM2( cell, SCALAR );
      }
   else
      {
      /* Vector input.*/

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         item = ((SpiceInt*)(Argv[0]->value.arr->data))[i];

         appndi_c ( item, &cell );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE_MEM2( cell, i );
         }

      }

   /*
   Unpack the data from 'window' to 'Argv'.
   */
   unpack_cell( 1, tag_offset, &cell, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




static FUNCTION CSPICE_CELLD (int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             size;
   IDL_VPTR             cell;

   struct argcheck argcheck[] =
      {
      { OREAD, "size", (void*)IDL_TYP_LONG,  0, { 0 }, 0}
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("cell = CSPICE_CELLD(size)");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   size  = S_INT_ARGV(0);

   if ( size <= (SpiceInt)1)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(0, "size", IDL_VarName(Argv_orig[0]),
      "Cell size must exceed 1 element.");
      }

   cell = icy_cell( SPICE_DP, size, 0 );

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return cell;
   }




static FUNCTION CSPICE_CELLI (int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             size;
   IDL_VPTR             cell;

   struct argcheck argcheck[] =
      {
      { OREAD, "size", (void*)IDL_TYP_LONG,  0, { 0 }, 0}
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("cell = CSPICE_CELLI(size)");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   size  = S_INT_ARGV(0);

   if ( size <= (SpiceInt)1)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(0, "size", IDL_VarName(Argv_orig[0]),
      "Cell size must exceed 1 element.");
      }

   cell = icy_cell( SPICE_INT, size, 0 );

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return cell;
   }




/*

   All following PROCEDURE and FUNCTION routines perform some interface to
   the CSPICE library.

*/





/*
   void              axisar_c ( ConstSpiceDouble   axis   [3],
                                SpiceDouble        angle,
                                SpiceDouble        r      [3][3]  )
*/
PROCEDURE CSPICE_AXISAR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * axis;
   SpiceDouble          angle;
   SpiceDouble        * r;

   struct argcheck argcheck[] =
      {
      { OREAD, "axis",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "angle", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "r",     (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_AXISAR, axis[3], angle, R[3,3]");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   axis  = A_DBL_ARGV( 0 );
   angle = S_DBL_ARGV( 1 );
   r     = A_DBL_ARGV( 2 );

   (void) axisar_c (axis, angle, (SpiceDouble (*)[3])r);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceBoolean      badkpv_c ( ConstSpiceChar    *caller,
                                ConstSpiceChar    *name,
                                ConstSpiceChar    *comp,
                                SpiceInt           size,
                                SpiceInt           divby,
                                SpiceChar          type   )
*/
PROCEDURE CSPICE_BADKPV(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceBoolean         retval_c;
   SpiceChar          * caller;
   SpiceChar          * name;
   SpiceChar          * comp;
   SpiceInt             size;
   SpiceInt             divby;
   SpiceChar          * type;

   struct argcheck argcheck[] =
      {
      { OREAD, "caller",(void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "name",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "comp",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "size",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "divby", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "type",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_BADKPV, `caller`, `name`, `comp`, "
            "size, divby, `type`");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   caller = S_STR_ARGV( 0 );
   name   = S_STR_ARGV( 1 );
   comp   = S_STR_ARGV( 2 );
   size   = S_INT_ARGV( 3 );
   divby  = S_INT_ARGV( 4 );
   type   = S_STR_ARGV( 5 );

   /*
   Despite the use of a return variable, this interface does not return a
   value to the IDL environment. A badkpv_c failure causes a SPICE error.
   */
   retval_c = badkpv_c( caller,
                        name,
                        comp,
                        size,
                        divby,
                        (SpiceChar)type[0]);

   /*
   Test for a SPICE error signal. If found, display an error message
   to the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              bodc2n_c ( SpiceInt           code,
                                SpiceInt           namelen,
                                SpiceChar        * name,
                                SpiceBoolean     * found   )
*/
PROCEDURE CSPICE_BODC2N(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             code;
   SpiceChar            name_buf[RET_ARRAY_LEN+1];
   SpiceBoolean         found;

   struct argcheck argcheck[] =
      {
      { OREAD, "code",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "name",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "found", (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_BODC2N, code, `NAME`, FOUND");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   code     = S_INT_ARGV( 0 );

   /* Scalar */
   bodc2n_c( code, RET_ARRAY_LEN, name_buf, &found);

   /*
   Test for a SPICE error signal. If found, display an error message
   to the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /*
   Note, this is a copy operation.
   */
   if ( found )
      {
      S_STR_RET_ARGV( 1, name_buf);
      }
   else
      {
      S_STR_RET_ARGV( 1, "\0");
      }

   Argv[2]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              bodc2s_c ( SpiceInt        code,
                                SpiceInt        lenout,
                                SpiceChar     * name )

*/
PROCEDURE CSPICE_BODC2S(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             code;
   SpiceChar            name_buf[RET_ARRAY_LEN+1];

   struct argcheck argcheck[] =
      {
      { OREAD, "code",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "name",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_BODC2S, code, `NAME`");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   code     = S_INT_ARGV( 0 );

   /* Scalar */
   (void) bodc2s_c ( code, RET_ARRAY_LEN, name_buf );

   /*
   Test for a SPICE error signal. If found, display an error message
   to the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV( 1, name_buf);

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              boddef_c ( ConstSpiceChar   * name,
                                SpiceInt           code )
*/
PROCEDURE CSPICE_BODDEF(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * name;
   SpiceInt             code;

   struct argcheck argcheck[] =
      {
      { OREAD, "name", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "code", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_BODDEF, `name`, code");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   name = S_STR_ARGV( 0 );
   code = S_INT_ARGV( 1 );

   (void) boddef_c (name,code);

   /*
   Test for a SPICE error signal. If found, display an error message
   to the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceBoolean      bodfnd_c ( SpiceInt           body,
                                ConstSpiceChar   * item )
*/
FUNCTION CSPICE_BODFND(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl = NULL;
   SpiceBoolean         retval_c;
   SpiceInt             body;
   SpiceChar          * item;

   struct argcheck argcheck[] =
      {
      { OREAD, "body", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "item", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("boolean = CSPICE_BODFND( body, `item` )");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   body = S_INT_ARGV( 0 );
   item = S_STR_ARGV( 1 );

   /* Scalar */
   retval_c = bodfnd_c(body,item);

   /*
   Test for a SPICE error signal. If found, display an error message
   to the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_BYTE;
   retval_idl->value.c  = (RETURN_BOOL) retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              bodn2c_c ( ConstSpiceChar   * name,
                                SpiceInt         * code,
                                SpiceBoolean     * found )
*/
PROCEDURE CSPICE_BODN2C(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * name;
   SpiceInt             code;
   SpiceBoolean         found;

   struct argcheck argcheck[] =
      {
      { OREAD, "name",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "code",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "found", (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_BODN2C, `name`, CODE, FOUND");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   name  = S_STR_ARGV( 0 );

   /* Scalar */
   (void) bodn2c_c (name, &code, &found);

   /*
   Test for a SPICE error signal. If found, display an error message
   to the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.l = code;
   Argv[2]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
 void              bods2c_c ( ConstSpiceChar   * name,
                              SpiceInt         * code,
                              SpiceBoolean     * found )
 */
PROCEDURE CSPICE_BODS2C(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * name;
   SpiceInt             code;
   SpiceBoolean         found;

   struct argcheck argcheck[] =
      {
      { OREAD, "name",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "code",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "found", (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_BODS2C, `name`, CODE, FOUND");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   name  = S_STR_ARGV( 0 );

   /* Scalar */
   (void) bods2c_c (name, &code, &found);

   /*
   Test for a SPICE error signal. If found, display an error message
   to the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.l = code;
   Argv[2]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              bodvar_c ( SpiceInt           body,
                                ConstSpiceChar   * item,
                                SpiceInt         * dim,
                                SpiceDouble      * values )
*/
PROCEDURE CSPICE_BODVAR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             body;
   SpiceChar          * item;
   SpiceInt             values_dim;
   SpiceDouble          values[RET_ARRAY_LEN];

   struct argcheck argcheck[] =
      {
      { OREAD, "body",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "item",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "values", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_BODVAR, body, `item`, VALUES[]");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   body       = S_INT_ARGV( 0 );
   item       = S_STR_ARGV( 1 );
   values_dim = 0;

   (void) bodvar_c (body, item, &values_dim, values);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   if (values_dim != 0)
      {
      char       * values_copy;
      int          tmp_ndims;
      IDL_MEMINT   tmp_dims[IDL_MAX_ARRAY_DIM];

      /*
      Check 'values_dim' not greater than the 'values' array.
      Alter 'values_dim' if necessary.
      */
      if ( values_dim > RET_ARRAY_LEN )
         {
         values_dim = RET_ARRAY_LEN;
         }

      tmp_ndims   = 1;
      tmp_dims[0] = values_dim;
      values_copy = IDL_MakeTempArray(IDL_TYP_DOUBLE, tmp_ndims, tmp_dims,
                                      IDL_ARR_INI_NOP, &Argv[2]);

      memmove(values_copy, values, values_dim * sizeof(SpiceDouble) );
      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              bodvcd_c ( SpiceInt           * bodyid,
                                ConstSpiceChar     * item,
                                SpiceInt             maxn,
                                SpiceInt           * dim,
                                SpiceDouble        * values );

*/
PROCEDURE CSPICE_BODVCD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             bodyid;
   SpiceChar          * item;
   SpiceInt             maxn;
   SpiceInt             values_dim;
   SpiceDouble        * values;

   struct argcheck argcheck[] =
      {
      { OREAD, "bodyid", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "item",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "maxn",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "values", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_BODVCD, bodyid, `item`, maxn, VALUES[]" );
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   bodyid     = S_INT_ARGV( 0 );
   item       = S_STR_ARGV( 1 );
   maxn       = S_INT_ARGV( 2 );
   values_dim = 0;

   /*
   Allocate the necessary memory for 'values'. Check for an error signal.
   */
   values = alloc_SpiceDouble_C_array ( 1, (int) maxn );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   (void) bodvcd_c ( bodyid, item, maxn, &values_dim, values);

   /* Check for SPICE call failure, clean up if failed. */
   if ( failed_c())
      {
      free_SpiceMemory( values );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }


   if (values_dim != 0)
      {
      char       * values_copy;
      int          tmp_ndims;
      IDL_MEMINT   tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = values_dim;
      values_copy = IDL_MakeTempArray(IDL_TYP_DOUBLE, tmp_ndims, tmp_dims,
                                      IDL_ARR_INI_NOP, &Argv[3]);

      memmove(values_copy, values, values_dim * sizeof(SpiceDouble) );
      }


   /*
   Clean up temporary variables
   */
   free_SpiceMemory( values );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*

   void              bodvrd_c ( ConstSpiceChar     * bodynm,
                                ConstSpiceChar     * item,
                                SpiceInt             maxn,
                                SpiceInt           * dim,
                                SpiceDouble        * values );

*/
PROCEDURE CSPICE_BODVRD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * bodynm;
   SpiceChar          * item;
   SpiceInt             maxn;
   SpiceInt             values_dim;
   SpiceDouble        * values;

   struct argcheck argcheck[] =
      {
      { OREAD, "bodynm", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "item",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "maxn",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "values", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_BODVRD, `bodynm`, `item`, maxn, VALUES[]" );
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   bodynm     = S_STR_ARGV( 0 );
   item       = S_STR_ARGV( 1 );
   maxn       = S_INT_ARGV( 2 );
   values_dim = 0;

   /*
   Allocate the necessary memory for 'values'. Check for an error signal.
   */
   values = alloc_SpiceDouble_C_array ( 1, (int) maxn );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   (void) bodvrd_c ( bodynm, item, maxn, &values_dim, values);

   /* Check for SPICE call failure, clean up if failed. */
   if ( failed_c())
      {
      free_SpiceMemory( values );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }


   if (values_dim != 0)
      {
      char       * values_copy;
      int          tmp_ndims;
      IDL_MEMINT   tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = values_dim;
      values_copy = IDL_MakeTempArray(IDL_TYP_DOUBLE, tmp_ndims, tmp_dims,
                                      IDL_ARR_INI_NOP, &Argv[3]);

      memmove(values_copy, values, values_dim * sizeof(SpiceDouble) );
      }


   /*
   Clean up temporary variables
   */
   free_SpiceMemory( values );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceDouble       brcktd_c ( SpiceDouble        number,
                                SpiceDouble        end1,
                                SpiceDouble        end2    )
*/
FUNCTION CSPICE_BRCKTD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR    * Argv;
   struct        extra_dims *extra;
   IDL_VPTR      retval_idl;
   SpiceDouble   retval_c;
   SpiceDouble   number;
   SpiceDouble   end1;
   SpiceDouble   end2;

   struct argcheck argcheck[] =
      {
      { OREAD, "number", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "end1",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "end2",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("double  = CSPICE_BRCKTD( number, end1, end2 )");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   number = S_DBL_ARGV( 0 );
   end1   = S_DBL_ARGV( 1 );
   end2   = S_DBL_ARGV( 2 );

   retval_c = brcktd_c(number,end1,end2);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   SpiceInt          brckti_c ( SpiceInt           number,
                                SpiceInt           end1,
                                SpiceInt           end2    )
*/
FUNCTION CSPICE_BRCKTI(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceInt             retval_c;
   SpiceInt             number;
   SpiceInt             end1;
   SpiceInt             end2;

   struct argcheck argcheck[] =
      {
      { OREAD, "number", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "end1",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "end2",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("integer = CSPICE_BRCKTI( number, end1, end2 )");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   number  = S_INT_ARGV( 0 );
   end1    = S_INT_ARGV( 1 );
   end2    = S_INT_ARGV( 2 );

   retval_c = brckti_c( number, end1, end2);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_LONG;
   retval_idl->value.l  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   SpiceDouble       b1900_c  ( void )
*/
FUNCTION CSPICE_B1900(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR     retval_idl;
   SpiceDouble  retval_c;

   /* Check the input contains the correct number of arguments. */
   if (Argc != 0)
      {
      USAGE("double  = CSPICE_B1900()");
      }

   retval_c = b1900_c();

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   return retval_idl;
   }




/*
   SpiceDouble       b1950_c  ( void )
*/
FUNCTION CSPICE_B1950(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR     retval_idl;

   SpiceDouble  retval_c;

   /* Check the input contains the correct number of arguments. */
   if (Argc != 0)
      {
      USAGE("double  = CSPICE_B1950()");
      }

   retval_c = b1950_c();

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   return retval_idl;
   }




/*
   SpiceInt          card_c   ( SpiceCell         * cell );
*/
FUNCTION CSPICE_CARD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;

   IDL_VPTR               retval_idl = NULL;

   SpiceInt               retval_c;
   SpiceInt             * tag_offset;
   SpiceCell              cell;

   struct argcheck argcheck[] =
      {
      { OREAD, "cell", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("integer = CSPICE_CARD( (cell) )");
      }


   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[0].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[0]->value.s.arr->data);
   pack_cell( &cell, 0, tag_offset, Argv );

   retval_c   = card_c ( &cell );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( cell, SCALAR );

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_LONG;
   retval_idl->value.l  = retval_c;

   unpack_cell( 0, tag_offset,  &cell, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              ccifrm_c ( SpiceInt          frclss,
                                SpiceInt          clssid,
                                SpiceInt          lenout,
                                SpiceInt        * frcode,
                                SpiceChar       * frname,
                                SpiceInt        * center,
                                SpiceBoolean    * found   )
*/
PROCEDURE CSPICE_CCIFRM(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              frclss;
   SpiceInt              clssid;
   SpiceInt              frcode;
   SpiceChar             frname_buf[RET_ARRAY_LEN+1];
   SpiceInt              center;
   SpiceBoolean          found;

   struct argcheck argcheck[] =
      {
      { OREAD, "frclss", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "clssid", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "frcode", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "frname", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "center", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_CCIFRM, frclss, clssid, FRCODE, `FRNAME`, CENTER, FOUND");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   frclss        = S_INT_ARGV( 0 );
   clssid        = S_INT_ARGV( 1 );

   (void) ccifrm_c ( frclss,
              clssid,
              RET_ARRAY_LEN,
              &frcode,
              frname_buf,
              &center,
              &found   );
   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[2]->value.l = frcode;

   /*
   Note, this is a copy operation.
   */
   if ( found )
      {
      S_STR_RET_ARGV( 3, frname_buf );
      }
   else
      {
      S_STR_RET_ARGV( 3, "\0" );
      }

   Argv[4]->value.l = center;

   Argv[5]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }



/*
   void              cgv2el_c ( ConstSpiceDouble    center[3],
                                ConstSpiceDouble    vec1  [3],
                                ConstSpiceDouble    vec2  [3],
                                SpiceEllipse      * ellipse   )
*/
PROCEDURE CSPICE_CGV2EL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * center;
   SpiceDouble         * vec1;
   SpiceDouble         * vec2;
   SpiceEllipse        * ellipse;

   struct argcheck argcheck[] =
      {
      { OREAD, "center",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "vec1",    (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "vec2",    (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "ellipse", (void*)IDL_TYP_STRUCT,  0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_CGV2EL, center[3], vec1[3], vec2[3], ELLIPSE");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[3].type = s_SpiceEllipse;

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   center   = A_DBL_ARGV( 0 );
   vec1     = A_DBL_ARGV( 1 );
   vec2     = A_DBL_ARGV( 2 );
   ellipse  = S_ELL_ARGV( 3 );

   (void) cgv2el_c (center,vec1,vec2,ellipse);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              cidfrm_c ( SpiceInt            cent,
                                SpiceInt            lenout,
                                SpiceInt          * frcode,
                                SpiceChar         * frname,
                                SpiceBoolean      * found  )
*/
PROCEDURE CSPICE_CIDFRM(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              cent;
   SpiceInt              frcode;
   SpiceChar             frname_buf[RET_ARRAY_LEN+1];
   SpiceBoolean          found;

   struct argcheck argcheck[] =
      {
      { OREAD, "cent",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "frcode", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "frname", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_CIDFRM, cent, FRCODE, `FRNAME`, FOUND");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   cent        = S_INT_ARGV( 0 );

   (void) cidfrm_c ( cent, RET_ARRAY_LEN, &frcode, frname_buf, &found);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.l = frcode;

   /*
   Note, this is a copy operation.
   */
   if ( found )
      {
      S_STR_RET_ARGV( 2, frname_buf );
      }
   else
      {
      S_STR_RET_ARGV( 2, "\0" );
      }


   Argv[3]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ckcls_c  ( SpiceInt            handle )
*/
PROCEDURE CSPICE_CKCLS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_CKCLS, handle");
      }


   extra  = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle = S_INT_ARGV( 0 );

   (void) ckcls_c (handle);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }






/*

 void              ckcov_c ( ConstSpiceChar    * ck,
                             SpiceInt            idcode,
                             SpiceBoolean        needav,
                             ConstSpiceChar    * level,
                             SpiceDouble         tol,
                             ConstSpiceChar    * timsys,
                             SpiceCell         * cover   )

 */
PROCEDURE CSPICE_CKCOV(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset;
   SpiceChar            * ck;
   SpiceInt               idcode;
   SpiceBoolean           needav;
   SpiceChar            * level;
   SpiceDouble            tol;
   SpiceChar            * timsys;
   SpiceCell              cover;

   struct argcheck argcheck[] =
      {
      { OREAD, "ck",     (void*)IDL_TYP_STRING, 0, { 0 }, 0},
      { OREAD, "idcode", (void*)IDL_TYP_LONG,   0, { 0 }, 0},
      { OREAD, "needav", (void*)IDL_TYP_BYTE,   0, { 0 }, 0},
      { OREAD, "level",  (void*)IDL_TYP_STRING, 0, { 0 }, 0},
      { OREAD, "tol",    (void*)IDL_TYP_DOUBLE, 0, { 0 }, 0},
      { OREAD, "timsys", (void*)IDL_TYP_STRING, 0, { 0 }, 0},
      { RDWRT, "cover",  (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_CKCOV, `ck`, idcode, needav, level, tol, timsys, (COVER)");
      }


   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[6].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   ck     = S_STR_ARGV( 0 );
   idcode = S_INT_ARGV( 1 );
   needav = S_BOOL_ARGV( 2 );
   level  = S_STR_ARGV( 3 );
   tol    = S_DBL_ARGV( 4 );
   timsys = S_STR_ARGV( 5 );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[6]->value.s.arr->data);
   pack_cell( &cover, 6, tag_offset, Argv );

   (void) ckcov_c ( ck, idcode, needav, level, tol, timsys, &cover );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( cover, SCALAR );

   /*
   Unpack the data from 'cover' to 'Argv'.
   */
   unpack_cell( 6, tag_offset, &cover, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ckgp_c   ( SpiceInt            inst,
                                SpiceDouble         sclkdp,
                                SpiceDouble         tol,
                                ConstSpiceChar    * ref,
                                SpiceDouble         cmat[3][3],
                                SpiceDouble       * clkout,
                                SpiceBoolean      * found      )
*/
PROCEDURE CSPICE_CKGP(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              inst;
   SpiceDouble           sclkdp;
   SpiceDouble           tol;
   SpiceChar           * ref;
   SpiceDouble         * cmat;
   SpiceDouble           clkout;
   SpiceBoolean          found;

   struct argcheck argcheck[] =
      {
      { OREAD, "inst",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "sclkdp", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "tol",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "ref",    (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "cmat",   (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      { OWRIT, "clkout", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_CKGP, inst, sclkdp, tol, `ref`, CMAT[3,3], "
                    "CLKOUT, FOUND");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   inst    = S_INT_ARGV( 0 );
   sclkdp  = S_DBL_ARGV( 1 );
   tol     = S_DBL_ARGV( 2 );
   ref     = S_STR_ARGV( 3 );
   cmat    = A_DBL_ARGV( 4 );

   /* Scalar */
   (void) ckgp_c( inst,
           sclkdp,
           tol,
           ref,
           (SpiceDouble (*)[3])cmat,
           &clkout,
           &found);

   /*
   Test for a SPICE error signal. If found, display an error message
   to the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[5]->value.d = clkout;
   Argv[6]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ckgpav_c ( SpiceInt            inst,
                                SpiceDouble         sclkdp,
                                SpiceDouble         tol,
                                ConstSpiceChar    * ref,
                                SpiceDouble         cmat[3][3],
                                SpiceDouble         av[3],
                                SpiceDouble       * clkout,
                                SpiceBoolean      * found      )
*/
PROCEDURE CSPICE_CKGPAV(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              inst;
   SpiceDouble           sclkdp;
   SpiceDouble           tol;
   SpiceChar           * ref;
   SpiceDouble         * cmat;
   SpiceDouble         * av;
   SpiceDouble           clkout;
   SpiceBoolean          found;

   struct argcheck argcheck[] =
      {
      { OREAD, "inst",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "sclkdp", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "tol",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "ref",    (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "cmat",   (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      { OWRIT, "av",     (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "clkout", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 8)
      {
      USAGE("CSPICE_CKGPAV, inst, sclkdp, tol, `ref`, "
            "CMAT[3,3], AV[3], CLKOUT, FOUND");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   inst   = S_INT_ARGV( 0 );
   sclkdp = S_DBL_ARGV( 1 );
   tol    = S_DBL_ARGV( 2 );
   ref    = S_STR_ARGV( 3 );
   cmat   = A_DBL_ARGV( 4 );
   av     = A_DBL_ARGV( 5 );

   /* Scalar */
   (void) ckgpav_c(inst,
            sclkdp,
            tol,
            ref,
            (SpiceDouble (*)[3])cmat,
            av,
            &clkout,
            &found);

   /*
   Test for a SPICE error signal. If found, display an error message
   to the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[6]->value.d = clkout;
   Argv[7]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              cklpf_c  ( ConstSpiceChar    * fname,
                                SpiceInt          * handle    )
*/
PROCEDURE CSPICE_CKLPF(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * fname;
   SpiceInt              handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "fname",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_CKLPF, `fname`, HANDLE");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   fname      = S_STR_ARGV( 0 );

   (void) cklpf_c ( fname, &handle);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.l = handle;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*

 void              ckobj_c ( ConstSpiceChar  * ck,
                             SpiceCell       * ids )

 */
PROCEDURE CSPICE_CKOBJ(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset;
   SpiceChar            * ck;
   SpiceCell              ids;

   struct argcheck argcheck[] =
      {
      { OREAD, "ck",  (void*)IDL_TYP_STRING, 0, { 0 }, 0},
      { RDWRT, "ids", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_CKOBJ, ck, (IDS)");
      }


   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[1].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   ck = S_STR_ARGV( 0 );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[1]->value.s.arr->data);
   pack_cell( &ids, 1, tag_offset, Argv );

   (void) ckobj_c ( ck, &ids );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( ids, SCALAR );

   /*
   Unpack the data from 'ids' to 'Argv'.
   */
   unpack_cell( 1, tag_offset, &ids, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ckopn_c  ( ConstSpiceChar    * name,
                                ConstSpiceChar    * ifname,
                                SpiceInt            ncomch,
                                SpiceInt          * handle  )
*/
PROCEDURE CSPICE_CKOPN(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * name;
   SpiceChar           * ifname;
   SpiceInt              ncomch;
   SpiceInt              handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "name",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "ifname", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "ncomch", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_CKOPN, `name`, `ifname`, ncomch, HANDLE");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   name   = S_STR_ARGV( 0 );
   ifname = S_STR_ARGV( 1 );
   ncomch = S_INT_ARGV( 2 );

   (void) ckopn_c ( name, ifname, ncomch, &handle);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[3]->value.l = handle;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ckupf_c  ( SpiceInt            handle )
*/
PROCEDURE CSPICE_CKUPF(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_CKUPF, handle");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle = S_INT_ARGV( 0 );

   ckupf_c(handle);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ckw01_c  ( SpiceInt            handle,
                                SpiceDouble         begtime,
                                SpiceDouble         endtime,
                                SpiceInt            inst,
                                ConstSpiceChar    * ref,
                                SpiceBoolean        avflag,
                                ConstSpiceChar    * segid,
                                SpiceInt            nrec,
                                ConstSpiceDouble    sclkdp [],
                                ConstSpiceDouble    quats  [][4],
                                ConstSpiceDouble    avvs   [][3]  )
*/
PROCEDURE CSPICE_CKW01(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceDouble          begtime;
   SpiceDouble          endtime;
   SpiceInt             inst;
   SpiceChar          * ref;
   SpiceBoolean         avflag;
   SpiceChar          * segid;
   SpiceInt             sclkdp_size;

   ConstSpiceDouble   * sclkdp;
   ConstSpiceDouble   * quats;
   ConstSpiceDouble   * avvs;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "begtime", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "endtime", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "inst",    (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "ref",     (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "avflag",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      { OREAD, "segid",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "sclkdp",  (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OREAD, "quats",   (void*)IDL_TYP_DOUBLE,  2, { 4, 0 }, 0},
      { OREAD, "avvs",    (void*)IDL_TYP_DOUBLE,  2, { 3, 0 }, 0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 10)
      {
      USAGE("CSPICE_CKW01, handle, begtime, endtime, inst, `ref`, "
            "avflag, `segid`, sclkdp[N], quats[4,N], avvs[3,N]");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Retrieve input array dimensions (to pass on to C) */
   sclkdp_size = (SpiceInt)Argv[7]->value.arr->dim[0];

   /* Check dimensions of input arrays */
   if (Argv[8]->value.arr->dim[1] != sclkdp_size)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(8, "quats", IDL_VarName(Argv_orig[8]),
                     "Matrix `quats` must have the same "
                     "measure of vectorization as `sclkdp`");
      }

   if (Argv[9]->value.arr->dim[1] != sclkdp_size)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(9, "avvs", IDL_VarName(Argv_orig[9]),
                     "Matrix `avvs` must have the same "
                     "measure of vectorization as `sclkdp`");
      }

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   begtime    = S_DBL_ARGV( 1 );
   endtime    = S_DBL_ARGV( 2 );
   inst       = S_INT_ARGV( 3 );
   ref        = S_STR_ARGV( 4 );
   avflag     = S_BOOL_ARGV( 5 );
   segid      = S_STR_ARGV( 6 );
   sclkdp     = (ConstSpiceDouble*)Argv[7]->value.arr->data;
   quats      = (ConstSpiceDouble*)Argv[8]->value.arr->data;
   avvs       = (ConstSpiceDouble*)Argv[9]->value.arr->data;

   ckw01_c( handle,
            begtime,
            endtime,
            inst,
            ref,
            avflag,
            segid,
            sclkdp_size,
            sclkdp,
            (ConstSpiceDouble (*)[4])quats,
            (Nx3d)avvs);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ckw02_c  ( SpiceInt            handle,
                                SpiceDouble         begtim,
                                SpiceDouble         endtim,
                                SpiceInt            inst,
                                ConstSpiceChar    * ref,
                                ConstSpiceChar    * segid,
                                SpiceInt            nrec,
                                ConstSpiceDouble    start  [],
                                ConstSpiceDouble    stop   [],
                                ConstSpiceDouble    quats  [][4],
                                ConstSpiceDouble    avvs   [][3],
                                ConstSpiceDouble    rates  []    )
*/
PROCEDURE CSPICE_CKW02(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceDouble          begtim;
   SpiceDouble          endtim;
   SpiceInt             inst;
   SpiceChar          * ref;
   SpiceChar          * segid;
   SpiceInt             start_size;
   ConstSpiceDouble   * start;
   ConstSpiceDouble   * stop;
   ConstSpiceDouble   * quats;
   ConstSpiceDouble   * avvs;
   ConstSpiceDouble   * rates;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "begtim", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "endtim", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "inst",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "ref",    (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "segid",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "start",  (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OREAD, "stop",   (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OREAD, "quats",  (void*)IDL_TYP_DOUBLE,  2, { 4, 0 }, 0},
      { OREAD, "avvs",   (void*)IDL_TYP_DOUBLE,  2, { 3, 0 }, 0},
      { OREAD, "rates",  (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 11)
      {
      USAGE("CSPICE_CKW02, handle, begtim, endtim, inst, `ref`, "
            "`segid`, start[N], stop[N], quats[4,N], avvs[3,N], rates[N]");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Retrieve input array dimensions (to pass on to C) */
   start_size = (SpiceInt)Argv[6]->value.arr->dim[0];

   /* Check dimensions of input arrays. Do this explicitly since
      the size has arbitrary value (positive definite).
   */
   if (Argv[7]->value.arr->dim[0] != start_size)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(7, "stop", IDL_VarName(Argv_orig[7]),
                     "Array `stop` must have the same "
                     "measure of vectorization as `start`");
      }

   if (Argv[8]->value.arr->dim[1] != start_size)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(8, "quats", IDL_VarName(Argv_orig[8]),
                     "Matrix `quats` must have the same "
                     "measure of vectorization as `start`");
      }

   if (Argv[9]->value.arr->dim[1] != start_size)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(9, "avvs", IDL_VarName(Argv_orig[9]),
                     "Matrix `aavs` must have the same "
                     "measure of vectorization as `start`");
      }

   if (Argv[10]->value.arr->dim[0] != start_size)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(10, "rates", IDL_VarName(Argv_orig[10]),
                     "Array `rates` must have the same "
                     "measure of vectorization as `start`");
      }


   /* Initialize local variables, to pass to CSPICE */
   handle  = S_INT_ARGV( 0 );
   begtim  = S_DBL_ARGV( 1 );
   endtim  = S_DBL_ARGV( 2 );
   inst    = S_INT_ARGV( 3 );
   ref     = S_STR_ARGV( 4 );
   segid   = S_STR_ARGV( 5 );
   start   = (ConstSpiceDouble*)Argv[6]->value.arr->data;
   stop    = (ConstSpiceDouble*)Argv[7]->value.arr->data;
   quats   = (ConstSpiceDouble*)Argv[8]->value.arr->data;
   avvs    = (ConstSpiceDouble*)Argv[9]->value.arr->data;
   rates   = (ConstSpiceDouble*)Argv[10]->value.arr->data;

   ckw02_c( handle,
            begtim,
            endtim,
            inst,
            ref,
            segid,
            start_size,
            start,
            stop,
            (ConstSpiceDouble (*)[4])quats,
            (Nx3d)avvs,
            rates);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ckw03_c  ( SpiceInt            handle,
                                SpiceDouble         begtim,
                                SpiceDouble         endtim,
                                SpiceInt            inst,
                                ConstSpiceChar    * ref,
                                SpiceBoolean        avflag,
                                ConstSpiceChar    * segid,
                                SpiceInt            nrec,
                                ConstSpiceDouble    sclkdp [],
                                ConstSpiceDouble    quats  [][4],
                                ConstSpiceDouble    avvs   [][3],
                                SpiceInt            nints,
                                ConstSpiceDouble    starts []     )
*/
PROCEDURE CSPICE_CKW03(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceDouble          begtim;
   SpiceDouble          endtim;
   SpiceInt             inst;
   SpiceChar          * ref;
   SpiceBoolean         avflag;
   SpiceChar          * segid;
   SpiceInt             sclkdp_size;
   ConstSpiceDouble   * sclkdp;
   ConstSpiceDouble   * quats;
   ConstSpiceDouble   * avvs;
   SpiceInt             starts_size;
   ConstSpiceDouble   * starts;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "begtim", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "endtim", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "inst",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "ref",    (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "avflag", (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      { OREAD, "segid",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "sclkdp", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OREAD, "quats",  (void*)IDL_TYP_DOUBLE,  2, { 4, 0 }, 0},
      { OREAD, "avvs",   (void*)IDL_TYP_DOUBLE,  2, { 3, 0 }, 0},
      { OREAD, "starts", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 11)
      {
      USAGE("CSPICE_CKW03, handle, begtim, endtim, inst, `ref`, "
            "avflag, `segid`, sclkdp[N], quats[4,N], avvs[3,N], starts[M]");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Retrieve input array dimensions (to pass on to C) */
   sclkdp_size = (SpiceInt)Argv[7]->value.arr->dim[0];
   starts_size = (SpiceInt)Argv[10]->value.arr->dim[0];

   /* Check dimensions of input arrays */
   if (Argv[8]->value.arr->dim[1] != sclkdp_size)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(8, "quats", IDL_VarName(Argv_orig[8]),
                     "Matrix `quats` must have the same "
                     "measure of vectorization as `sclkdp`");
      }

   if (Argv[9]->value.arr->dim[1] != sclkdp_size)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(9, "avvs", IDL_VarName(Argv_orig[9]),
                     "Matrix `avvs` must have the same "
                     "measure of vectorization as `sclkdp`");
      }


   /* Initialize local variables, to pass to CSPICE */
   handle  = S_INT_ARGV( 0 );
   begtim  = S_DBL_ARGV( 1 );
   endtim  = S_DBL_ARGV( 2 );
   inst    = S_INT_ARGV( 3 );
   ref     = S_STR_ARGV( 4 );
   avflag  = S_BOOL_ARGV( 5 );
   segid   = S_STR_ARGV( 6 );
   sclkdp  = (ConstSpiceDouble*)Argv[7]->value.arr->data;
   quats   = (ConstSpiceDouble*)Argv[8]->value.arr->data;
   avvs    = (ConstSpiceDouble*)Argv[9]->value.arr->data;
   starts  = (ConstSpiceDouble*)Argv[10]->value.arr->data;

   ckw03_c( handle,
            begtim,
            endtim,
            inst,
            ref,
            avflag,
            segid,
            sclkdp_size,
            sclkdp,
           (ConstSpiceDouble (*)[4])quats,
           (Nx3d)avvs,
           starts_size,
           starts);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceDouble       clight_c ( void )
*/
FUNCTION CSPICE_CLIGHT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR     retval_idl;
   SpiceDouble  retval_c;

   /* Check the input contains the correct number of arguments. */
   if (Argc != 0)
      {
      USAGE("double  = CSPICE_CLIGHT()");
      }

   retval_c = clight_c();

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   return retval_idl;
   }




/*
   void              clpool_c ( void )
*/
PROCEDURE CSPICE_CLPOOL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   /* Check the input contains the correct number of arguments. */
   if (Argc != 0)
      {
      USAGE("CSPICE_CLPOOL");
      }

   clpool_c();

   if ( failed_c())
      {
      icy_fail(SCALAR);
      }
   }




/*
   void              cmprss_c ( SpiceChar           delim,
                                SpiceInt            n,
                                ConstSpiceChar    * input,
                                SpiceInt            lenout,
                                SpiceChar         * output  )
*/
PROCEDURE CSPICE_CMPRSS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar             delim;
   SpiceInt              n;
   SpiceChar           * input;
   SpiceChar           * output;

   struct argcheck argcheck[] =
      {
      { OREAD, "delim",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "n",      (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "input",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "output", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_CMPRSS, `delim`, n, `input`, `OUTPUT`");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   delim      = S_STR_ARGV( 0 )[0];
   if (Argv[0]->value.str.slen > 1)
      {
      IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_RET,
                  "All but the first character of 'delim' are ignored");
      }

   n       = S_INT_ARGV( 1 );
   input   = S_STR_ARGV( 2 );

   /*
   Allow a null input string as a no-op.
   */
   if ( (int) strlen(input) > 0 )
      {

      /*
      Allocate the needed memory for the output string. Assign the length
      as 1 plus the string length of the input string. We need the '+1'
      for the C string null terminator.
      */
      output  = (SpiceChar*)alloc_SpiceString( (int) strlen(input) + 1 );

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      cmprss_c( delim, n, input, (SpiceInt) strlen(input) + (SpiceInt)1,
                output);

      if ( failed_c())
         {
         free_SpiceMemory( output );

         zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
         icy_fail(SCALAR);
         }

      /*
      Note, this is a copy operation.
      */
      S_STR_RET_ARGV( 3, output);

      /* Done, so free the allocated memory. */
      free_SpiceMemory( output );
      }
   else
      {

      /*
      Return nothing for a empty input string.
      */
      output = NULL;

      /*
      Note, this is a copy operation.
      */
      S_STR_RET_ARGV( 3, output);
      }

   /* Clean up temporary variables */
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              cnmfrm_c ( ConstSpiceChar    * cname,
                                SpiceInt            lenout,
                                SpiceInt          * frcode,
                                SpiceChar         * frname,
                                SpiceBoolean      * found   )
*/
PROCEDURE CSPICE_CNMFRM(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * cname;
   SpiceInt             frcode;
   SpiceChar            frname_buf[RET_ARRAY_LEN+1];
   SpiceBoolean         found;

   struct argcheck argcheck[] =
      {
      { OREAD, "cname",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "frcode", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "frname", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_CNMFRM, `cname`, FRCODE, `FRNAME`, FOUND");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   cname      = S_STR_ARGV( 0 );

   cnmfrm_c( cname,
             RET_ARRAY_LEN,
             &frcode,
             frname_buf,
             &found);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.l = frcode;

   /*
   Note, this is a copy operation.
   */
   if ( found )
      {
      S_STR_RET_ARGV( 2, frname_buf);
      }
   else
      {
      S_STR_RET_ARGV( 2, "\0" );
      }


   Argv[3]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              conics_c ( ConstSpiceDouble    elts[8],
                                SpiceDouble         et,
                                SpiceDouble         state[6] )
*/
PROCEDURE CSPICE_CONICS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * elts;
   SpiceDouble          et;
   SpiceDouble        * state;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "elts",  (void*)IDL_TYP_DOUBLE,  1, { 8 },    1},
      { OREAD, "et",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "state", (void*)IDL_TYP_DOUBLE,  1, { 6 },    1},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_CONICS, _elts[8]_, _et_, _STATE[6]_");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   state = A_DBL_ARGV( 2 );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
   */
   if (extra->ndims == 0)
      {
      elts = A_DBL_ARGV( 0 );
      et   = S_DBL_ARGV( 1 );

      conics_c(elts,et,state);

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      }
   else
      {
      /* Vector input. */

      elts  =  (SpiceDouble*)(Argv[0]->value.arr->data) ;

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         et = ((SpiceDouble*)(Argv[1]->value.arr->data))[i];

         conics_c( (elts + i*8), et, (state +i*6));

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              convrt_c ( SpiceDouble         x,
                                ConstSpiceChar    * in,
                                ConstSpiceChar    * out,
                                SpiceDouble       * y    )
*/
PROCEDURE CSPICE_CONVRT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble           x;
   SpiceChar           * in;
   SpiceChar           * out;
   SpiceDouble           y;

   struct argcheck argcheck[] =
      {
      { OREAD, "x",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "in",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "out", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "y",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_CONVRT, x, `in`, `out`, Y");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   x   = S_DBL_ARGV( 0 );
   in  = S_STR_ARGV( 1 );
   out = S_STR_ARGV( 2 );

   convrt_c( x, in, out, &y);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[3]->value.d = y;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              cyllat_c ( SpiceDouble         r,
                                SpiceDouble         lonc,
                                SpiceDouble         z,
                                SpiceDouble       * radius,
                                SpiceDouble       * lon,
                                SpiceDouble       * lat )
*/
PROCEDURE CSPICE_CYLLAT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble           r;
   SpiceDouble           lonc;
   SpiceDouble           z;
   SpiceDouble           radius;
   SpiceDouble           lon;
   SpiceDouble           lat;

   struct argcheck argcheck[] =
      {
      { OREAD, "r",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "lonc",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "z",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "radius", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "lon",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "lat",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_CYLLAT, r, lonc, z, RADIUS, LON, LAT");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   r      = S_DBL_ARGV( 0 );
   lonc   = S_DBL_ARGV( 1 );
   z      = S_DBL_ARGV( 2 );

   cyllat_c( r, lonc, z,  &radius, &lon, &lat);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[3]->value.d = radius;
   Argv[4]->value.d = lon;
   Argv[5]->value.d = lat;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              cylrec_c ( SpiceDouble         r,
                                SpiceDouble         lonc,
                                SpiceDouble         z,
                                SpiceDouble         rectan[3] )
*/
PROCEDURE CSPICE_CYLREC(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceDouble            r;
   SpiceDouble            lon;
   SpiceDouble            z;
   SpiceDouble          * rectan;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "r",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "lon",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "z",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "rectan", (void*)IDL_TYP_DOUBLE,  1, { 3 },    1},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_CYLREC, _r_, _lonc_, _z_, _RECTAN[3]_");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   rectan = A_DBL_ARGV( 3 );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
   */
   if (extra->ndims == 0)
      {
      /* Scalar input. */
      r      = S_DBL_ARGV( 0 );
      lon    = S_DBL_ARGV( 1 );
      z      = S_DBL_ARGV( 2 );

      cylrec_c(r,lon,z,rectan);

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );
      }
   else
      {
      /* Vector input. */

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         r   = ((SpiceDouble*)(Argv[0]->value.arr->data))[i];
         lon = ((SpiceDouble*)(Argv[1]->value.arr->data))[i];
         z   = ((SpiceDouble*)(Argv[2]->value.arr->data))[i];

         cylrec_c( r, lon, z, (rectan+i*3) );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              cylsph_c ( SpiceDouble         r,
                                SpiceDouble         lonc,
                                SpiceDouble         z,
                                SpiceDouble       * radius,
                                SpiceDouble       * colat,
                                SpiceDouble       * lon )
*/
PROCEDURE CSPICE_CYLSPH(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble           r;
   SpiceDouble           lonc;
   SpiceDouble           z;
   SpiceDouble           radius;
   SpiceDouble           colat;
   SpiceDouble           lon;

   struct argcheck argcheck[] =
      {
      { OREAD, "r",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "lonc",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "z",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "radius", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "colat",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "lon",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_CYLSPH, r, lonc, z, RADIUS, COLAT, LON");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   r      = S_DBL_ARGV( 0 );
   lonc   = S_DBL_ARGV( 1 );
   z      = S_DBL_ARGV( 2 );

   cylsph_c( r, lonc, z, &radius, &colat, &lon);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[3]->value.d = radius;
   Argv[4]->value.d = colat;
   Argv[5]->value.d = lon;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dafac_c  ( SpiceInt            handle,
                                SpiceInt            n,
                                SpiceInt            lenvals,
                                const void        * buffer  );
*/
PROCEDURE CSPICE_DAFAC(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt              buf_len;
   SpiceInt              buf_size;
   SpiceChar          ** buffer;
   SpiceInt              i;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "length", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "buffer", (void*)IDL_TYP_STRING,  1, { 0 },    0},
      };


    /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_DAFAC, handle, length, buffer[]");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Retrieve input array dimensions (to pass on to C) */
   handle   = S_INT_ARGV(0);
   buf_len  = S_INT_ARGV(1) + 1;
   buf_size = A_LEN_ARGV(2);

   buffer = alloc_SpiceString_C_array ( buf_len, buf_size );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /* Initialize local variables, to pass to CSPICE */
   for (i=0; i < buf_size; i++)
      {
      strncpy( *buffer + i*buf_len,
               IDL_STRING_STR( &((IDL_STRING*)(Argv[2]->value.arr->data))[i]),
               buf_len);
      }

   dafac_c  ( handle, buf_size, buf_len, *buffer );
   CHECK_CALL_FAILURE_MEM( 1, buffer );

   /* Free the memory allocated to buffer. */
   free_SpiceString_C_array ( 1, buffer );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dafbbs_c ( SpiceInt            handle )
*/
PROCEDURE CSPICE_DAFBBS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_DAFBBS, handle");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle = S_INT_ARGV( 0 );

   dafbbs_c(handle);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dafbfs_c ( SpiceInt            handle )
*/
PROCEDURE CSPICE_DAFBFS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_DAFBFS, handle");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle = S_INT_ARGV( 0 );

   dafbfs_c(handle);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dafcls_c ( SpiceInt            handle )
*/
PROCEDURE CSPICE_DAFCLS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_DAFCLS, handle");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle = S_INT_ARGV( 0 );

   dafcls_c(handle);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dafcs_c  ( SpiceInt            handle )
*/
PROCEDURE CSPICE_DAFCS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_DAFCS, handle");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle = S_INT_ARGV( 0 );

   dafcs_c(handle);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dafdc_c ( SpiceInt handle )
*/
PROCEDURE CSPICE_DAFDC(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_DAFDC, handle");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle = S_INT_ARGV( 0 );

   dafdc_c(handle);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dafec_c  ( SpiceInt            handle,
                                SpiceInt            bufsiz,
                                SpiceInt            lenout,
                                SpiceInt          * n,
                                void              * buffer,
                                SpiceBoolean      * done    );
*/
PROCEDURE CSPICE_DAFEC(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt              bufsiz;
   SpiceInt              lenout;
   SpiceInt              n;
   SpiceChar          ** buffer;
   SpiceBoolean          done;
   char               ** str_array;

   IDL_STRING          * idl_ret_str;
   IDL_MEMINT            lDimensions[IDL_MAX_ARRAY_DIM];
   SpiceInt              i;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,   0, { 0 },    0},
      { OREAD, "bufsiz", (void*)IDL_TYP_LONG,   0, { 0 },    0},
      { OREAD, "lenout", (void*)IDL_TYP_LONG,   0, { 0 },    0},
      { OWRIT, "n",      (void*)IDL_TYP_LONG,   0, { 0 },    0},
      { OWRIT, "buffer", (void*)IDL_TYP_STRING, 1, { 0 },    0},
      { OWRIT, "done",   (void*)IDL_TYP_BYTE,   0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_DAFEC, handle, bufsiz, lenout, N, BUFFER, DONE");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle  = S_INT_ARGV( 0 );
   bufsiz  = S_INT_ARGV( 1 );
   lenout  = S_INT_ARGV( 2 ) + 1;

   buffer = alloc_SpiceString_C_array ( lenout, bufsiz );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   dafec_c( handle, bufsiz, lenout, &n, *buffer, &done );

   /* Check for SPICE call failure, clean up if failed. */
   CHECK_CALL_FAILURE_MEM( 1, buffer );

   /* If the call found data... */
   if ( n > 0 )
      {

      /* Create a string array for passing to the IDL created array. */
      str_array = alloc_SpiceString_C_Copy_array ( n,
                                                   lenout,
                                                   buffer );
      CHECK_CALL_FAILURE_MEM( 1, buffer );

      /*
      Create the IDL array for the right size and cast
      it to an IDL_STRING pointer.
      */
      lDimensions[0] = n;
      idl_ret_str    = (IDL_STRING *)IDL_MakeTempArray((int) IDL_TYP_STRING,
                       1,
                       lDimensions,
                       IDL_ARR_INI_NOP,
                       &Argv[4]);

      /*
      Store the string in the IDL string with the string length for
      each element.
      */
      for ( i=0; i< n; i++ )
         {
         IDL_StrStore( &(idl_ret_str[i]), (char*)str_array[i] );
         idl_ret_str[i].slen = strlen(str_array[i]);
         }


      /* Free the memory allocated to str_array. */
      free_SpiceString_C_array ( (int) n, str_array );
      }

   Argv[3]->value.l = n;
   Argv[5]->value.c = done;

   /* Free the memory allocated to buffer. */
   free_SpiceString_C_array ( 1, buffer );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              daffna_c ( SpiceBoolean      * found )
*/
PROCEDURE CSPICE_DAFFNA(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceBoolean          found;

   struct argcheck argcheck[] =
      {
      { OWRIT, "found", (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_DAFFNA, FOUND");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   daffna_c( &found);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[0]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              daffpa_c ( SpiceBoolean      * found )
*/
PROCEDURE CSPICE_DAFFPA(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceBoolean          found;

   struct argcheck argcheck[] =
      {
      { OWRIT, "found", (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_DAFFPA, FOUND");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   daffpa_c(&found);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[0]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dafgda_c ( SpiceInt            handle,
                                SpiceInt            begin,
                                SpiceInt            end,
                                SpiceDouble       * data );

*/
PROCEDURE CSPICE_DAFGDA(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt              begin;
   SpiceInt              end;
   SpiceDouble         * data;
   SpiceInt              size;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "begin",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "end",    (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "values", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_DAFGDA, handle, begin, end, DATA[]");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle = S_INT_ARGV( 0 );
   begin  = S_INT_ARGV( 1 );
   end    = S_INT_ARGV( 2 );
   size   = end - begin + 1;

   /*
   Allocate the necessary memory for 'values'. Check for an error signal.

   Need an error check on end - begin + 1 value
   */
   data = alloc_SpiceDouble_C_array ( 1, (int)size );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   dafgda_c(  handle, begin, end, data);

   /* Check for SPICE call failure, clean up if failed. */
   if ( failed_c())
      {
      free_SpiceMemory( data );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

      {
      char      *data_copy;
      int        tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = size;
      data_copy = IDL_MakeTempArray( IDL_TYP_DOUBLE,
                                       tmp_ndims,
                                       tmp_dims,
                                       IDL_ARR_INI_NOP,
                                       &Argv[3]);

      MOVED( data, size, data_copy );
      }


   free_SpiceMemory( data );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dafgn_c  ( SpiceInt            lenout,
                                SpiceChar         * name   )
*/
PROCEDURE CSPICE_DAFGN(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar             name_buf[RET_ARRAY_LEN+1];

   struct argcheck argcheck[] =
      {
      { OWRIT, "name", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_DAFGN, `NAME`");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   dafgn_c( RET_ARRAY_LEN, name_buf);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV( 0, name_buf);

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dafgs_c  ( SpiceDouble         sum[] )
*/
PROCEDURE CSPICE_DAFGS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          sum [MAXSUM];
   SpiceInt             nd;
   SpiceInt             ni;
   SpiceDouble        * dc;
   SpiceInt           * ic;

   struct argcheck argcheck[] =
      {
      { OREAD, "nd",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "ni",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "dc",  (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OWRIT, "ic",  (void*)IDL_TYP_LONG,    1, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_DAFGS, nd, ni, DC[], IC[]");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   nd = S_INT_ARGV( 0 );
   ni = S_INT_ARGV( 1 );

   /*
   Allocate the necessary memory for ic and dc. Check for an error signal.
   */
   dc = alloc_SpiceDouble_C_array ( 1, (int) nd );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   ic = alloc_SpiceInt_C_array ( 1, (int) ni );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   dafgs_c( sum );
   dafus_c( sum, nd, ni, dc, ic );

   /* Check for SPICE call failure, clean up if failed. */
   if ( failed_c())
      {
      free_SpiceMemory( ic );
      free_SpiceMemory( dc );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail( SCALAR );
      }

   if ( ni != 0 )
      {
      char    *ivals_copy;
      int      tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = ni;
      ivals_copy  = IDL_MakeTempArray(IDL_TYP_LONG,    tmp_ndims, tmp_dims,
                                      IDL_ARR_INI_NOP, &Argv[3]);
      memmove(ivals_copy, ic, ni * sizeof(SpiceInt ) );
      }

   if ( nd != 0)
      {
      char    *values_copy;
      int      tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = nd;
      values_copy = IDL_MakeTempArray(IDL_TYP_DOUBLE, tmp_ndims,
                                      tmp_dims, IDL_ARR_INI_NOP, &Argv[2]);
      memmove(values_copy, dc, nd * sizeof(SpiceDouble) );
      }


   /* Clean up temporary variables */
   free_SpiceMemory( ic );
   free_SpiceMemory( dc );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dafopr_c ( ConstSpiceChar    * fname,
                                SpiceInt          * handle  )
*/
PROCEDURE CSPICE_DAFOPR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * fname;
   SpiceInt              handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "fname",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_DAFOPR, `fname`, HANDLE");
      }


   extra  = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   fname  = S_STR_ARGV( 0 );

   dafopr_c( fname, &handle);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.l = handle;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
 void              dafopw_c ( ConstSpiceChar    * fname,
                              SpiceInt          * handle  )

 */
PROCEDURE CSPICE_DAFOPW(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * fname;
   SpiceInt              handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "fname",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_DAFOPW, `fname`, HANDLE");
      }


   extra  = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   fname = S_STR_ARGV( 0 );

   dafopw_c( fname, &handle);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.l = handle;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dafrs_c ( ConstSpiceDouble  * sum )
*/
PROCEDURE CSPICE_DAFRS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          sum[125];
   SpiceInt             nd;
   SpiceInt             ni;
   SpiceDouble        * dc;
   SpiceInt           * ic;

   struct argcheck argcheck[] =
      {
      { OREAD, "nd",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "ni",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "dc",  (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OREAD, "ic",  (void*)IDL_TYP_LONG,    1, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_DAFRS, nd, ni, dc[], ic[]");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   nd = S_INT_ARGV( 0 );
   ni = S_INT_ARGV( 1 );
   dc = A_DBL_ARGV( 2 );
   ic = A_INT_ARGV( 3 );

   dafps_c( nd, ni, dc, ic, sum );
   dafrs_c( sum );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dafus_c  ( ConstSpiceDouble    sum [],
                                SpiceInt            nd,
                                SpiceInt            ni,
                                SpiceDouble         dc  [],
                                SpiceInt            ic  []  )
*/
PROCEDURE CSPICE_DAFUS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   ConstSpiceDouble  * sum;
   SpiceInt             nd;
   SpiceInt             ni;
   SpiceDouble        * dc;
   SpiceInt           * ic;

   SpiceInt             sum_size;

   struct argcheck argcheck[] =
      {
      { OREAD, "sum", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OREAD, "nd",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "ni",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "dc",  (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OWRIT, "ic",  (void*)IDL_TYP_LONG,    1, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 5)
      {
      USAGE("CSPICE_DAFUS, sum, nd, ni, DC[], IC[]");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */

   sum = (ConstSpiceDouble*)Argv[0]->value.arr->data;

   /* Retrieve input array dimensions */
   sum_size = A_LEN_ARGV(0);

   /* Check dimensions of input arrays */
   if ( sum_size > MAXSUM )
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(0, "sum", IDL_VarName(Argv_orig[0]),
                      "Size of summary array `sum` exceeds MAXSUM.");
      }

   nd  = S_INT_ARGV( 1 );
   ni  = S_INT_ARGV( 2 );

   /*
   Allocate the necessary memory for ic and dc. Check for an error signal.
   */
   dc = alloc_SpiceDouble_C_array ( 1, (int) nd );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   ic = alloc_SpiceInt_C_array ( 1, (int) ni );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   dafus_c( sum, nd, ni, dc, ic );

   /* Check for SPICE call failure, clean up if failed. */
   if ( failed_c())
      {
      free_SpiceMemory( ic );
      free_SpiceMemory( dc );
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail( SCALAR );
      }


   if ( nd != 0)
      {
      char    *values_copy;
      int      tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = nd;
      values_copy = IDL_MakeTempArray(IDL_TYP_DOUBLE, tmp_ndims,
                                      tmp_dims, IDL_ARR_INI_NOP, &Argv[3]);
      memmove(values_copy, dc, nd * sizeof(SpiceDouble) );
      }


   if ( ni != 0 )
      {
      char    *ivals_copy;
      int      tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = ni;
      ivals_copy  = IDL_MakeTempArray(IDL_TYP_LONG,    tmp_ndims, tmp_dims,
                                      IDL_ARR_INI_NOP, &Argv[4]);
      memmove(ivals_copy, ic, ni * sizeof(SpiceInt ) );
      }


   /* Clean up temporary variables */
   free_SpiceMemory( ic );
   free_SpiceMemory( dc );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dascls_c ( SpiceInt            handle )
*/
PROCEDURE CSPICE_DASCLS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_DASCLS, handle");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle = S_INT_ARGV( 0 );

   dascls_c(handle);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dasec_c  ( SpiceInt            handle,
                                SpiceInt            bufsiz,
                                SpiceInt            lenout,
                                SpiceInt          * n,
                                void              * buffer,
                                SpiceBoolean      * done    );
*/
PROCEDURE CSPICE_DASEC(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt              bufsiz;
   SpiceInt              lenout;
   SpiceInt              n;
   SpiceChar          ** buffer;
   SpiceBoolean          done;
   char               ** str_array;

   IDL_STRING          * idl_ret_str;
   IDL_MEMINT            lDimensions[IDL_MAX_ARRAY_DIM];
   SpiceInt              i;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,   0, { 0 },    0},
      { OREAD, "bufsiz", (void*)IDL_TYP_LONG,   0, { 0 },    0},
      { OREAD, "lenout", (void*)IDL_TYP_LONG,   0, { 0 },    0},
      { OWRIT, "n",      (void*)IDL_TYP_LONG,   0, { 0 },    0},
      { OWRIT, "buffer", (void*)IDL_TYP_STRING, 1, { 0 },    0},
      { OWRIT, "done",   (void*)IDL_TYP_BYTE,   0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_DASEC, handle, bufsiz, lenout, N, BUFFER, DONE");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle  = S_INT_ARGV( 0 );
   bufsiz  = S_INT_ARGV( 1 );
   lenout  = S_INT_ARGV( 2 ) + 1;

   buffer = alloc_SpiceString_C_array ( lenout, bufsiz );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   dasec_c( handle, bufsiz, lenout, &n, *buffer, &done );

   /* Check for SPICE call failure, clean up if failed. */
   CHECK_CALL_FAILURE_MEM( 1, buffer );

   /* If the call found data... */
   if ( n > 0 )
      {

      /* Create a string array for passing to the IDL created array. */
      str_array = alloc_SpiceString_C_Copy_array ( n,
                                                   lenout,
                                                   buffer );
      CHECK_CALL_FAILURE_MEM( 1, buffer );

      /*
      Create the IDL array for the right size and cast
      it to an IDL_STRING pointer.
      */
      lDimensions[0] = n;
      idl_ret_str    = (IDL_STRING *)IDL_MakeTempArray((int) IDL_TYP_STRING,
                       1,
                       lDimensions,
                       IDL_ARR_INI_NOP,
                       &Argv[4]);

      /*
      Store the string in the IDL string with the string length for
      each element.
      */
      for ( i=0; i< n; i++ )
         {
         IDL_StrStore( &(idl_ret_str[i]), (char*)str_array[i] );
         idl_ret_str[i].slen = strlen(str_array[i]);
         }


      /* Free the memory allocated to str_array. */
      free_SpiceString_C_array ( (int) n, str_array );
      }

   Argv[3]->value.l = n;
   Argv[5]->value.c = done;

   /* Free the memory allocated to buffer. */
   free_SpiceString_C_array ( 1, buffer );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dasopr_c ( ConstSpiceChar    * fname,
                                SpiceInt          * handle  )
*/
PROCEDURE CSPICE_DASOPR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * fname;
   SpiceInt              handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "fname",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_DASOPR, `fname`, HANDLE");
      }


   extra  = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   fname  = S_STR_ARGV( 0 );

   dasopr_c( fname, &handle);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.l = handle;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }





/*
   void              dcyldr_c ( SpiceDouble         x,
                                SpiceDouble         y,
                                SpiceDouble         z,
                                SpiceDouble         jacobi[3][3] )
*/
PROCEDURE CSPICE_DCYLDR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          x;
   SpiceDouble          y;
   SpiceDouble          z;
   SpiceDouble        * jacobi;

   struct argcheck argcheck[] =
      {
      { OREAD, "x",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "y",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "z",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "jacobi", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_DCYLDR, x, y, z, JACOBI[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   x   = S_DBL_ARGV( 0 );
   y   = S_DBL_ARGV( 1 );
   z   = S_DBL_ARGV( 2 );
   jacobi = A_DBL_ARGV( 3 );

   dcyldr_c(x, y, z, (SpiceDouble (*)[3])jacobi);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*

   void deltet_c ( SpiceDouble      epoch,
                   ConstSpiceChar * eptype,
                   SpiceDouble    * delta )

*/
PROCEDURE CSPICE_DELTET(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          epoch;
   SpiceChar          * eptype;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "epoch",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "eptype", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "delta",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_DELTET, _epoch_, `eptype`, _DELTA_");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra  = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   eptype  = S_STR_ARGV( 1 );


   /* Called with vectorized' input arguments? */
   if (extra->ndims == 0)
      {
      /* Scalar input. */
      SpiceDouble          delta;

      epoch   = S_DBL_ARGV( 0 );

      deltet_c( epoch, eptype, &delta );

      /*
      Test for a SPICE error signal. If found, display an error message
      to the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      Argv[2]->value.d = delta;

      }
   else
      {
      /* Vector input. */

      SpiceDouble        * delta;
      delta = A_DBL_ARGV(2);

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         epoch = ((SpiceDouble*)(Argv[0]->value.arr->data))[i];

         deltet_c( epoch, eptype, (delta+i) );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);

         }

      }
   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceDouble det_c ( ConstSpiceDouble    m1[3][3] )
*/
FUNCTION CSPICE_DET(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceDouble          retval_c;
   SpiceDouble        * m1;

   struct argcheck argcheck[] =
      {
      { OREAD, "m1", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 },  0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("double  = CSPICE_DET( m1[3,3] )");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   m1 = A_DBL_ARGV( 0 );

   retval_c = det_c((Nx3d)m1);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              dgeodr_c ( SpiceDouble         x,
                                SpiceDouble         y,
                                SpiceDouble         z,
                                SpiceDouble         re,
                                SpiceDouble         f,
                                SpiceDouble         jacobi[3][3] )
*/
PROCEDURE CSPICE_DGEODR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          x;
   SpiceDouble          y;
   SpiceDouble          z;
   SpiceDouble          re;
   SpiceDouble          f;
   SpiceDouble        * jacobi;

   struct argcheck argcheck[] =
      {
      { OREAD, "x",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "y",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "z",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "re",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "f",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "jacobi", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6 )
      {
      USAGE("CSPICE_DGEODR, x, y, z, re, f, JACOBI[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   x      = S_DBL_ARGV( 0 );
   y      = S_DBL_ARGV( 1 );
   z      = S_DBL_ARGV( 2 );
   re     = S_DBL_ARGV( 3 );
   f      = S_DBL_ARGV( 4 );
   jacobi = A_DBL_ARGV( 5 );

   dgeodr_c(x, y, z, re, f, (SpiceDouble (*)[3])jacobi);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              diags2_c ( ConstSpiceDouble    symmat [2][2],
                                SpiceDouble         diag   [2][2],
                                SpiceDouble         rotate [2][2]  )
*/
PROCEDURE CSPICE_DIAGS2(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * symmat;
   SpiceDouble        * diag;
   SpiceDouble        * rotate;

   struct argcheck argcheck[] =
      {
      { OREAD, "symmat", (void*)IDL_TYP_DOUBLE,  2, { 2, 2 }, 0},
      { OWRIT, "diag",   (void*)IDL_TYP_DOUBLE,  2, { 2, 2 }, 0},
      { OWRIT, "rotate", (void*)IDL_TYP_DOUBLE,  2, { 2, 2 }, 0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_DIAGS2, symmat[2,2], DIAG[2,2], ROTATE[2,2]");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   symmat = A_DBL_ARGV( 0 );
   diag   = A_DBL_ARGV( 1 );
   rotate = A_DBL_ARGV( 2 );

   diags2_c((ConstSpiceDouble (*)[2])symmat,
            (SpiceDouble (*)[2])diag,
            (SpiceDouble (*)[2])rotate);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*

 void               diff_c ( SpiceCell          * a,
                             SpiceCell          * b,
                             SpiceCell          * c );


 */
PROCEDURE CSPICE_DIFF(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset1;
   SpiceInt             * tag_offset2;
   SpiceInt             * tag_offset3;
   SpiceCell              a;
   SpiceCell              b;
   SpiceCell              c;

   struct argcheck argcheck[] =
      {
      { OREAD, "a", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0},
      { OREAD, "b", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0},
      { RDWRT, "c", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_DIFF, a, b, (C)");
      }


   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[0].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[1].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[2].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );


   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset1 = (SpiceInt*) (Argv[0]->value.s.arr->data);
   tag_offset2 = (SpiceInt*) (Argv[1]->value.s.arr->data);
   tag_offset3 = (SpiceInt*) (Argv[2]->value.s.arr->data);

   pack_cell( &a, 0, tag_offset1, Argv );
   pack_cell( &b, 1, tag_offset2, Argv );
   pack_cell( &c, 2, tag_offset3, Argv );

   diff_c ( &a, &b, &c );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM4( a, b, c, SCALAR );

   /*
   Unpack the cells, return the data from 'c' to 'Argv'.
   */
   unpack_cell( 0, tag_offset1, &a, Argv );
   unpack_cell( 1, tag_offset2, &b, Argv );
   unpack_cell( 2, tag_offset3, &c, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void dlabfs_c ( SpiceInt            handle,
                   SpiceInt          * dladsc,
                   SpiceBoolean      * found    )
*/
PROCEDURE CSPICE_DLABFS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt            * dladsc;
   SpiceBoolean          found;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG, 0, { 0 },              0},
      { OWRIT, "dladsc", (void*)IDL_TYP_LONG, 1, {SPICE_DLA_DSCSIZ}, 0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE, 0, { 0 },              0},
      };

   /*
   Other local variables
   */
   SpiceDLADescr         descr;


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE( "CSPICE_DLABFS, handle, DLADSC[SPICE_DLA_DSCSIZ], FOUND" );
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   dladsc     = A_INT_ARGV( 1 );


   dlabfs_c ( handle, &descr, &found );


   /*
   Test for a SPICE error signal, if found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /*
   Copy the contents of the DLA descriptor structure to the
   output integer array.
   */
   dladsc[0]  =  descr.bwdptr;
   dladsc[1]  =  descr.fwdptr;
   dladsc[2]  =  descr.ibase;
   dladsc[3]  =  descr.isize;
   dladsc[4]  =  descr.dbase;
   dladsc[5]  =  descr.dsize;
   dladsc[6]  =  descr.cbase;
   dladsc[7]  =  descr.csize;

   Argv[2]->value.c = found;


   /*
   Clean up temporary variables
   */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void dlafns_c ( SpiceInt                 handle,
                   ConstSpiceDLADescr     * dladsc,
                   SpiceDLADescr          * nxtdsc,
                   SpiceBoolean           * found    )
*/
PROCEDURE CSPICE_DLAFNS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt            * dladsc;
   SpiceInt            * nxtdsc;
   SpiceDLADescr         descr;
   SpiceDLADescr         nxtdescr;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG, 0, { 0    },           0},
      { OREAD, "dladsc", (void*)IDL_TYP_LONG, 1, {SPICE_DLA_DSCSIZ}, 0},
      { OWRIT, "nxtdsc", (void*)IDL_TYP_LONG, 1, { 8    },           0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE, 0, { 0    },           0},
      };

   /*
   Other local variables
   */
   SpiceBoolean          found;



   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE( "CSPICE_DLAFNS, handle, dladsc[SPICE_DLA_DSCSIZ], "
             "NXTDSC, FOUND" );
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV      ( 0 );
   dladsc     = A_INT_ARGV      ( 1 );
   nxtdsc     = A_INT_ARGV      ( 2 );



   /*
   Copy the contents of the input integer array to the
   input DLA descriptor structure.
   */
   descr.bwdptr = dladsc[0];
   descr.fwdptr = dladsc[1];
   descr.ibase  = dladsc[2];
   descr.isize  = dladsc[3];
   descr.dbase  = dladsc[4];
   descr.dsize  = dladsc[5];
   descr.cbase  = dladsc[6];
   descr.csize  = dladsc[7];


   dlafns_c ( handle, &descr, &nxtdescr, &found );


   /* Check for SPICE call failure, clean up if failed. */
   CHECK_CALL_FAILURE( SCALAR );

   /*
   Copy the contents of the output DLA descriptor structure to the
   output integer array.
   */
   nxtdsc[0]  =  nxtdescr.bwdptr;
   nxtdsc[1]  =  nxtdescr.fwdptr;
   nxtdsc[2]  =  nxtdescr.ibase;
   nxtdsc[3]  =  nxtdescr.isize;
   nxtdsc[4]  =  nxtdescr.dbase;
   nxtdsc[5]  =  nxtdescr.dsize;
   nxtdsc[6]  =  nxtdescr.cbase;
   nxtdsc[7]  =  nxtdescr.csize;


   Argv[3]->value.c = found;


   /*
   Clean up temporary variables
   */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dlatdr_c ( SpiceDouble         x,
                                SpiceDouble         y,
                                SpiceDouble         z,
                                SpiceDouble         jacobi[3][3] )
*/
PROCEDURE CSPICE_DLATDR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          x;
   SpiceDouble          y;
   SpiceDouble          z;
   SpiceDouble        * jacobi;

   struct argcheck argcheck[] =
      {
      { OREAD, "x",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "y",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "z",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "jacobi", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_DLATDR, x, y, z, JACOBI[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   x   = S_DBL_ARGV( 0 );
   y   = S_DBL_ARGV( 1 );
   z   = S_DBL_ARGV( 2 );
   jacobi = A_DBL_ARGV( 3 );

   dlatdr_c(x, y, z, (SpiceDouble (*)[3])jacobi);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dp2hx_c ( SpiceDouble   number,
                               SpiceInt      lenout,
                               SpiceChar   * string,
                               SpiceInt    * length
                             )
*/
PROCEDURE CSPICE_DP2HX(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   /*
   This value must match the corresponding parameter defined in dp2hx.f.
   Edit one, edit both.
   */
   #define               STRLEN       255

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble           number;
   char                  string_buf[STRLEN];
   SpiceInt              length;

   struct argcheck argcheck[] =
      {
      { OREAD, "number", (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OWRIT, "string", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_DP2HX, number, `STRING`");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */

   number = S_DBL_ARGV( 0 );

   dp2hx_c ( number, STRLEN, string_buf, &length );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV( 1, string_buf);

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dpgrdr_c ( ConstSpiceChar    * body,
                                SpiceDouble         x,
                                SpiceDouble         y,
                                SpiceDouble         z,
                                SpiceDouble         re,
                                SpiceDouble         f,
                                SpiceDouble         jacobi[3][3] )
*/
PROCEDURE CSPICE_DPGRDR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * body;
   SpiceDouble          x;
   SpiceDouble          y;
   SpiceDouble          z;
   SpiceDouble          re;
   SpiceDouble          f;
   SpiceDouble        * jacobi;

   struct argcheck argcheck[] =
      {
      { OREAD, "body",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "x",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "y",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "z",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "re",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "f",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "jacobi", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_DPGRDR, body, x, y, z, re, f, JACOBI[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   body   = S_STR_ARGV( 0 );
   x      = S_DBL_ARGV( 1 );
   y      = S_DBL_ARGV( 2 );
   z      = S_DBL_ARGV( 3 );
   re     = S_DBL_ARGV( 4 );
   f      = S_DBL_ARGV( 5 );
   jacobi = A_DBL_ARGV( 6 );

   dpgrdr_c(body, x, y, z, re, f, (SpiceDouble (*)[3])jacobi);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceDouble       dpmax_c  ( void )
*/
FUNCTION CSPICE_DPMAX(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR retval_idl;
   SpiceDouble retval_c;

   /* Check the input contains the correct number of arguments. */
   if (Argc != 0)
      {
      USAGE("double  = CSPICE_DPMAX()");
      }

   retval_c = dpmax_c();

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   return retval_idl;
   }




/*
   SpiceDouble       dpmin_c  ( void )
*/
FUNCTION CSPICE_DPMIN(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR     retval_idl;
   SpiceDouble  retval_c;

   /* Check the input contains the correct number of arguments. */
   if (Argc != 0)
      {
      USAGE("double  = CSPICE_DPMIN()");
      }

   retval_c = dpmin_c();

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   return retval_idl;
   }




/*
   SpiceDouble       dpr_c    ( void )
*/
FUNCTION CSPICE_DPR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR     retval_idl;
   SpiceDouble  retval_c;

   /* Check the input contains the correct number of arguments. */
   if (Argc != 0)
      {
      USAGE("double  = CSPICE_DPR()");
      }

   retval_c = dpr_c();

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   return retval_idl;
   }




/*
   void              drdcyl_c ( SpiceDouble    r,
                                SpiceDouble    lon,
                                SpiceDouble    z,
                                SpiceDouble    jacobi[3][3] )
*/
PROCEDURE CSPICE_DRDCYL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          r;
   SpiceDouble          lon;
   SpiceDouble          z;
   SpiceDouble        * jacobi;

   struct argcheck argcheck[] =
      {
      { OREAD, "r",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "lon",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "z",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "jacobi", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_DRDCYL, r, lon, z, JACOBI[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   r      = S_DBL_ARGV( 0 );
   lon    = S_DBL_ARGV( 1 );
   z      = S_DBL_ARGV( 2 );
   jacobi = A_DBL_ARGV( 3 );

   drdcyl_c(r, lon, z, (SpiceDouble (*)[3])jacobi);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              drdgeo_c ( SpiceDouble         lon,
                                SpiceDouble         lat,
                                SpiceDouble         alt,
                                SpiceDouble         re,
                                SpiceDouble         f,
                                SpiceDouble         jacobi[3][3] )
*/
PROCEDURE CSPICE_DRDGEO(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          lon;
   SpiceDouble          lat;
   SpiceDouble          alt;
   SpiceDouble          re;
   SpiceDouble          f;
   SpiceDouble        * jacobi;

   struct argcheck argcheck[] =
      {
      { OREAD, "lon",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "lat",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "alt",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "re",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "f",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "jacobi", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_DRDGEO, lon, lat, alt, re, f, JACOBI[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   lon    = S_DBL_ARGV( 0 );
   lat    = S_DBL_ARGV( 1 );
   alt    = S_DBL_ARGV( 2 );
   re     = S_DBL_ARGV( 3 );
   f      = S_DBL_ARGV( 4 );
   jacobi = A_DBL_ARGV( 5 );

   drdgeo_c(lon, lat, alt, re, f, (SpiceDouble (*)[3])jacobi);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              drdlat_c ( SpiceDouble    r,
                                SpiceDouble    lon,
                                SpiceDouble    lat,
                                SpiceDouble    jacobi[3][3] )
*/
PROCEDURE CSPICE_DRDLAT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          r;
   SpiceDouble          lon;
   SpiceDouble          lat;
   SpiceDouble        * jacobi;

   struct argcheck argcheck[] =
      {
      { OREAD, "r",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "lon",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "lat",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "jacobi", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_DRDLAT, r, lon, lat, JACOBI[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   r      = S_DBL_ARGV( 0 );
   lon    = S_DBL_ARGV( 1 );
   lat    = S_DBL_ARGV( 2 );
   jacobi = A_DBL_ARGV( 3 );

   drdlat_c(r, lon, lat, (SpiceDouble (*)[3])jacobi);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              drdpgr_c ( ConstSpiceChar    * body,
                                SpiceDouble         lon,
                                SpiceDouble         lat,
                                SpiceDouble         alt,
                                SpiceDouble         re,
                                SpiceDouble         f,
                                SpiceDouble         jacobi[3][3] )
*/
PROCEDURE CSPICE_DRDPGR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * body;
   SpiceDouble          lon;
   SpiceDouble          lat;
   SpiceDouble          alt;
   SpiceDouble          re;
   SpiceDouble          f;
   SpiceDouble        * jacobi;

   struct argcheck argcheck[] =
      {
      { OREAD, "body",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "lon",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "lat",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "alt",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "re",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "f",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "jacobi", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_DRDPGR, body, lon, lat, alt, re, f, JACOBI[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   body   = S_STR_ARGV( 0 );
   lon    = S_DBL_ARGV( 1 );
   lat    = S_DBL_ARGV( 2 );
   alt    = S_DBL_ARGV( 3 );
   re     = S_DBL_ARGV( 4 );
   f      = S_DBL_ARGV( 5 );
   jacobi = A_DBL_ARGV( 6 );

   drdpgr_c( body, lon, lat, alt, re, f, (SpiceDouble (*)[3])jacobi);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              drdsph_c ( SpiceDouble    r,
                                SpiceDouble    colat,
                                SpiceDouble    lon,
                                SpiceDouble    jacobi[3][3] )
*/
PROCEDURE CSPICE_DRDSPH(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          r;
   SpiceDouble          colat;
   SpiceDouble          lon;
   SpiceDouble        * jacobi;

   struct argcheck argcheck[] =
      {
      { OREAD, "r",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "colat",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "lon",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "jacobi", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_DRDSPH, r, colat, lon, JACOBI[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   r      = S_DBL_ARGV( 0 );
   colat  = S_DBL_ARGV( 1 );
   lon    = S_DBL_ARGV( 2 );
   jacobi = A_DBL_ARGV( 3 );

   drdsph_c(r, colat, lon, (SpiceDouble (*)[3])jacobi);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }





/*
   void              dskb02_c ( SpiceInt               handle,
                                ConstSpiceDLADescr   * dladsc,
                                SpiceInt             * nv,
                                SpiceInt             * np,
                                SpiceInt             * nvxtot,
                                SpiceDouble            vtxbds  [3][2],
                                SpiceDouble          * voxsiz,
                                SpiceDouble            voxori  [3],
                                SpiceInt               vgrext  [3],
                                SpiceInt             * cgscal,
                                SpiceInt             * vtxnpl,
                                SpiceInt             * voxnpt,
                                SpiceInt             * voxnpl          )
*/
PROCEDURE CSPICE_DSKB02(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt            * dladsc;
   SpiceInt              nv;
   SpiceInt              np;
   SpiceInt              nvxtot;
   SpiceDouble         * vtxbds;
   SpiceDouble           voxsiz;
   SpiceDouble         * voxori;
   SpiceInt            * vgrext;
   SpiceInt              cgscal;
   SpiceInt              vtxnpl;
   SpiceInt              voxnpt;
   SpiceInt              voxnpl;


   SpiceDLADescr         descr;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,   0, { 0 },              0},
      { OREAD, "dladsc", (void*)IDL_TYP_LONG,   1, {SPICE_DLA_DSCSIZ}, 0},
      { OWRIT, "nv",     (void*)IDL_TYP_LONG,   0, { 0 },              0},
      { OWRIT, "np",     (void*)IDL_TYP_LONG,   0, { 0 },              0},
      { OWRIT, "nvxtot", (void*)IDL_TYP_LONG,   0, { 0 },              0},
      { OWRIT, "vtxbds", (void*)IDL_TYP_DOUBLE, 2, { 2, 3 },           0},
      { OWRIT, "voxsiz", (void*)IDL_TYP_DOUBLE, 0, { 0 },              0},
      { OWRIT, "voxori", (void*)IDL_TYP_DOUBLE, 1, { 3 },              0},
      { OWRIT, "vgrext", (void*)IDL_TYP_LONG,   1, { 3 },              0},
      { OWRIT, "cgscal", (void*)IDL_TYP_LONG,   0, { 0 },              0},
      { OWRIT, "vtxnpl", (void*)IDL_TYP_LONG,   0, { 0 },              0},
      { OWRIT, "voxnpt", (void*)IDL_TYP_LONG,   0, { 0 },              0},
      { OWRIT, "voxnpl", (void*)IDL_TYP_LONG,   0, { 0 },              0}
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 13)
      {
      USAGE( "CSPICE_DSKB02, handle, dladsc[SPICE_DLA_DSCSIZ], "
             "NV, NP, NVXTOT, VTXBDS[], "
             "VOXSIZ, VOXORI[], VGREXT[], CGSCAL, VTXNPL, VOXNPT, VOXNPL" );
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV ( 0 );
   dladsc     = A_INT_ARGV ( 1 );
   vtxbds     = A_DBL_ARGV ( 5 );
   voxsiz     = S_DBL_ARGV ( 6 );
   voxori     = A_DBL_ARGV ( 7 );
   vgrext     = A_INT_ARGV ( 8 );



   /*
   Fill in the members of the local DLA descriptor.
   */
   descr.bwdptr = dladsc[0];
   descr.fwdptr = dladsc[1];
   descr.ibase  = dladsc[2];
   descr.isize  = dladsc[3];
   descr.dbase  = dladsc[4];
   descr.dsize  = dladsc[5];
   descr.cbase  = dladsc[6];
   descr.csize  = dladsc[7];

   dskb02_c(   handle,
               &descr,
               &nv,
               &np,
               &nvxtot,
               ( SpiceDouble (*) [2] ) vtxbds,
               &voxsiz,
               ( SpiceDouble * ) voxori,
               ( SpiceInt    * ) vgrext,
               &cgscal,
               &vtxnpl,
               &voxnpt,
               &voxnpl                         );

   /* Check for SPICE call failure, clean up if failed. */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[2 ]->value.l = nv;
   Argv[3 ]->value.l = np;
   Argv[4 ]->value.l = nvxtot;
   Argv[6 ]->value.d = voxsiz;
   Argv[9 ]->value.l = cgscal;
   Argv[10]->value.l = vtxnpl;
   Argv[11]->value.l = voxnpt;
   Argv[12]->value.l = voxnpl;



   /*
   Clean up temporary variables
   */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dskcls_c ( SpiceInt               handle,
                                SpiceBoolean           optmiz );
*/
PROCEDURE CSPICE_DSKCLS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceBoolean         optmiz;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "found",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_DSKCLS, handle, optimz");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle = S_INT_ARGV( 0 );
   optmiz = S_BOOL_ARGV( 1 );

   dskcls_c ( handle, optmiz );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void dskd02_c ( SpiceInt            handle,
                   ConstSpiceInt     * dladsc,
                   SpiceInt            item,
                   SpiceInt            start,
                   SpiceInt            room,
                   SpiceInt          * n,
                   SpiceDouble       * values  )
*/

PROCEDURE CSPICE_DSKD02(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt            * dladsc;
   SpiceInt              item;
   SpiceInt              start;
   SpiceInt              room;
   SpiceInt              values_dim;
   SpiceDouble         * values;
   SpiceDLADescr         descr;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,   0, { 0 },              0},
      { OREAD, "dladsc", (void*)IDL_TYP_LONG,   1, {SPICE_DLA_DSCSIZ}, 0},
      { OREAD, "item",   (void*)IDL_TYP_LONG,   0, { 0 },              0},
      { OREAD, "start",  (void*)IDL_TYP_LONG,   0, { 0 },              0},
      { OREAD, "room",   (void*)IDL_TYP_LONG,   0, { 0 },              0},
      { OWRIT, "values", (void*)IDL_TYP_DOUBLE, 1, { 0 },              0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_DSKD02, handle, dladsc[SPICE_DLA_DSCSIZ], "
            "item, start, room, VALUES[]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   dladsc     = A_INT_ARGV( 1 );
   item       = S_INT_ARGV( 2 );
   start      = S_INT_ARGV( 3 );
   room       = S_INT_ARGV( 4 );
   values_dim = 0;

   /*
   Allocate the necessary memory for 'values'. Check for an error signal.
   */
   values = alloc_SpiceDouble_C_array ( 1, (int) room );

   /*
   Test for a SPICE error signal, if found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /*
   Fill in the members of the local DLA descriptor.
   */
   descr.bwdptr = dladsc[0];
   descr.fwdptr = dladsc[1];
   descr.ibase  = dladsc[2];
   descr.isize  = dladsc[3];
   descr.dbase  = dladsc[4];
   descr.dsize  = dladsc[5];
   descr.cbase  = dladsc[6];
   descr.csize  = dladsc[7];


   dskd02_c( handle, &descr, item, start, room, &values_dim, values );

   /* Check for SPICE call failure, clean up if failed. */
   if ( failed_c())
      {
      free_SpiceMemory( values );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }


   if ( values_dim != 0)
      {
      char      *values_copy;
      int        tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = values_dim;
      values_copy = IDL_MakeTempArray( IDL_TYP_DOUBLE,
                                       tmp_ndims,
                                       tmp_dims,
                                       IDL_ARR_INI_NOP,
                                       &Argv[5]);

      memmove(values_copy, values, values_dim * sizeof(SpiceDouble) );
      }

   /*
   Clean up temporary variables
   */
   free_SpiceMemory( values );
   ICY_ALLOC_CHECK;

   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void dskgd_ ( integer           * handle,
                 integer           * dladsc,
                 doublereal          dskdsc[]  )
*/
PROCEDURE CSPICE_DSKGD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt            * dladsc;
   SpiceDouble         * dskdsc;


   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,   0, { 0 },              0},
      { OREAD, "dladsc", (void*)IDL_TYP_LONG,   1, {SPICE_DLA_DSCSIZ}, 0},
      { OWRIT, "dskdsc", (void*)IDL_TYP_DOUBLE, 1, {SPICE_DSK_DSCSIZ}, 0},
      };



   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE( "CSPICE_DSKGD, handle, DLADSC[SPICE_DLA_DSCSIZ], "
             "DSKDSC[SPICE_DSK_DSCSIZ]" );
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   dladsc     = A_INT_ARGV( 1 );
   dskdsc     = A_DBL_ARGV( 2 );

   dskgd_ ( &handle, dladsc, dskdsc );

   /*
   Test for a SPICE error signal, if found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /*
   Clean up temporary variables
   */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dskgtl_c ( SpiceInt        keywrd,
                                SpiceDouble   * dpval  )
*/
PROCEDURE CSPICE_DSKGTL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             keywrd;
   SpiceDouble          dpval;

   struct argcheck argcheck[] =
      {
      { OREAD, "keywrd", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "dpval",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_DSKGTL, keywrd, DPVAL");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   keywrd     = S_INT_ARGV( 0 );

   /* Scalar */
   (void) dskgtl_c ( keywrd, &dpval );

   /*
   Test for a SPICE error signal. If found, display an error message
   to the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.d = dpval;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void dski02_c ( SpiceInt            handle,
                   ConstSpiceInt     * dladsc,
                   SpiceInt            item,
                   SpiceInt            start,
                   SpiceInt            room,
                   SpiceInt          * n,
                   SpiceInt          * values  )
*/
PROCEDURE CSPICE_DSKI02(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt            * dladsc;
   SpiceInt              item;
   SpiceInt              start;
   SpiceInt              room;
   SpiceInt              values_dim;
   SpiceInt            * values;
   SpiceDLADescr         descr;


   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG, 0, { 0 },              0},
      { OREAD, "dladsc", (void*)IDL_TYP_LONG, 1, {SPICE_DLA_DSCSIZ}, 0},
      { OREAD, "item",   (void*)IDL_TYP_LONG, 0, { 0 },              0},
      { OREAD, "start",  (void*)IDL_TYP_LONG, 0, { 0 },              0},
      { OREAD, "room",   (void*)IDL_TYP_LONG, 0, { 0 },              0},
      { OWRIT, "values", (void*)IDL_TYP_LONG, 1, { 0 },              0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_DSKI02, handle, dladsc[SPICE_DLA_DSCSIZ], "
            "item, start, room, VALUES[]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   dladsc     = A_INT_ARGV( 1 );
   item       = S_INT_ARGV( 2 );
   start      = S_INT_ARGV( 3 );
   room       = S_INT_ARGV( 4 );
   values_dim = 0;

   /*
   Allocate the necessary memory for 'values'. Check for an error signal.
   */
   values = alloc_SpiceInt_C_array ( 1, (int) room );

   /*
   Test for a SPICE error signal, if found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /*
   Fill in the members of the local DLA descriptor.
   */
   descr.bwdptr = dladsc[0];
   descr.fwdptr = dladsc[1];
   descr.ibase  = dladsc[2];
   descr.isize  = dladsc[3];
   descr.dbase  = dladsc[4];
   descr.dsize  = dladsc[5];
   descr.cbase  = dladsc[6];
   descr.csize  = dladsc[7];

   dski02_c( handle, &descr, item, start, room, &values_dim, values );

   /* Check for SPICE call failure, clean up if failed. */
   if ( failed_c())
      {
      free_SpiceMemory( values );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   if ( values_dim != 0)
      {
      char      *values_copy;
      int        tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = values_dim;
      values_copy = IDL_MakeTempArray( IDL_TYP_LONG,
                                       tmp_ndims,
                                       tmp_dims,
                                       IDL_ARR_INI_NOP,
                                       &Argv[5]);

      memmove(values_copy, values, values_dim * sizeof(SpiceInt) );
      }

   /*
   Clean up temporary variables
   */
   free_SpiceMemory( values );
   ICY_ALLOC_CHECK;

   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dskmi2_c ( SpiceInt              nv,
                                ConstSpiceDouble      vrtces[][3],
                                SpiceInt              np,
                                ConstSpiceInt         plates[][3],
                                SpiceDouble           finscl,
                                SpiceInt              corscl,
                                SpiceInt              worksz,
                                SpiceInt              voxpsz,
                                SpiceInt              voxlsz,
                                SpiceBoolean          makvtl,
                                SpiceInt              spxisz,
                                SpiceInt              work   [][2],
                                SpiceDouble           spaixd [],
                                SpiceInt              spaixi []    );
*/
PROCEDURE CSPICE_DSKMI2(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              nv;
   SpiceDouble         * vrtces;
   SpiceInt              np;
   SpiceInt            * plates;
   SpiceDouble           finscl;
   SpiceInt              corscl;
   SpiceInt              worksz;
   SpiceInt              voxpsz;
   SpiceInt              voxlsz;
   SpiceBoolean          makvtl;
   SpiceInt              spxisz;
   SpiceDouble         * spaixd;
   SpiceInt            * spaixi;

   SpiceInt            * work;

   struct argcheck argcheck[] =
      {
      { OREAD, "vrtces", (void*)IDL_TYP_DOUBLE,  2, { 3, 0 }, 0},
      { OREAD, "plates", (void*)IDL_TYP_LONG,    2, { 3, 0 }, 0},
      { OREAD, "finscl", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "corscl", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "worksz", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "voxpsz", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "voxlsz", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "makvtl", (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      { OREAD, "spxisz", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "spaixd", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OWRIT, "spaixi", (void*)IDL_TYP_LONG,    1, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 11)
      {
      USAGE("CSPICE_DSKMI2, vrtces[3,N], plates[3,N], finscl, "
                           "corscl, worksz, voxpsz, voxlsz, "
                           "makvtl, spaisz, "
                           "SPAIXD[SPICE_DSK02_SPADSZ], SPAIXI[spaisz]");
      }

   if ( Argv_orig[0]->value.arr->n_dim == 1)
      {
      zzicy_argerr(0, "vrtces", IDL_VarName(Argv_orig[0]),
                  "ICY(INVALIDDIM): Matrix `vrtces` must have dimension "
                  "3xN, 2 dimensions. The input argument has 1 dimension. "
                  "Use `reform( argname, 3,1)` to create an Array[3,1] "
                  "argument from an Array[3] argument.");
      }

   if ( Argv_orig[1]->value.arr->n_dim == 1)
      {
      zzicy_argerr(1, "plates", IDL_VarName(Argv_orig[1]),
                  "ICY(INVALIDDIM): Matrix `plates` must have dimension "
                  "3xN, 2 dimensions. The input argument has 1 dimension. "
                  "Use `reform( argname, 3,1)` to create an Array[3,1] "
                  "argument from an Array[3] argument.");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   vrtces  = A_DBL_ARGV( 0 );
   plates  = A_INT_ARGV( 1 );
   finscl  = S_DBL_ARGV( 2 );
   corscl  = S_INT_ARGV( 3 );
   worksz  = S_INT_ARGV( 4 );
   voxpsz  = S_INT_ARGV( 5 );
   voxlsz  = S_INT_ARGV( 6 );
   makvtl  =S_BOOL_ARGV( 7 );
   spxisz  = S_INT_ARGV( 8 );

   nv = Argv[0]->value.arr->dim[1];
   np = Argv[1]->value.arr->dim[1];

   /*
   Allocate the necessary memory for 'work', 'spaixd', and 'spaixi'.
   Check for an error signal. Cleanup any allocated memory.
   */
   work   = alloc_SpiceInt_C_array( (int)worksz, 2 );
   if ( failed_c())
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   spaixd = alloc_SpiceDouble_C_array( 1, (int)SPICE_DSK02_SPADSZ );
   if ( failed_c())
      {
      free_SpiceMemory( work );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   spaixi = alloc_SpiceInt_C_array( 1, (int)spxisz );
   if ( failed_c())
      {
      free_SpiceMemory( work );
      free_SpiceMemory( spaixd );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   dskmi2_c ( nv,
              (Nx3d)vrtces,
              np,
              (Nx3i)plates,
              finscl,
              corscl,
              worksz,
              voxpsz,
              voxlsz,
              makvtl,
              spxisz,
              (SpiceInt(*)[2])work,
              spaixd,
              spaixi );

   /*
   Check for a failure signal. Free the memory assigned to 'work', 'spaixd',
   'spaixi' before signaling a IDL error.
   */
   if ( failed_c())
      {
      free_SpiceMemory( work   );
      free_SpiceMemory( spaixd );
      free_SpiceMemory( spaixi );

      /*
      The icy_fail call creates the error string then returns control
      to the IDL interpreter.
      */

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

      {
      char      *spaixd_copy;
      int        tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = SPICE_DSK02_SPADSZ;
      spaixd_copy = IDL_MakeTempArray( IDL_TYP_DOUBLE,
                                       tmp_ndims,
                                       tmp_dims,
                                       IDL_ARR_INI_NOP,
                                       &Argv[9]);

      memmove(spaixd_copy, spaixd, SPICE_DSK02_SPADSZ * sizeof(SpiceDouble) );
      }

   if (spxisz != 0)
      {
      char      *spaixi_copy;
      int        tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = spxisz;
      spaixi_copy = IDL_MakeTempArray( IDL_TYP_LONG,
                                       tmp_ndims,
                                       tmp_dims,
                                       IDL_ARR_INI_NOP,
                                       &Argv[10]);

      memmove(spaixi_copy, spaixi, spxisz * sizeof(SpiceInt) );
      }


   /*
   Clean up temporary variables
   */
   free_SpiceMemory( work );
   free_SpiceMemory( spaixd );
   free_SpiceMemory( spaixi );
   ICY_ALLOC_CHECK;

   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dskn02_c ( SpiceInt            handle,
                                ConstSpiceInt     * dladsc,
                                SpiceInt            plid,
                                SpiceDouble         normal[3] )
*/
PROCEDURE CSPICE_DSKN02(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt            * dladsc;
   SpiceInt              plid;
   SpiceDouble         * normal;

   SpiceDLADescr         descr;


   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,   0, { 0 },              0},
      { OREAD, "dladsc", (void*)IDL_TYP_LONG,   1, {SPICE_DLA_DSCSIZ}, 0},
      { OREAD, "plid",   (void*)IDL_TYP_LONG,   0, { 0 },              0},
      { OWRIT, "normal", (void*)IDL_TYP_DOUBLE, 1, { 3 },              0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_DSKN02, handle, dladsc[SPICE_DLA_DSCSIZ], "
            "plid, NORMAL[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   dladsc     = A_INT_ARGV( 1 );
   plid       = S_INT_ARGV( 2 );
   normal     = A_DBL_ARGV( 3 );


   /*
   Fill in the members of the local DLA descriptor.
   */
   descr.bwdptr = dladsc[0];
   descr.fwdptr = dladsc[1];
   descr.ibase  = dladsc[2];
   descr.isize  = dladsc[3];
   descr.dbase  = dladsc[4];
   descr.dsize  = dladsc[5];
   descr.cbase  = dladsc[6];
   descr.csize  = dladsc[7];


   dskn02_c( handle, &descr, plid, normal );

   /* Check for SPICE call failure, clean up if failed. */
   CHECK_CALL_FAILURE( SCALAR );


   /*
   Clean up temporary variables
   */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*

 void              dskobj_c ( ConstSpiceChar  * dsk,
                              SpiceCell       * bodids )

*/
PROCEDURE CSPICE_DSKOBJ(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset;
   SpiceChar            * dsk;
   SpiceCell              bodids;

   struct argcheck argcheck[] =
      {
      { OREAD, "dsk",    (void*)IDL_TYP_STRING, 0, { 0 }, 0},
      { RDWRT, "bodids", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_DSKOBJ, dsk, (BODIDS)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[1].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   dsk = S_STR_ARGV( 0 );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[1]->value.s.arr->data);
   pack_cell( &bodids, 1, tag_offset, Argv );

   dskobj_c ( dsk, &bodids );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( bodids, SCALAR );

   /*
   Unpack the data from 'bodids' to 'Argv'.
   */
   unpack_cell( 1, tag_offset, &bodids, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dskopn_c ( ConstSpiceChar    * fname,
                                ConstSpiceChar    * ifname,
                                SpiceInt            ncomch,
                                SpiceInt          * handle  )
*/
PROCEDURE CSPICE_DSKOPN(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * fname;
   SpiceChar           * ifname;
   SpiceInt              ncomch;
   SpiceInt              handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "fname",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "ifname", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "ncomch", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_DSKOPN, `fname`, `ifname`, ncomch, HANDLE");
      }


   extra  = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   fname  = S_STR_ARGV( 0 );
   ifname = S_STR_ARGV( 1 );
   ncomch = S_INT_ARGV( 2 );

   dskopn_c( fname, ifname, ncomch, &handle );

   /*
   Test for a SPICE error signal, if found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[3]->value.l = handle;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dskp02_c ( SpiceInt            handle,
                                ConstSpiceInt     * dladsc,
                                SpiceInt            start,
                                SpiceInt            room,
                                SpiceInt          * n,
                                SpiceInt            plates[][3]  )
*/
PROCEDURE CSPICE_DSKP02(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt            * dladsc;
   SpiceInt              start;
   SpiceInt              room;
   SpiceInt              values_dim;
   SpiceInt            * values;
   SpiceDLADescr         descr;


   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG, 0, { 0 },              0},
      { OREAD, "dladsc", (void*)IDL_TYP_LONG, 1, {SPICE_DLA_DSCSIZ}, 0},
      { OREAD, "start",  (void*)IDL_TYP_LONG, 0, { 0 },              0},
      { OREAD, "room",   (void*)IDL_TYP_LONG, 0, { 0 },              0},
      { OWRIT, "plates", (void*)IDL_TYP_LONG, 2, { 3, 0 },           0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 5)
      {
      USAGE("CSPICE_DSKP02, handle, dladsc[SPICE_DLA_DSCSIZ], "
            "start, room, PLATES[3,N]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   dladsc     = A_INT_ARGV( 1 );
   start      = S_INT_ARGV( 2 );
   room       = S_INT_ARGV( 3 );
   values_dim = 0;

   /*
   Allocate the necessary memory for 'values'. Check for an error signal.
   */
   values = alloc_SpiceInt_C_array ( 3, room );

   /*
   Test for a SPICE error signal, if found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /*
   Fill in the members of the local DLA descriptor.
   */
   descr.bwdptr = dladsc[0];
   descr.fwdptr = dladsc[1];
   descr.ibase  = dladsc[2];
   descr.isize  = dladsc[3];
   descr.dbase  = dladsc[4];
   descr.dsize  = dladsc[5];
   descr.cbase  = dladsc[6];
   descr.csize  = dladsc[7];


   dskp02_c( handle, &descr,      start,
             room,   &values_dim, (SpiceInt(*)[3])values );

   /* Check for SPICE call failure, clean up if failed. */
   if ( failed_c())
      {
      free_SpiceMemory( values );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   if ( values_dim != 0)
      {
      char      *values_copy;
      int        tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 2;
      tmp_dims[0] = 3;
      tmp_dims[1] = values_dim;
      values_copy = IDL_MakeTempArray( IDL_TYP_LONG,
                                       tmp_ndims,
                                       tmp_dims,
                                       IDL_ARR_INI_NOP,
                                       &Argv[4]);

      memmove(values_copy, values, 3 * values_dim * sizeof(SpiceInt) );
      }

   /*
   Clean up temporary variables
   */
   free_SpiceMemory( values );
   ICY_ALLOC_CHECK;

   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
 void              dskrb2_c ( SpiceInt              nv,
                              ConstSpiceDouble      vrtces[][3],
                              SpiceInt              np,
                              ConstSpiceInt         plates[][3],
                              SpiceInt              corsys,
                              ConstSpiceDouble      corpar[],
                              SpiceDouble         * mncor3,
                              SpiceDouble         * mxcor3       );
*/
PROCEDURE CSPICE_DSKRB2(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * vrtces;
   SpiceInt           * plates;
   SpiceInt             corsys;
   SpiceDouble        * corpar;
   SpiceDouble          mncor3;
   SpiceDouble          mxcor3;

   SpiceInt             nv = 0;
   SpiceInt             np = 0;

   struct argcheck argcheck[] =
      {
      { OREAD, "vrtces", (void*)IDL_TYP_DOUBLE,  2, { 3, 0 }, 0},
      { OREAD, "plates", (void*)IDL_TYP_LONG,    2, { 3, 0 }, 0},
      { OREAD, "corsys", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "corpar", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OWRIT, "mncor3", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "mxcor3", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_DSKRB2, vrtces[3,NV], plates[3,NP], corsys, "
                           "corpar[SPICE_DSK_NSYPAR], MNCOR3, MXCOR3");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   vrtces  = A_DBL_ARGV( 0 );
   plates  = A_INT_ARGV( 1 );
   corsys  = S_INT_ARGV( 2 );
   corpar  = A_DBL_ARGV( 3 );

   nv = Argv[0]->value.arr->dim[1];
   np = Argv[1]->value.arr->dim[1];

   dskrb2_c ( nv,
              (Nx3d)vrtces,
              np,
              (Nx3i)plates,
              corsys,
              corpar,
              &mncor3,
              &mxcor3 );

   /*
   Test for a SPICE error signal, if found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[4]->value.d = mncor3;
   Argv[5]->value.d = mxcor3;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
void              dsksrf_c ( ConstSpiceChar      * dsk,
                             SpiceInt              bodyid,
                             SpiceCell           * srfids );
*/
PROCEDURE CSPICE_DSKSRF(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset;
   SpiceChar            * dsk;
   SpiceInt               bodyid;
   SpiceCell              srfids;

   struct argcheck argcheck[] =
      {
      { OREAD, "dsk",    (void*)IDL_TYP_STRING, 0, { 0 }, 0},
      { OREAD, "bodyid", (void*)IDL_TYP_LONG,   0, { 0 }, 0},
      { RDWRT, "srfids", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_DSKSRF, dsk, bodyid, (SRFIDS)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[2].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   dsk    = S_STR_ARGV( 0 );
   bodyid = S_INT_ARGV( 1 );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[2]->value.s.arr->data);
   pack_cell( &srfids, 2, tag_offset, Argv );

   dsksrf_c ( dsk, bodyid, &srfids );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( srfids, SCALAR );

   /*
   Unpack the data from 'srfids' to 'Argv'.
   */
   unpack_cell( 2, tag_offset, &srfids, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }





/*
   void              dskstl_c ( SpiceInt        keywrd,
                                SpiceDouble     dpval  )
*/
PROCEDURE CSPICE_DSKSTL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             keywrd;
   SpiceDouble          dpval;

   struct argcheck argcheck[] =
      {
      { OREAD, "keywrd", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "dpval",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_DSKSTL, keywrd, dpval");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   keywrd     = S_INT_ARGV( 0 );
   dpval      = S_DBL_ARGV( 1 );

   /* Scalar */
   (void) dskstl_c ( keywrd, dpval );

   /*
   Test for a SPICE error signal. If found, display an error message
   to the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dskv02_c ( SpiceInt            handle,
                                ConstSpiceInt     * dladsc,
                                SpiceInt            start,
                                SpiceInt            room,
                                SpiceInt          * n,
                                SpiceDouble         vrtces[][3]  )
*/
PROCEDURE CSPICE_DSKV02(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt            * dladsc;
   SpiceInt              start;
   SpiceInt              room;
   SpiceInt              values_dim;
   SpiceDouble         * values;
   SpiceDLADescr         descr;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,   0, { 0 },              0},
      { OREAD, "dladsc", (void*)IDL_TYP_LONG,   1, {SPICE_DLA_DSCSIZ}, 0},
      { OREAD, "start",  (void*)IDL_TYP_LONG,   0, { 0 },              0},
      { OREAD, "room",   (void*)IDL_TYP_LONG,   0, { 0 },              0},
      { OWRIT, "vrtces", (void*)IDL_TYP_DOUBLE, 2, { 3, 0 },           0},
      };



   /* Check the input contains the correct number of arguments. */
   if (Argc != 5)
      {
      USAGE("CSPICE_DSKV02, handle, dladsc[SPICE_DLA_DSCSIZ], "
            "start, room, VRTCES[3,N]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   dladsc     = A_INT_ARGV( 1 );
   start      = S_INT_ARGV( 2 );
   room       = S_INT_ARGV( 3 );
   values_dim = 0;

   /*
   Allocate the necessary memory for 'values'. Check for an error signal.
   */
   values    = alloc_SpiceDouble_C_array ( (int)room, 3 );

   /*
   Test for a SPICE error signal, if found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /*
   Fill in the members of the local DLA descriptor.
   */
   descr.bwdptr = dladsc[0];
   descr.fwdptr = dladsc[1];
   descr.ibase  = dladsc[2];
   descr.isize  = dladsc[3];
   descr.dbase  = dladsc[4];
   descr.dsize  = dladsc[5];
   descr.cbase  = dladsc[6];
   descr.csize  = dladsc[7];

   dskv02_c( handle,
             &descr,
             start,
             room,
             &values_dim,
             (SpiceDouble(*)[3])values );

   /* Check for SPICE call failure, clean up if failed. */
   if ( failed_c())
      {
      free_SpiceMemory( values );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   if ( values_dim != 0)
      {
      char      *values_copy;
      int        tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 2;
      tmp_dims[0] = 3;
      tmp_dims[1] = values_dim;
      values_copy = IDL_MakeTempArray( IDL_TYP_DOUBLE,
                                       tmp_ndims,
                                       tmp_dims,
                                       IDL_ARR_INI_NOP,
                                       &Argv[4]);

      memmove(values_copy, values, 3 * values_dim * sizeof(SpiceDouble) );
      }

   /*
   Clean up temporary variables
   */
   free_SpiceMemory( values );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dskw02_c ( SpiceInt             handle,
                                SpiceInt             center,
                                SpiceInt             surfid,
                                SpiceInt             dclass,
                                ConstSpiceChar     * frame,
                                SpiceInt             corsys,
                                ConstSpiceDouble     corpar[],
                                SpiceDouble          mncor1,
                                SpiceDouble          mxcor1,
                                SpiceDouble          mncor2,
                                SpiceDouble          mxcor2,
                                SpiceDouble          mncor3,
                                SpiceDouble          mxcor3,
                                SpiceDouble          first,
                                SpiceDouble          last,
                                SpiceInt             nv,
                                ConstSpiceDouble     vrtces[][3],
                                SpiceInt             np,
                                ConstSpiceInt        plates[][3],
                                ConstSpiceDouble     spaixd[],
                                ConstSpiceInt        spaixi[]      )
*/
PROCEDURE CSPICE_DSKW02(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceInt             center;
   SpiceInt             surfid;
   SpiceInt             dclass;
   SpiceChar          * frame;
   SpiceInt             corsys;
   SpiceDouble        * corpar;
   SpiceDouble          mncor1;
   SpiceDouble          mxcor1;
   SpiceDouble          mncor2;
   SpiceDouble          mxcor2;
   SpiceDouble          mncor3;
   SpiceDouble          mxcor3;
   SpiceDouble          first;
   SpiceDouble          last;
   SpiceInt             nv;
   ConstSpiceDouble   * vrtces;
   SpiceInt             np;
   ConstSpiceInt      * plates;
   ConstSpiceDouble   * spaixd;
   ConstSpiceInt      * spaixi;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "center", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "surfid", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "dclass", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "frame",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "corsys", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "corpar", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OREAD, "mncor1", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "mxcor1", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "mncor2", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "mxcor2", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "mncor3", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "mxcor3", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "first",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "last",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "vrtces", (void*)IDL_TYP_DOUBLE,  2, { 3, 0 }, 0},
      { OREAD, "plates", (void*)IDL_TYP_LONG,    2, { 3, 0 }, 0},
      { OREAD, "spaixd", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OREAD, "spaixi", (void*)IDL_TYP_LONG,    1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 19)
      {
      USAGE("CSPICE_DSKW02, handle, center, surfid, dclass, "
            "`frame`, corsys, corpar[SPICE_DSK_NSYPAR], mncor1, mxcor1, "
            "mncor2, mxcor2, mncor3, mxcor3, first, last, vrtces[3,NV], "
            "plates[3,NP], spaixd[M], spaixi[N] ");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle  = S_INT_ARGV( 0 );
   center  = S_INT_ARGV( 1 );
   surfid  = S_INT_ARGV( 2 );
   dclass  = S_INT_ARGV( 3 );
   frame   = S_STR_ARGV( 4 );
   corsys  = S_INT_ARGV( 5 );
   corpar  = A_DBL_ARGV( 6 );
   mncor1  = S_DBL_ARGV( 7 );
   mxcor1  = S_DBL_ARGV( 8 );
   mncor2  = S_DBL_ARGV( 9 );
   mxcor2  = S_DBL_ARGV( 10 );
   mncor3  = S_DBL_ARGV( 11 );
   mxcor3  = S_DBL_ARGV( 12 );
   first   = S_DBL_ARGV( 13 );
   last    = S_DBL_ARGV( 14 );
   vrtces  = (ConstSpiceDouble*)Argv[15]->value.arr->data;
   plates  = (ConstSpiceInt*   )Argv[16]->value.arr->data;
   spaixd  = (ConstSpiceDouble*)Argv[17]->value.arr->data;
   spaixi  = (ConstSpiceInt*   )Argv[18]->value.arr->data;

   nv = Argv[15]->value.arr->dim[1];
   np = Argv[16]->value.arr->dim[1];

   dskw02_c ( handle,
              center,
              surfid,
              dclass,
              frame,
              corsys,
              corpar,
              mncor1,
              mxcor1,
              mncor2,
              mxcor2,
              mncor3,
              mxcor3,
              first,
              last,
              nv,
              (Nx3d)vrtces,
              np,
              (Nx3i)plates,
              spaixd,
              spaixi );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void dskx02_c ( SpiceInt            handle,
                   ConstSpiceInt     * dladsc,
                   ConstSpiceDouble    vertex[3],
                   ConstSpiceDouble    raydir[3],
                   SpiceInt          * plid,
                   SpiceDouble         xpt[3],
                   SpiceBoolean      * found     )
*/
PROCEDURE CSPICE_DSKX02(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt            * dladsc;
   SpiceDouble         * vertex;
   SpiceDouble         * raydir;
   SpiceInt              plid;
   SpiceDouble         * xpt;
   SpiceBoolean          found;

   SpiceDLADescr         descr;


   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,   0, { 0 },              0},
      { OREAD, "dladsc", (void*)IDL_TYP_LONG,   1, {SPICE_DLA_DSCSIZ}, 0},
      { OREAD, "vertex", (void*)IDL_TYP_DOUBLE, 1, { 3 },              0},
      { OREAD, "raydir", (void*)IDL_TYP_DOUBLE, 1, { 3 },              0},
      { OWRIT, "plid",   (void*)IDL_TYP_LONG,   0, { 0 },              0},
      { OWRIT, "normal", (void*)IDL_TYP_DOUBLE, 1, { 3 },              0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE,   0, { 0 },              0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_DSKX02, handle, dladsc[SPICE_DLA_DSCSIZ], vertex, raydir, "
            "PLID, XPT[3], FOUND" );
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   dladsc     = A_INT_ARGV( 1 );
   vertex     = A_DBL_ARGV( 2 );
   raydir     = A_DBL_ARGV( 3 );
   xpt        = A_DBL_ARGV( 5 );

   /*
   Fill in the members of the local DLA descriptor.
   */
   descr.bwdptr = dladsc[0];
   descr.fwdptr = dladsc[1];
   descr.ibase  = dladsc[2];
   descr.isize  = dladsc[3];
   descr.dbase  = dladsc[4];
   descr.dsize  = dladsc[5];
   descr.cbase  = dladsc[6];
   descr.csize  = dladsc[7];


   dskx02_c( handle, &descr, vertex, raydir, &plid, xpt, &found );


   /* Check for SPICE call failure, clean up if failed. */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[4]->value.l = plid;
   Argv[6]->value.c = found;

   /*
   Clean up temporary variables
   */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dskxsi_c ( SpiceBoolean           pri,
                                ConstSpiceChar       * target,
                                SpiceInt               nsurf,
                                ConstSpiceInt          srflst [],
                                SpiceDouble            et,
                                ConstSpiceChar       * fixref,
                                ConstSpiceDouble       vertex [3],
                                ConstSpiceDouble       raydir [3],
                                SpiceInt               maxd,
                                SpiceInt               maxi,
                                SpiceDouble            xpt    [3],
                                SpiceInt             * handle,
                                SpiceDLADescr        * dladsc,
                                SpiceDSKDescr        * dskdsc,
                                SpiceDouble            dc     [],
                                SpiceInt               ic     [],
                                SpiceBoolean         * found      );
*/
PROCEDURE CSPICE_DSKXSI(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceBoolean          pri;
   ConstSpiceChar      * target;
   SpiceInt              nsurf;
   ConstSpiceInt       * srflst;
   SpiceDouble           et;
   ConstSpiceChar      * fixref;
   ConstSpiceDouble    * vertex;
   ConstSpiceDouble    * raydir;
   SpiceInt              maxd;
   SpiceInt              maxi;
   SpiceDouble         * xpt;
   SpiceInt              handle;
   SpiceInt            * dladsc;
   SpiceDouble         * dskdsc;
   SpiceDouble         * dc;
   SpiceInt            * ic;
   SpiceBoolean          found;

   struct argcheck argcheck[] =
      {
      { OREAD, "pri",    (void*)IDL_TYP_BYTE,   0, { 0 }, 0},
      { OREAD, "target", (void*)IDL_TYP_STRING, 0, { 0 }, 0},
      { OREAD, "nsurf",  (void*)IDL_TYP_LONG,   0, { 0 }, 0},
      { OREAD, "srflst", (void*)IDL_TYP_LONG,   1, { 0 }, 0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE, 0, { 0 }, 0},
      { OREAD, "fixref", (void*)IDL_TYP_STRING, 0, { 0 }, 0},
      { OREAD, "vertex", (void*)IDL_TYP_DOUBLE, 1, { 3 }, 0},
      { OREAD, "raydir", (void*)IDL_TYP_DOUBLE, 1, { 3 }, 0},
      { OWRIT, "xpt",    (void*)IDL_TYP_DOUBLE, 1, { 3 }, 0},
      { OWRIT, "handle", (void*)IDL_TYP_LONG,   0, { 0 }, 0},
      { OWRIT, "dladsc", (void*)IDL_TYP_LONG,   1, {SPICE_DLA_DSCSIZ},    0},
      { OWRIT, "dskdsc", (void*)IDL_TYP_DOUBLE, 1, {SPICE_DSK_DSCSIZ},    0},
      { OWRIT, "dc",     (void*)IDL_TYP_DOUBLE, 1, {SPICE_DSKXSI_DCSIZE}, 0},
      { OWRIT, "ic",     (void*)IDL_TYP_LONG,   1, {SPICE_DSKXSI_ICSIZE}, 0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE,   0, { 0 }, 0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 15)
      {
      USAGE("CSPICE_DSKXSI, pri, target, nsurf, srflst[], et, fixref, "
            "vertex[3], raydir[3], XPT[3], HANDLE, DLADSC[SPICE_DLA_DSCSIZ], "
            "DSKDSC[SPICE_DSK_DSCSIZ], DC[], IC[], FOUND" );
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   pri        = S_BOOL_ARGV( 0 );
   target     =  S_STR_ARGV( 1 );
   nsurf      =  S_INT_ARGV( 2 );
   srflst     =  A_INT_ARGV( 3 );
   et         =  S_DBL_ARGV( 4 );
   fixref     =  S_STR_ARGV( 5 );
   vertex     =  A_DBL_ARGV( 6 );
   raydir     =  A_DBL_ARGV( 7 );
   xpt        =  A_DBL_ARGV( 8 );
   dladsc     =  A_INT_ARGV( 10 );
   dskdsc     =  A_DBL_ARGV( 11 );
   dc         =  A_DBL_ARGV( 12 );
   ic         =  A_INT_ARGV( 13 );

   maxd = SPICE_DSKXSI_DCSIZE;
   maxi = SPICE_DSKXSI_ICSIZE;

   dskxsi_ ( (logical     *) &pri,
             (char        *) target,
             (integer     *) &nsurf,
             (integer     *) srflst,
             (doublereal  *) &et,
             (char        *) fixref,
             (doublereal  *) vertex,
             (doublereal  *) raydir,
             (integer     *) &maxd,
             (integer     *) &maxi,
             (doublereal  *) xpt,
             (integer     *) &handle,
             (integer     *) dladsc,
             (doublereal  *) dskdsc,
             (doublereal  *) dc,
             (integer     *) ic,
             (logical     *) &found,
             (ftnlen       ) strlen(target),
             (ftnlen       ) strlen(fixref)  );

   /*
   Test for a SPICE error signal, if found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[9]->value.l  = handle;
   Argv[14]->value.c = found;

   /*
   Clean up temporary variables
   */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void               dskxv_c ( SpiceBoolean           pri,
                                ConstSpiceChar       * target,
                                SpiceInt               nsurf,
                                ConstSpiceInt          srflst[],
                                SpiceDouble            et,
                                ConstSpiceChar       * fixref,
                                SpiceInt               nrays,
                                ConstSpiceDouble       vtxarr[][3],
                                ConstSpiceDouble       dirarr[][3],
                                SpiceDouble            xptarr[][3],
                                SpiceBoolean           fndarr[]     );
*/
PROCEDURE CSPICE_DSKXV(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceBoolean          pri;
   ConstSpiceChar      * target;
   SpiceInt              nsurf;
   ConstSpiceInt       * srflst;
   SpiceDouble           et;
   ConstSpiceChar      * fixref;
   ConstSpiceDouble    * vtxarr;
   ConstSpiceDouble    * dirarr;
   SpiceDouble         * xptarr;

   SpiceBoolean         * fndarr;

   SpiceInt               nrays;
   SpiceInt               nd;
   SpiceInt               nv;

   struct argcheck argcheck[] =
      {
      { OREAD, "pri",    (void*)IDL_TYP_BYTE,   0, { 0 },    0},
      { OREAD, "target", (void*)IDL_TYP_STRING, 0, { 0 },    0},
      { OREAD, "nsurf",  (void*)IDL_TYP_LONG,   0, { 0 },    0},
      { OREAD, "srflst", (void*)IDL_TYP_LONG,   1, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE, 0, { 0 },    0},
      { OREAD, "fixref", (void*)IDL_TYP_STRING, 0, { 0 },    0},
      { OREAD, "vtxarr", (void*)IDL_TYP_DOUBLE, 2, { 3, 0 }, 0},
      { OREAD, "dirarr", (void*)IDL_TYP_DOUBLE, 2, { 3, 0 }, 0},
      { OWRIT, "xptarr", (void*)IDL_TYP_DOUBLE, 2, { 3, 0 }, 0},
      { OWRIT, "fndarr", (void*)IDL_TYP_BYTE,   1, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 10)
      {
      USAGE("CSPICE_DSKXV, pri, target, nsurf, srflst, et, fixref, "
            "vtxarr[3,N], dirarr[3,N], XPTARR[3,N], FNDARR[N]" );
      }


   if ( Argv_orig[6]->value.arr->n_dim == 1)
      {
      zzicy_argerr(6, "vtxarr", IDL_VarName(Argv_orig[6]),
                  "ICY(INVALIDDIM): Matrix `vtxarr` must have dimension "
                  "3xN, 2 dimensions. The input argument has 1 dimension. "
                  "Use `reform( argname, 3,1)` to create an Array[3,1] "
                  "argument from an Array[3] argument.");
      }

   if ( Argv_orig[7]->value.arr->n_dim == 1)
      {
      zzicy_argerr(7, "dirarr", IDL_VarName(Argv_orig[7]),
                  "ICY(INVALIDDIM): Matrix `dirarr` must have dimension "
                  "3xN, 2 dimensions. The input argument has 1 dimension. "
                  "Use `reform( argname, 3,1)` to create an Array[3,1] "
                  "argument from an Array[3] argument.");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   pri        = S_BOOL_ARGV( 0 );
   target     =  S_STR_ARGV( 1 );
   nsurf      =  S_INT_ARGV( 2 );
   srflst     =  A_INT_ARGV( 3 );
   et         =  S_DBL_ARGV( 4 );
   fixref     =  S_STR_ARGV( 5 );
   vtxarr     =  A_DBL_ARGV( 6 );
   dirarr     =  A_DBL_ARGV( 7 );

   nv         =  Argv[6]->value.arr->dim[1];
   nd         =  Argv[7]->value.arr->dim[1];

   /* Check dimensions of input arrays */
   if ( (nv != nd) )
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(7, "dirarr", IDL_VarName(Argv_orig[7]),
                      "ICY(INVALIDSIZE): Matrix `dirarr` must have the same "
                      "size and shape as `vtxarr`.");
      }

   nrays      = nv;

   /*
   Allocate the necessary memory for ic and dc. Check for an error signal.
   */
   xptarr = alloc_SpiceDouble_C_array ( (int) nrays, 3 );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   if ( failed_c())
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   fndarr = alloc_SpiceBoolean_C_array ( 1, (int) nrays);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   if ( failed_c())
      {
      free_SpiceMemory( xptarr );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

    dskxv_c ( pri,
              target,
              nsurf,
              srflst,
              et,
              fixref,
              nrays,
              (Nx3d)vtxarr,
              (Nx3d)dirarr,
              (SpiceDouble(*)[3])xptarr,
              fndarr         );

   /* Check for SPICE call failure, clean up if failed. */
   if ( failed_c())
      {
      free_SpiceMemory( xptarr );
      free_SpiceMemory( fndarr );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   if ( nrays > 0)
      {
      char      *xptarr_copy;
      char      *fndarr_copy;
      int        tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];
      long       i;

      tmp_ndims   = 2;
      tmp_dims[0] = 3;
      tmp_dims[1] = nrays;
      xptarr_copy = IDL_MakeTempArray( IDL_TYP_DOUBLE,
                                       tmp_ndims,
                                       tmp_dims,
                                       IDL_ARR_INI_NOP,
                                       &Argv[8]);

      tmp_ndims   = 1;
      tmp_dims[0] = nrays;
      tmp_dims[1] = 0;
      fndarr_copy = IDL_MakeTempArray( IDL_TYP_BYTE,
                                       tmp_ndims,
                                       tmp_dims,
                                       IDL_ARR_INI_NOP,
                                       &Argv[9]);

      memmove(xptarr_copy, xptarr, 3 * nrays * sizeof(SpiceDouble) );

      for (i=0; i < nrays; i++)
         {
         fndarr_copy[i] = (char) fndarr[i];
         }
      }

   /*
   Clean up temporary variables
   */
   free_SpiceMemory( xptarr );
   free_SpiceMemory( fndarr );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void dskz02_c ( SpiceInt            handle,
                   ConstSpiceInt     * dladsc,
                   SpiceInt          * nv,
                   SpiceInt          * np      )
*/
PROCEDURE CSPICE_DSKZ02(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt            * dladsc;
   SpiceInt              nv;
   SpiceInt              np;


   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG, 0, { 0 },              0},
      { OREAD, "dladsc", (void*)IDL_TYP_LONG, 1, {SPICE_DLA_DSCSIZ}, 0},
      { OWRIT, "nv",     (void*)IDL_TYP_LONG, 0, { 0 },              0},
      { OWRIT, "np",     (void*)IDL_TYP_LONG, 0, { 0 },              0},
      };

   /*
   Other local variables
   */
   SpiceDLADescr         descr;


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_DSKZ02, handle, dladsc[SPICE_DLA_DSCSIZ], NV, NP");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   dladsc     = A_INT_ARGV( 1 );


   /*
   Fill in the members of the local DLA descriptor.
   */
   descr.bwdptr = dladsc[0];
   descr.fwdptr = dladsc[1];
   descr.ibase  = dladsc[2];
   descr.isize  = dladsc[3];
   descr.dbase  = dladsc[4];
   descr.dsize  = dladsc[5];
   descr.cbase  = dladsc[6];
   descr.csize  = dladsc[7];


   dskz02_c( handle, &descr, &nv, &np );

   /*
   Test for a SPICE error signal, if found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[2]->value.l = nv;
   Argv[3]->value.l = np;


   /*
   Clean up temporary variables
   */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dsphdr_c ( SpiceDouble         x,
                                SpiceDouble         y,
                                SpiceDouble         z,
                                SpiceDouble         jacobi[3][3] );
*/
PROCEDURE CSPICE_DSPHDR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          x;
   SpiceDouble          y;
   SpiceDouble          z;
   SpiceDouble        * jacobi;

   struct argcheck argcheck[] =
      {
      { OREAD, "x",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "y",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "z",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "jacobi", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_DSPHDR, x, y, z, JACOBI[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   x      = S_DBL_ARGV( 0 );
   y      = S_DBL_ARGV( 1 );
   z      = S_DBL_ARGV( 2 );
   jacobi = A_DBL_ARGV( 3 );

   dsphdr_c(x, y, z, (SpiceDouble (*)[3])jacobi);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /*
   Clean up temporary variables
   */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dtpool_c ( ConstSpiceChar      * name,
                                SpiceBoolean        * found,
                                SpiceInt            * n,
                                SpiceChar             type [1] )
*/
PROCEDURE CSPICE_DTPOOL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR              * Argv;
   struct extra_dims     * extra;
   SpiceChar             * name;
   SpiceBoolean            found;
   SpiceInt                n;
   SpiceChar               type;
   SpiceChar               type_buf[2];

   struct argcheck argcheck[] =
      {
      { OREAD, "name",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "found", (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      { OWRIT, "n",     (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "type",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_DTPOOL, `name`, FOUND, N, `TYPE`");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   name   = S_STR_ARGV( 0 );

   dtpool_c( name, &found, &n, &type);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.c = found;
   Argv[2]->value.l = n;

   /* We return a string to IDL, so copy the char to a string. */
   type_buf[0] = type;
   type_buf[1] = '\0';

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV( 3, type_buf);

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ducrss_c ( ConstSpiceDouble s1  [6],
                                ConstSpiceDouble s2  [6],
                                SpiceDouble      sout[6] )
*/
PROCEDURE CSPICE_DUCRSS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * s1;
   SpiceDouble        * s2;
   SpiceDouble        * sout;

   struct argcheck argcheck[] =
      {
      { OREAD, "s1",   (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      { OREAD, "s2",   (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      { OWRIT, "sout", (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_DUCRSS, s1[6], s2[6], SOUT[6]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   s1    = A_DBL_ARGV( 0 );
   s2    = A_DBL_ARGV( 1 );
   sout  = A_DBL_ARGV( 2 );

   ducrss_c( s1, s2, sout );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              dvcrss_c ( ConstSpiceDouble s1  [6],
                                ConstSpiceDouble s2  [6],
                                SpiceDouble      sout[6] )
*/
PROCEDURE CSPICE_DVCRSS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * s1;
   SpiceDouble        * s2;
   SpiceDouble        * sout;

   struct argcheck argcheck[] =
      {
      { OREAD, "s1",   (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      { OREAD, "s2",   (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      { OWRIT, "sout", (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_DVCRSS, s1[6], s2[6], SOUT[6]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   s1    = A_DBL_ARGV( 0 );
   s2    = A_DBL_ARGV( 1 );
   sout  = A_DBL_ARGV( 2 );

   dvcrss_c( s1, s2, sout );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceDouble       dvdot_c  ( ConstSpiceDouble      s1[6],
                                ConstSpiceDouble      s2[6] )
*/
FUNCTION CSPICE_DVDOT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceDouble          dvdot;
   SpiceDouble        * s1;
   SpiceDouble        * s2;

   struct argcheck argcheck[] =
      {
      { OREAD, "s1", (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      { OREAD, "s2", (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("double  = CSPICE_DVDOT( s1[6], s2[6] )");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   s1 = A_DBL_ARGV( 0 );
   s2 = A_DBL_ARGV( 1 );

   dvdot = dvdot_c(s1,s2);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = dvdot;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              dvhat_c  ( ConstSpiceDouble      s1[6],
                                SpiceDouble           sout[6] )
*/
PROCEDURE CSPICE_DVHAT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * s1;
   SpiceDouble        * sout;

   struct argcheck argcheck[] =
      {
      { OREAD, "s1",   (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      { OWRIT, "sout", (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_DVHAT, s1[6], SOUT[6]");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   s1   = A_DBL_ARGV( 0 );
   sout = A_DBL_ARGV( 1 );

   dvhat_c(s1,sout);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceDouble       dvnorm_c  ( ConstSpiceDouble    state[6] )
*/
FUNCTION CSPICE_DVNORM(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceDouble          retval_c;
   SpiceDouble        * state;

   struct argcheck argcheck[] =
      {
      { OREAD, "state", (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("double  = CSPICE_DVNORM( state[6] )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   state  = A_DBL_ARGV( 0 );

   retval_c = dvnorm_c(state);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   SpiceDouble       dvsep_c  ( ConstSpiceDouble      s1[6],
                                ConstSpiceDouble      s2[6] )
*/
FUNCTION CSPICE_DVSEP(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceDouble          retval_c;
   SpiceDouble        * s1;
   SpiceDouble        * s2;

   struct argcheck argcheck[] =
      {
      { OREAD, "s1", (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      { OREAD, "s2", (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("double  = CSPICE_DVSEP( s1[6], s2[6] )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   s1 = A_DBL_ARGV( 0 );
   s2 = A_DBL_ARGV( 1 );

   retval_c = dvsep_c(s1,s2);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              dvpool_c ( ConstSpiceChar      * name )
*/
PROCEDURE CSPICE_DVPOOL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * name;

  struct argcheck argcheck[] =
      {
      { OREAD, "name", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_DVPOOL, `name`");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   name = S_STR_ARGV( 0 );

   dvpool_c(name);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              edlimb_c ( SpiceDouble           a,
                                SpiceDouble           b,
                                SpiceDouble           c,
                                ConstSpiceDouble      viewpt[3],
                                SpiceEllipse        * limb      )
*/
PROCEDURE CSPICE_EDLIMB(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR              * Argv;
   struct extra_dims     * extra;
   SpiceDouble             a;
   SpiceDouble             b;
   SpiceDouble             c;
   SpiceDouble           * viewpt;
   SpiceEllipse          * limb;

   struct argcheck argcheck[] =
      {
      { OREAD, "a",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "b",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "c",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "viewpt", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "limb",   (void*)IDL_TYP_STRUCT,  0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 5)
      {
      USAGE("CSPICE_EDLIMB, a, b, c, viewpt[3], LIMB");
      }


   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[4].type = s_SpiceEllipse;

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   a       = S_DBL_ARGV( 0 );
   b       = S_DBL_ARGV( 1 );
   c       = S_DBL_ARGV( 2 );
   viewpt  = A_DBL_ARGV( 3 );
   limb    = S_ELL_ARGV( 4 );

   edlimb_c(a,b,c,viewpt,limb);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              edterm_c ( ConstSpiceChar      * trmtyp,
                                ConstSpiceChar      * source,
                                ConstSpiceChar      * target,
                                SpiceDouble           et,
                                ConstSpiceChar      * fixfrm,
                                ConstSpiceChar      * abcorr,
                                ConstSpiceChar      * obsrvr,
                                SpiceInt              npts,
                                SpiceDouble         * trgepc,
                                SpiceDouble           obspos  [3],
                                SpiceDouble           termpts [][3] );
*/
PROCEDURE CSPICE_EDTERM(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * trmtyp;
   SpiceChar           * source;
   SpiceChar           * target;
   SpiceDouble           et;
   SpiceChar           * fixfrm;
   SpiceChar           * abcorr;
   SpiceChar           * obsrvr;
   SpiceInt              npts;
   SpiceDouble           trgepc;
   SpiceDouble         * obspos;
   SpiceDouble         * termpts;

   char                * termpts_copy;
   int                   tmp_ndims;
   IDL_MEMINT            tmp_dims[IDL_MAX_ARRAY_DIM];

   struct argcheck argcheck[] =
      {
      { OREAD, "trmtyp",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "source",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "target",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "fixfrm",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "abcorr",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obsrvr",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "npts",    (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "trgepc",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "obspos",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "termpts", (void*)IDL_TYP_DOUBLE,  2, { 3, 0 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 11)
      {
      USAGE("CSPICE_EDTERM, `trmtyp`, `source`, `target`, et, "
                           "`fixfrm`, `abcorr`, `obsrvr`, npts, "
                           "TRGEPC, OBSPOS[3], TERMPTS[3,N]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   trmtyp  = S_STR_ARGV( 0 );
   source  = S_STR_ARGV( 1 );
   target  = S_STR_ARGV( 2 );
   et      = S_DBL_ARGV( 3 );
   fixfrm  = S_STR_ARGV( 4 );
   abcorr  = S_STR_ARGV( 5 );
   obsrvr  = S_STR_ARGV( 6 );
   npts    = S_INT_ARGV( 7 );
   obspos  = A_DBL_ARGV( 9 );

   termpts  = alloc_SpiceDouble_C_array ( (int)npts, 3 );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   memset( termpts,  0, npts * 3 * sizeof(SpiceDouble) );

   edterm_c ( trmtyp,
              source,
              target,
              et,
              fixfrm,
              abcorr,
              obsrvr,
              npts,
              &trgepc,
              obspos,
              (SpiceDouble (*)[3])termpts);

   /* Check for SPICE call failure, clean up if failed. */
   if ( failed_c())
      {
      free_SpiceMemory( termpts );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   tmp_ndims    = 2;
   tmp_dims[0]  = 3;
   tmp_dims[1]  = npts;
   termpts_copy = IDL_MakeTempArray(IDL_TYP_DOUBLE,
                                    tmp_ndims,
                                    tmp_dims,
                                    IDL_ARR_INI_NOP,
                                    &Argv[10]);
   memmove(termpts_copy, termpts, 3 * npts * sizeof(SpiceDouble));

   Argv[8]->value.d = trgepc;

   /* Clean up temporary variables */
   free_SpiceMemory( termpts );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekacec_c ( SpiceInt              handle,
                                SpiceInt              segno,
                                SpiceInt              recno,
                                ConstSpiceChar      * column,
                                SpiceInt              nvals,
                                SpiceInt              vallen,
                                const void          * cvals,
                                SpiceBoolean          isnull )
*/
PROCEDURE CSPICE_EKACEC(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceInt             segno;
   SpiceInt             recno;
   SpiceChar          * column;
   SpiceInt             nvals;
   SpiceInt             cvals_len;
   SpiceInt             cvals_size;
   long                 i;
   SpiceChar         ** cvals;
   SpiceBoolean         isnull;

   struct argcheck    argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "segno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "recno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "column", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "nvals",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "length", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "cvals",  (void*)IDL_TYP_STRING,  1, { 0 },    0},
      { OREAD, "isnull", (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 8)
      {
      USAGE("CSPICE_EKACEC, handle, segno, recno, `column`, nvals, "
            "cvals_len, cvals[], isnull");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV(0);
   segno      = S_INT_ARGV(1);
   recno      = S_INT_ARGV(2);
   column     = S_STR_ARGV(3);
   nvals      = S_INT_ARGV(4);
   cvals_len  = S_INT_ARGV(5) + 1;
   cvals_size = A_LEN_ARGV(6);

   if ( nvals > cvals_size )
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(4, "nvals", IDL_VarName(Argv_orig[4]),
      "`nvals` exceeds array size of `cvals`");
      }

   cvals = alloc_SpiceString_C_array ( cvals_len, cvals_size );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /* Initialize local variables, to pass to CSPICE */
   for (i=0; i < nvals; i++)
      {
      strncpy( *cvals + i*cvals_len,
               IDL_STRING_STR(&((IDL_STRING*)(Argv[6]->value.arr->data))[i]),
               cvals_len);
      }

   isnull = S_BOOL_ARGV( 7 );

   ekacec_c(handle,segno,recno,column,nvals,cvals_len,*cvals,isnull);

   CHECK_CALL_FAILURE_MEM ( 1, cvals );

   /* Free the memory allocated to cvals. */
   free_SpiceString_C_array ( 1, cvals );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekaced_c ( SpiceInt              handle,
                                SpiceInt              segno,
                                SpiceInt              recno,
                                ConstSpiceChar      * column,
                                SpiceInt              nvals,
                                ConstSpiceDouble    * dvals,
                                SpiceBoolean          isnull )
*/
PROCEDURE CSPICE_EKACED(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt              segno;
   SpiceInt              recno;
   SpiceChar           * column;
   SpiceInt              nvals;
   SpiceInt              dvals_size;
   SpiceDouble         * dvals;
   SpiceBoolean          isnull;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "segno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "recno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "column", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "nvals",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "dvals",  (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OREAD, "isnull", (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_EKACED, handle, segno, recno, `column`, nvals, "
            "dvals[], isnull");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle = S_INT_ARGV( 0 );
   segno  = S_INT_ARGV( 1 );
   recno  = S_INT_ARGV( 2 );
   column = S_STR_ARGV( 3 );
   nvals  = S_INT_ARGV( 4 );
   dvals  = A_DBL_ARGV( 5 );
   isnull = S_BOOL_ARGV( 6 );

   dvals_size = A_LEN_ARGV( 5 );

   if ( nvals > dvals_size )
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(5, "dvals", IDL_VarName(Argv_orig[5]),
                     "`nvals` exceeds array size of `dvals`");
      }

   ekaced_c(handle,segno,recno,column,nvals,dvals,isnull);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekacei_c ( SpiceInt              handle,
                                SpiceInt              segno,
                                SpiceInt              recno,
                                ConstSpiceChar      * column,
                                SpiceInt              nvals,
                                ConstSpiceInt       * ivals,
                                SpiceBoolean          isnull )
*/
PROCEDURE CSPICE_EKACEI(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceInt             segno;
   SpiceInt             recno;
   SpiceChar          * column;
   SpiceInt             nvals;
   SpiceInt             ivals_size;
   SpiceInt           * ivals;
   SpiceBoolean         isnull;

   struct argcheck argcheck[] =
    {
    { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
    { OREAD, "segno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
    { OREAD, "recno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
    { OREAD, "column", (void*)IDL_TYP_STRING,  0, { 0 },    0},
    { OREAD, "nvals",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
    { OREAD, "ivals",  (void*)IDL_TYP_LONG,    1, { 0 },    0},
    { OREAD, "isnull", (void*)IDL_TYP_BYTE,    0, { 0 },    0},
    };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_EKACEI, handle, segno, recno, `column`, nvals, "
            "ivals[], isnull");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   segno      = S_INT_ARGV( 1 );
   recno      = S_INT_ARGV( 2 );
   column     = S_STR_ARGV( 3 );
   nvals      = S_INT_ARGV( 4 );
   ivals      = A_INT_ARGV( 5 );
   isnull     = S_BOOL_ARGV( 6 );

   ivals_size = A_LEN_ARGV( 5 );

   if ( nvals > ivals_size )
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(5, "ivals", IDL_VarName(Argv_orig[5]),
                     "`nvals` exceeds array size of `ivals`");
      }

   ekacei_c(handle,segno,recno,column,nvals,ivals,isnull);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekaclc_c ( SpiceInt              handle,
                                SpiceInt              segno,
                                ConstSpiceChar      * column,
                                SpiceInt              vallen,
                                const void          * cvals,
                                ConstSpiceInt       * entszs,
                                ConstSpiceBoolean   * nlflgs,
                                ConstSpiceInt       * rcptrs,
                                SpiceInt            * wkindx  );
*/
PROCEDURE CSPICE_EKACLC(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt              segno;
   SpiceChar           * column;
   SpiceInt              cvals_len;
   SpiceInt              cvals_size;
   SpiceChar          ** cvals;
   SpiceInt            * entszs;
   SpiceBoolean        * nlflgs;
   SpiceInt            * rcptrs;
   SpiceInt            * wkindx;
   SpiceInt              i;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "segno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "column", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "vallen", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "cvals",  (void*)IDL_TYP_STRING,  1, { 0 },    0},
      { OREAD, "entszs", (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { OREAD, "nlflgs", (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { OREAD, "rcptrs", (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { RDWRT, "wkindx", (void*)IDL_TYP_LONG,    1, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 9)
      {
      USAGE("CSPICE_EKACLC, handle, segno, `column`, vallen, "
            "cvals[], entszs[], nlflgs[], rcptrs[], (WKINDX[])");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle    = S_INT_ARGV( 0 );
   segno     = S_INT_ARGV( 1 );
   column    = S_STR_ARGV( 2 );
   cvals_len = S_INT_ARGV( 3 ) + 1;
   cvals_size= A_LEN_ARGV( 4 );
   entszs    = A_INT_ARGV( 5 );
   nlflgs    = A_BOOL_ARGV( 6 );
   rcptrs    = A_INT_ARGV( 7 );
   wkindx    = A_INT_ARGV( 8 );

   cvals = alloc_SpiceString_C_array ( cvals_len, cvals_size );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Initialize local variables, to pass to CSPICE */
   for (i=0; i < cvals_size; i++)
      {
      strncpy( *cvals + i*cvals_len,
               IDL_STRING_STR(&((IDL_STRING*)(Argv[4]->value.arr->data))[i]),
               cvals_len);
      }

   ekaclc_c(handle,segno,column,cvals_len,*cvals,entszs,nlflgs,rcptrs,wkindx);

   CHECK_CALL_FAILURE_MEM( 1, cvals );

   /* Free the memory allocated to cvals. */
   free_SpiceString_C_array ( 1, cvals );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekacld_c ( SpiceInt              handle,
                                SpiceInt              segno,
                                ConstSpiceChar      * column,
                                ConstSpiceDouble    * dvals,
                                ConstSpiceInt       * entszs,
                                ConstSpiceBoolean   * nlflgs,
                                ConstSpiceInt       * rcptrs,
                                SpiceInt            * wkindx  )
*/
PROCEDURE CSPICE_EKACLD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt              segno;
   SpiceChar           * column;
   SpiceDouble         * dvals;
   SpiceInt            * entszs;
   SpiceBoolean        * nlflgs;
   SpiceInt            * rcptrs;
   SpiceInt            * wkindx;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "segno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "column", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "dvals",  (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OREAD, "entszs", (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { OREAD, "nlflgs", (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { OREAD, "rcptrs", (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { RDWRT, "wkindx", (void*)IDL_TYP_LONG,    1, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 8)
      {
      USAGE("CSPICE_EKACLD, handle, segno, `column`, dvals[], "
            "entszs[], nlflgs[], rcptrs[], (WKINDX[])");
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle  = S_INT_ARGV( 0 );
   segno   = S_INT_ARGV( 1 );
   column  = S_STR_ARGV( 2 );
   dvals   = A_DBL_ARGV( 3 );
   entszs  = A_INT_ARGV( 4 );
   nlflgs  = A_BOOL_ARGV( 5 );
   rcptrs  = A_INT_ARGV( 6 );
   wkindx  = A_INT_ARGV( 7 );

   ekacld_c(handle,segno,column,dvals,entszs,nlflgs,rcptrs,wkindx);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekacli_c ( SpiceInt              handle,
                                SpiceInt              segno,
                                ConstSpiceChar      * column,
                                ConstSpiceInt       * ivals,
                                ConstSpiceInt       * entszs,
                                ConstSpiceBoolean   * nlflgs,
                                ConstSpiceInt       * rcptrs,
                                SpiceInt            * wkindx  )
*/
PROCEDURE CSPICE_EKACLI(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceInt             segno;
   SpiceChar          * column;
   SpiceInt           * ivals;
   SpiceInt           * entszs;
   SpiceBoolean       * nlflgs;
   SpiceInt           * rcptrs;
   SpiceInt           * wkindx;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "segno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "column", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "ivals",  (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { OREAD, "entszs", (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { OREAD, "nlflgs", (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { OREAD, "rcptrs", (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { RDWRT, "wkindx", (void*)IDL_TYP_LONG,    1, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 8)
      {
      USAGE("CSPICE_EKACLI, handle, segno, `column`, ivals[], "
            "entszs[], nlflgs[], rcptrs[], (WKINDX[])");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle = S_INT_ARGV( 0 );
   segno  = S_INT_ARGV( 1 );
   column = S_STR_ARGV( 2 );
   ivals  = A_INT_ARGV( 3 );
   entszs = A_INT_ARGV( 4 );
   nlflgs = A_BOOL_ARGV( 5 );
   rcptrs = A_INT_ARGV( 6 );
   wkindx = A_INT_ARGV( 7 );

   ekacli_c(handle,segno,column,ivals,entszs,nlflgs,rcptrs,wkindx);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekappr_c ( SpiceInt              handle,
                                SpiceInt              segno,
                                SpiceInt            * recno  )
*/
PROCEDURE CSPICE_EKAPPR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceInt             segno;
   SpiceInt             recno;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "segno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "recno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_EKAPPR, handle, segno, RECNO");
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle = S_INT_ARGV(0);
   segno  = S_INT_ARGV(1);

   ekappr_c( handle, segno, &recno);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[2]->value.l = recno;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekbseg_c ( SpiceInt              handle,
                                ConstSpiceChar      * tabnam,
                                SpiceInt              ncols,
                                SpiceInt              cnmlen,
                                const void          * cnames,
                                SpiceInt              declen,
                                const void          * decls,
                                SpiceInt            * segno  )
*/
PROCEDURE CSPICE_EKBSEG(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceChar           * tabnam;
   SpiceInt              ncols;
   SpiceInt              cnmlen;
   SpiceInt              declen;
   SpiceInt              segno;
   SpiceInt              i;
   SpiceChar             decls [SPICE_EK_MXCLSG][SPICE_EK_CSTRLN*10];
   SpiceChar             cnames[SPICE_EK_MXCLSG][SPICE_EK_CSTRLN];

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "tabnam", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "ncols",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "cnames", (void*)IDL_TYP_STRING,  1, { 0 },    0},
      { OREAD, "decls",  (void*)IDL_TYP_STRING,  1, { 0 },    0},
      { OWRIT, "segno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_EKBSEG, handle, `tabnam`, ncols, cnames, "
                   "decls, SEGNO");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle = S_INT_ARGV(0);
   tabnam = S_STR_ARGV(1);
   ncols  = S_INT_ARGV(2);

   /* The EK cannot contain more then SPICE_EK_MXCLSG columns */
   if ( ncols > SPICE_EK_MXCLSG  )
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(2, "ncols", IDL_VarName(Argv_orig[2]),
          "Value for `ncols` exceeds maximum allowed size for this array." );
      }

   /* The value of ncols must not exceed size of cvals (or decls). */
   if ( A_LEN_ARGV( 3 ) < ncols )
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(3, "cvals", IDL_VarName(Argv_orig[3]),
                     "Vector `cval` length less than input `ncols`");
      }

   /* Expect cvals and decls to have the same length. */
   if ( A_LEN_ARGV( 3 ) != A_LEN_ARGV( 4 ) )
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(4, "decls", IDL_VarName(Argv_orig[4]),
                     "Vector `decls` length differs from input `cvals`");
      }

   cnmlen = SPICE_EK_CSTRLN;
   declen = SPICE_EK_CSTRLN*10;

   for (i=0; i < ncols; i++)
      {
      strncpy( cnames[i],
             IDL_STRING_STR(&((IDL_STRING*)(Argv[3]->value.arr->data))[i]),
             sizeof(cnames[i])
             );

      strncpy( decls[i],
             IDL_STRING_STR(&((IDL_STRING*)(Argv[4]->value.arr->data))[i]),
             sizeof(decls[i])
             );
      }

   ekbseg_c( handle,
             tabnam,
             ncols,
             cnmlen,
             cnames,
             declen,
             decls,
             &segno);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   Argv[5]->value.l = segno;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekccnt_c ( ConstSpiceChar      * table,
                                SpiceInt            * ccount )
*/
PROCEDURE CSPICE_EKCCNT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceChar            * table;
   SpiceInt               ccount;

   struct argcheck argcheck[] =
      {
      { OREAD, "table",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "ccount", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_EKCCNT, `table`, CCOUNT");
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   table  = S_STR_ARGV( 0 );

   ekccnt_c( table, &ccount);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.l = ccount;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekcii_c  ( ConstSpiceChar      * table,
                                SpiceInt              cindex,
                                SpiceInt              lenout,
                                SpiceChar           * column,
                                SpiceEKAttDsc       * attdsc  )
*/
PROCEDURE CSPICE_EKCII(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * table;
   SpiceInt             cindex;
   SpiceInt             column_len;
   char                 column_buf[SPICE_EK_CSTRLN];
   SpiceEKAttDsc      * attdsc;

   struct argcheck argcheck[] =
      {
      { OREAD, "table",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "cindex", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "column", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "attdsc", (void*)IDL_TYP_STRUCT,  0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_EKCII, `table`, cindex, `COLUMN`, ATTDSC");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[3].type = s_SpiceEKAttDsc;

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   table      = S_STR_ARGV( 0 );
   cindex     = S_INT_ARGV(1);
   attdsc     = (SpiceEKAttDsc*)Argv[3]->value.s.arr->data;
   column_len = sizeof column_buf;

   ekcii_c( table, cindex, column_len, column_buf, attdsc);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV( 2, column_buf);

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekcls_c  ( SpiceInt              handle )
*/
PROCEDURE CSPICE_EKCLS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_EKCLS, handle");
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );

   ekcls_c(handle);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekdelr_c ( SpiceInt              handle,
                                SpiceInt              segno,
                                SpiceInt              recno )
*/
PROCEDURE CSPICE_EKDELR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceInt             segno;
   SpiceInt             recno;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "segno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "recno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_EKDELR, handle, segno, recno");
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle  = S_INT_ARGV(0);
   segno   = S_INT_ARGV(1);
   recno   = S_INT_ARGV(2);

   ekdelr_c(handle,segno,recno);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekffld_c ( SpiceInt            handle,
                                SpiceInt            segno,
                                SpiceInt          * rcptrs )
*/
PROCEDURE CSPICE_EKFFLD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt              segno;
   SpiceInt            * rcptrs;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "segno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "rcptrs", (void*)IDL_TYP_LONG,    1, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_EKFFLD, handle, segno, rcptrs[]");
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle  = S_INT_ARGV( 0 );
   segno   = S_INT_ARGV( 1 );
   rcptrs  = A_INT_ARGV( 2 );

   ekffld_c(handle,segno,rcptrs);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekfind_c ( ConstSpiceChar    * query,
                                SpiceInt            lenout,
                                SpiceInt          * nmrows,
                                SpiceBoolean      * error,
                                SpiceChar         * errmsg )
*/
PROCEDURE CSPICE_EKFIND(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * query;
   SpiceInt              nmrows;
   SpiceBoolean          error;
   SpiceChar             errmsg_buf[RET_ARRAY_LEN+1];

   struct argcheck argcheck[] =
      {
      { OREAD, "query",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "nmrows", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "error",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      { OWRIT, "errmsg", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_EKFIND, `query`, NMROWS, ERROR, `ERRMSG`");
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   query      = S_STR_ARGV( 0 );

   ekfind_c( query,
             RET_ARRAY_LEN,
             &nmrows,
             &error,
             errmsg_buf);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.l = nmrows;
   Argv[2]->value.c = error;

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV( 3, errmsg_buf);

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekgc_c   ( SpiceInt            selidx,
                                SpiceInt            row,
                                SpiceInt            elment,
                                SpiceInt            lenout,
                                SpiceChar         * cdata,
                                SpiceBoolean      * null,
                                SpiceBoolean      * found  )
*/
PROCEDURE CSPICE_EKGC(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              selidx;
   SpiceInt              row;
   SpiceInt              elment;
   SpiceInt              lenout;
   SpiceChar           * cdata_buf;
   SpiceBoolean          null;
   SpiceBoolean          found;

   struct argcheck argcheck[] =
      {
      { OREAD, "selidx", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "row",    (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "elment", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "lenout", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "cdata",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "null",   (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_EKGC, selidx, row, elment, lenout, "
                  "`CDATA`, NULL, FOUND");
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   selidx       = S_INT_ARGV( 0 );
   row          = S_INT_ARGV( 1 );
   elment       = S_INT_ARGV( 2 );
   lenout       = S_INT_ARGV( 3 ) + 1;

   cdata_buf    = alloc_SpiceString ( (int) lenout);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   ekgc_c( selidx, row, elment, lenout, cdata_buf, &null, &found);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   if ( failed_c())
      {
      free_SpiceMemory( cdata_buf );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV( 4, cdata_buf);

   Argv[5]->value.c = null;
   Argv[6]->value.c = found;

   /* Clean up temporary variables */
   free_SpiceMemory( cdata_buf );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekgd_c   ( SpiceInt            selidx,
                                SpiceInt            row,
                                SpiceInt            elment,
                                SpiceDouble       * ddata,
                                SpiceBoolean      * null,
                                SpiceBoolean      * found  )
*/
PROCEDURE CSPICE_EKGD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              selidx;
   SpiceInt              row;
   SpiceInt              elment;
   SpiceDouble           ddata;
   SpiceBoolean          null;
   SpiceBoolean          found;

   struct argcheck argcheck[] =
      {
      { OREAD, "selidx", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "row",    (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "elment", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "ddata",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "null",   (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_EKGD, selidx, row, elment, DDATA, NULL, FOUND");
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   selidx  = S_INT_ARGV( 0 );
   row     = S_INT_ARGV( 1 );
   elment  = S_INT_ARGV( 2 );

   ekgd_c( selidx, row, elment, &ddata, &null, &found);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[3]->value.d = ddata;
   Argv[4]->value.c = null;
   Argv[5]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekgi_c   ( SpiceInt            selidx,
                                SpiceInt            row,
                                SpiceInt            elment,
                                SpiceInt          * idata,
                                SpiceBoolean      * null,
                                SpiceBoolean      * found  )
*/
PROCEDURE CSPICE_EKGI(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              selidx;
   SpiceInt              row;
   SpiceInt              elment;
   SpiceInt              idata;
   SpiceBoolean          null;
   SpiceBoolean          found;

   struct argcheck argcheck[] =
      {
      { OREAD, "selidx", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "row",    (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "elment", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "idata",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "null",   (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_EKGI, selidx, row, elment, IDATA, NULL, FOUND");
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   selidx  = S_INT_ARGV( 0 );
   row     = S_INT_ARGV( 1 );
   elment  = S_INT_ARGV( 2 );

   ekgi_c( selidx, row, elment, &idata, &null, &found);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[3]->value.l = idata;
   Argv[4]->value.c = null;
   Argv[5]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekifld_c ( SpiceInt            handle,
                                ConstSpiceChar    * tabnam,
                                SpiceInt            ncols,
                                SpiceInt            nrows,
                                SpiceInt            cnmlen,
                                const void        * cnames,
                                SpiceInt            declen,
                                const void        * decls,
                                SpiceInt          * segno,
                                SpiceInt          * rcptrs )
*/
PROCEDURE CSPICE_EKIFLD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceChar           * tabnam;
   SpiceInt              ncols;
   SpiceInt              nrows;
   SpiceInt              cnames_len;
   SpiceInt              decls_len;
   SpiceInt              i;
   char                  cnames[SPICE_EK_MXCLSG][SPICE_EK_CSTRLN];
   char                  decls [SPICE_EK_MXCLSG][SPICE_EK_CSTRLN*10];
   SpiceInt              segno;
   SpiceInt            * rcptrs;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "tabnam", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "ncols",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "nrows",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "cnames", (void*)IDL_TYP_STRING,  1, { 0 },    0},
      { OREAD, "decls",  (void*)IDL_TYP_STRING,  1, { 0 },    0},
      { OWRIT, "segno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "rcptrs", (void*)IDL_TYP_LONG,    1, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 8)
      {
      USAGE("CSPICE_EKIFLD, handle, `tabnam`, ncols, nrows, "
            "cnames[], decls[], SEGNO, RCPTRS[]");
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   tabnam     = S_STR_ARGV( 1 );
   ncols      = S_INT_ARGV( 2 );
   nrows      = S_INT_ARGV( 3 );

   cnames_len = SPICE_EK_CSTRLN;
   decls_len  = SPICE_EK_CSTRLN * 10;

   /* The EK cannot contain more then SPICE_EK_MXCLSG columns */
   if ( ncols > SPICE_EK_MXCLSG  )
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(2, "ncols", IDL_VarName(Argv_orig[2]),
         "Value for `ncols` exceeds maximum allowed size for this array." );
      }

   /* The value of ncols must not exceed size of cvals (or decls). */
   if ( A_LEN_ARGV( 4 ) < ncols )
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(4, "cvals", IDL_VarName(Argv_orig[4]),
         "Vector `cval` length less than input `ncols`");
      }

   /* Expect cvals and decls to have the same length. */
   if ( A_LEN_ARGV( 5 ) != A_LEN_ARGV( 4 ) )
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(5, "decls", IDL_VarName(Argv_orig[5]),
         "Vector `decls` length differs from input `cvals`");
      }

   /* Copy the input string array to the CSPICE string array. */
   for (i=0; i < ncols; i++)
      {
      strncpy(cnames[i],
             IDL_STRING_STR(&((IDL_STRING*)(Argv[4]->value.arr->data))[i]),
             sizeof(cnames[i])
             );

      strncpy(decls[i],
             IDL_STRING_STR(&((IDL_STRING*)(Argv[5]->value.arr->data))[i]),
             sizeof(decls[i])
             );
      }


   /*
   Allocate the necessary memory for values. Check for an error signal.
   */
   rcptrs = alloc_SpiceInt_C_array ( 1, (int) nrows );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   ekifld_c ( handle,
              tabnam,
              ncols,
              nrows,
              cnames_len,
              cnames,
              decls_len,
              decls,
              &segno,
              rcptrs);

   /* Check for SPICE call failure, clean up if failed. */
   if ( failed_c())
      {
      free_SpiceMemory( rcptrs );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   Argv[6]->value.l = segno;

   if (nrows != 0)
      {
      char    *rcptrs_copy;
      int      tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = nrows;
      rcptrs_copy = IDL_MakeTempArray( IDL_TYP_LONG,
                                       tmp_ndims,
                                       tmp_dims,
                                       IDL_ARR_INI_NOP,
                                       &Argv[7]);
      memmove(rcptrs_copy, rcptrs, nrows * sizeof(SpiceInt) );
      }

   /* Clean up temporary variables */
   free_SpiceMemory( rcptrs );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekinsr_c ( SpiceInt            handle,
                                SpiceInt            segno,
                                SpiceInt            recno )
*/
PROCEDURE CSPICE_EKINSR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceInt             segno;
   SpiceInt             recno;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "segno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "recno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_EKINSR, handle, segno, recno");
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle  = S_INT_ARGV(0);
   segno   = S_INT_ARGV(1);
   recno   = S_INT_ARGV(2);

   ekinsr_c(handle,segno,recno);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              eklef_c  ( ConstSpiceChar    * fname,
                                SpiceInt          * handle )
*/
PROCEDURE CSPICE_EKLEF(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * fname;
   SpiceInt              handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "fname",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_EKLEF, `fname`, HANDLE");
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   fname      = S_STR_ARGV( 0 );

   eklef_c( fname, &handle);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.l = handle;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceInt          eknelt_c ( SpiceInt            selidx,
                                SpiceInt            row     )
*/
FUNCTION CSPICE_EKNELT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceInt             retval_c;
   SpiceInt             selidx;
   SpiceInt             row;

   struct argcheck argcheck[] =
      {
      { OREAD, "selidx", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "row",    (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("integer = CSPICE_EKNELT( selidx, row )");
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   selidx  = S_INT_ARGV( 0 );
   row     = S_INT_ARGV( 1 );

   retval_c = eknelt_c( selidx, row);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_LONG;
   retval_idl->value.l  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   SpiceInt          eknseg_c ( SpiceInt            handle )
*/
FUNCTION CSPICE_EKNSEG(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceInt             retval_c;
   SpiceInt             handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("integer = CSPICE_EKNSEG( handle )");
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle   = S_INT_ARGV( 0 );

   retval_c = eknseg_c(handle);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_LONG;
   retval_idl->value.l  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              ekntab_c ( SpiceInt            * n )
*/
PROCEDURE CSPICE_EKNTAB(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             n;

   struct argcheck argcheck[] =
      {
      { OWRIT, "n", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_EKNTAB, N");
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   ekntab_c(&n);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[0]->value.l = n;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekopn_c  ( ConstSpiceChar    * fname,
                                ConstSpiceChar    * ifname,
                                SpiceInt            ncomch,
                                SpiceInt          * handle )
*/
PROCEDURE CSPICE_EKOPN(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * fname;
   SpiceChar          * ifname;
   SpiceInt             ncomch;
   SpiceInt             handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "fname",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "ifname", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "ncomch", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_EKOPN, `fname`, `ifname`, ncomch, HANDLE");
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   fname   = S_STR_ARGV( 0 );
   ifname  = S_STR_ARGV( 1 );
   ncomch  = S_INT_ARGV( 2 );

   ekopn_c( fname, ifname, ncomch, &handle);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[3]->value.l = handle;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekopr_c  ( ConstSpiceChar    * fname,
                                SpiceInt          * handle )
*/
PROCEDURE CSPICE_EKOPR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            *Argv;
   struct extra_dims   *extra;
   SpiceChar           * fname;
   SpiceInt              handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "fname",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_EKOPR, `fname`, HANDLE");
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   fname   = S_STR_ARGV( 0 );

   ekopr_c( fname, &handle);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.l = handle;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekops_c  ( SpiceInt          * handle )
*/
PROCEDURE CSPICE_EKOPS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;

   struct argcheck argcheck[] =
      {
      { OWRIT, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_EKOPS, HANDLE");
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   ekops_c( &handle);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[0]->value.l = handle;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekopw_c  ( ConstSpiceChar    * fname,
                                SpiceInt          * handle )
*/
PROCEDURE CSPICE_EKOPW(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * fname;
   SpiceInt             handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "fname",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_EKOPW, `fname`, HANDLE");
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   fname   = S_STR_ARGV( 0 );

   ekopw_c( fname, &handle);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.l = handle;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekpsel_c ( ConstSpiceChar    * query,
                                SpiceInt            msglen,
                                SpiceInt            tablen,
                                SpiceInt            collen,
                                SpiceInt          * n,
                                SpiceInt          * xbegs,
                                SpiceInt          * xends,
                                SpiceEKDataType   * xtypes,
                                SpiceEKExprClass  * xclass,
                                void              * tabs,
                                void              * cols,
                                SpiceBoolean      * error,
                                SpiceChar         * errmsg )
*/
PROCEDURE CSPICE_EKPSEL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * query;
   SpiceInt              n;
   SpiceInt              xbegs [SPICE_EK_MAXQSEL];
   SpiceInt              xends [SPICE_EK_MAXQSEL];
   SpiceEKDataType       xtypes[SPICE_EK_MAXQSEL];
   SpiceEKExprClass      xclass[SPICE_EK_MAXQSEL];
   SpiceChar             tabs  [SPICE_EK_MAXQSEL][SPICE_EK_TSTRLN];
   SpiceChar             cols  [SPICE_EK_MAXQSEL][SPICE_EK_CSTRLN];
   SpiceBoolean          error;
   char                  errmsg_buf[RET_ARRAY_LEN+1];

   struct argcheck argcheck[] =
      {
      { OREAD, "query",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "n",      (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "xbegs",  (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { OWRIT, "xends",  (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { OWRIT, "xtypes", (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { OWRIT, "xclass", (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { OWRIT, "tabs",   (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { OWRIT, "cols",   (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { OWRIT, "error",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      { OWRIT, "errmsg", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 10)
      {
      USAGE("CSPICE_EKPSEL, `query`, N, XBEGS[], XENDS[], XTYPES[], "
            "XCLASS[], TABS[], COLS[], ERROR, `ERRMSG`");
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   query = S_STR_ARGV( 0 );

   (void) ekpsel_c( (ConstSpiceChar*) query,
            RET_ARRAY_LEN,
            (SpiceInt)SPICE_EK_TSTRLN,
            (SpiceInt)SPICE_EK_CSTRLN,
            &n,
            xbegs,
            xends,
            xtypes,
            xclass,
            tabs,
            cols,
            &error,
            (SpiceChar*) errmsg_buf);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.l = n;

   Argv[8]->value.c = error;

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV( 9, errmsg_buf);

   if (  !error  &&  ( n != 0 )  )
      {
      char   * xbegs_copy;
      char   * xends_copy;
      char   * xtypes_copy;
      char   * xclass_copy;
      char   * tabs_copy;
      char   * cols_copy;

      int      tabs_end = SPICE_EK_TSTRLN - 2;
      int      cols_end = SPICE_EK_CSTRLN - 2;
      int      i;
      int      tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = (IDL_MEMINT)n;

      /* Create the needed temporary arrays. */

      xbegs_copy  = IDL_MakeTempArray(IDL_TYP_LONG, tmp_ndims,
                                      tmp_dims, IDL_ARR_INI_NOP, &Argv[2]);

      xends_copy  = IDL_MakeTempArray(IDL_TYP_LONG, tmp_ndims,
                                      tmp_dims, IDL_ARR_INI_NOP, &Argv[3]);

      xtypes_copy = IDL_MakeTempArray(IDL_TYP_LONG, tmp_ndims,
                                      tmp_dims, IDL_ARR_INI_NOP, &Argv[4]);

      xclass_copy = IDL_MakeTempArray(IDL_TYP_LONG, tmp_ndims,
                                      tmp_dims, IDL_ARR_INI_NOP, &Argv[5]);

      tabs_copy   = IDL_MakeTempArray(IDL_TYP_STRING, tmp_ndims,
                                      tmp_dims, IDL_ARR_INI_NOP, &Argv[6]);

      cols_copy   = IDL_MakeTempArray(IDL_TYP_STRING, tmp_ndims,
                                      tmp_dims, IDL_ARR_INI_NOP, &Argv[7]);

      /* Convert the enums to SpiceInts with an explicit cast, J.I.C. */

      for (i=0; i < n; i++)
         {
         xtypes_copy[i] = (SpiceInt)xtypes[i];
         xclass_copy[i] = (SpiceInt)xclass[i];

         while (isspace( (int)tabs[i][tabs_end] ) )
            {
            tabs[i][tabs_end--] = '\0';
            }
         IDL_StrStore( &((IDL_STRING*)tabs_copy)[i], tabs[i]);

         while (isspace( (int)cols[i][cols_end] ) )
            {
            cols[i][cols_end--] = '\0';
            }
         IDL_StrStore( &((IDL_STRING*)cols_copy)[i], cols[i]);
         }


      /*
      Move the data from the variables returned from CSPICE to the
      IDL return arrays.
      */
      memmove( xbegs_copy,  xbegs,  n * sizeof(SpiceInt) );
      memmove( xends_copy,  xends,  n * sizeof(SpiceInt) );
      memmove( xtypes_copy, xtypes, n * sizeof(SpiceInt) );
      memmove( xclass_copy, xclass, n * sizeof(SpiceInt) );
      }


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekrcec_c ( SpiceInt           handle,
                                SpiceInt           segno,
                                SpiceInt           recno,
                                ConstSpiceChar   * column,
                                SpiceInt           lenout,
                                SpiceInt         * nvals,
                                void             * cvals,
                                SpiceBoolean     * isnull )
*/
PROCEDURE CSPICE_EKRCEC(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceInt             segno;
   SpiceInt             recno;
   SpiceChar          * column;
   SpiceInt             cvals_size;
   SpiceInt             cvals_len;
   SpiceInt             cvals_dim;
   SpiceChar         ** cvals;
   char              ** str_array;
   SpiceBoolean         isnull;

   IDL_STRING         * idl_ret_str;
   IDL_MEMINT           lDimensions[IDL_MAX_ARRAY_DIM];
   long                 i;


   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "segno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "recno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "column", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "size",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "length", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "cvals",  (void*)IDL_TYP_STRING,  1, { 0 },    0},
      { OWRIT, "isnull", (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 8)
      {
      USAGE("CSPICE_EKRCEC, handle, segno, recno, `column`, nelts, "
            "cvals_len, CVALS[], ISNULL");
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV(0);
   segno      = S_INT_ARGV(1);
   recno      = S_INT_ARGV(2);
   column     = S_STR_ARGV(3);
   cvals_size = S_INT_ARGV(4);
   cvals_len  = S_INT_ARGV(5);
   cvals_dim  = 0;

   cvals = alloc_SpiceString_C_array ( cvals_len, cvals_size );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   ekrcec_c( handle,
             segno,
             recno,
             column,
             cvals_len,
             &cvals_dim,
             *cvals,
             &isnull);

   /*
   Check for a call a SPICE call failure, clean up memory if failure detected.
   */
   CHECK_CALL_FAILURE_MEM( 1, cvals );

   /* If the call found data... */
   if ( cvals_dim > 0 )
      {

      /* Create a string array for passing to the IDL created array. */
      str_array = alloc_SpiceString_C_Copy_array ( cvals_dim, cvals_len,
                                                   cvals );

      CHECK_CALL_FAILURE_MEM( 1, cvals );

      /*
      Create the IDL array for the right size and cast
      it to an IDL_STRING pointer.
      */
      lDimensions[0] = cvals_dim;
      idl_ret_str    = (IDL_STRING *)IDL_MakeTempArray((int) IDL_TYP_STRING,
                       1, lDimensions, IDL_ARR_INI_NOP, &Argv[6]);

      /*
      Store the string in the IDL string with the string length for
      each element.
      */
      for ( i=0; i<cvals_dim; i++ )
         {
         IDL_StrStore( &(idl_ret_str[i]), (char*)str_array[i]);
         idl_ret_str[i].slen = strlen(str_array[i]);
         }

      /* Free the memory allocated to str_array. */
      free_SpiceString_C_array ( (int) cvals_dim, str_array );

      }

   Argv[7]->value.c = isnull;

   /* Free the memory allocated to cvals. */
   free_SpiceString_C_array ( 1, cvals );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekrced_c ( SpiceInt           handle,
                                SpiceInt           segno,
                                SpiceInt           recno,
                                ConstSpiceChar   * column,
                                SpiceInt         * nvals,
                                SpiceDouble      * dvals,
                                SpiceBoolean     * isnull )
*/
PROCEDURE CSPICE_EKRCED(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceInt             segno;
   SpiceInt             recno;
   SpiceChar          * column;
   SpiceInt             nelts;
   SpiceInt             dvals_dim;
   SpiceDouble        * dvals;
   SpiceBoolean         isnull;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "segno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "recno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "column", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "nelts",  (void*)IDL_TYP_LONG,   0, { 0 },    0},
      { OWRIT, "dvals",  (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OWRIT, "isnull", (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_EKRCED, handle, segno, recno, `column`, "
            "nelts, DVALS[], ISNULL");
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV(0);
   segno      = S_INT_ARGV(1);
   recno      = S_INT_ARGV(2);
   column     = S_STR_ARGV(3);
   nelts      = S_INT_ARGV(4);
   dvals_dim  = 0;

   dvals = alloc_SpiceDouble_C_array ( 1, (int) nelts );

   /*
    Test for a SPICE error signal. If found, display an error message to
    the user then return to the IDL application.
    */
   CHECK_CALL_FAILURE( SCALAR );

   ekrced_c( handle,
             segno,
             recno,
             column,
             &dvals_dim,
             dvals,
             &isnull);

   /* Check for SPICE call failure, clean up if failed. */
   if ( failed_c())
      {
      free_SpiceMemory( dvals );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   if (dvals_dim > 0)
      {
      char      *dvals_copy;
      int        tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = dvals_dim;
      dvals_copy = IDL_MakeTempArray(IDL_TYP_DOUBLE, tmp_ndims, tmp_dims,
                                     IDL_ARR_INI_NOP, &Argv[5]);

      /*
      Move the data from the variables returned from CSPICE to the
      IDL return arrays.
      */
      memmove(dvals_copy, dvals, dvals_dim * sizeof(SpiceDouble) );
      }

   Argv[6]->value.c = isnull;

   /*
   Clean up temporary variables
   */
   free_SpiceMemory( dvals );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekrcei_c ( SpiceInt           handle,
                                SpiceInt           segno,
                                SpiceInt           recno,
                                ConstSpiceChar   * column,
                                SpiceInt         * nvals,
                                SpiceInt         * ivals,
                                SpiceBoolean     * isnull )
*/
PROCEDURE CSPICE_EKRCEI(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceInt             segno;
   SpiceInt             recno;
   SpiceChar          * column;
   SpiceInt             nelts;
   SpiceInt             ivals_dim;
   SpiceInt           * ivals;
   SpiceBoolean         isnull;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "segno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "recno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "column", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "nelts",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "ivals",  (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { OWRIT, "isnull", (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_EKRCEI, handle, segno, recno, `column`, "
            "nelts, IVALS[], ISNULL");
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   segno      = S_INT_ARGV( 1 );
   recno      = S_INT_ARGV( 2 );
   column     = S_STR_ARGV( 3 );
   nelts      = S_INT_ARGV(4);
   ivals_dim  = 0;

   ivals = alloc_SpiceInt_C_array ( 1, (int) nelts );

   /*
    Test for a SPICE error signal. If found, display an error message to
    the user then return to the IDL application.
    */
   CHECK_CALL_FAILURE( SCALAR );

   ekrcei_c( handle,
             segno,
             recno,
             column,
             &ivals_dim,
             ivals,
             &isnull);

   /* Check for SPICE call failure, clean up if failed. */
   if ( failed_c())
      {
      free_SpiceMemory( ivals );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   if (ivals_dim > 0)
      {
      char    *ivals_copy;
      int      tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = ivals_dim;
      ivals_copy  = IDL_MakeTempArray(IDL_TYP_LONG, tmp_ndims, tmp_dims,
                                      IDL_ARR_INI_NOP, &Argv[5]);

      /*
      Move the data from the variables returned from CSPICE to the
      IDL return array.
      */
      memmove(ivals_copy, ivals, ivals_dim * sizeof(SpiceInt) );
      }

   Argv[6]->value.c = isnull;

   /*
   Clean up temporary variables
   */
   free_SpiceMemory( ivals );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
            void     ekssum_c ( SpiceInt  handle,
                                SpiceInt            segno,
                                SpiceEKSegSum     * segsum )
*/
PROCEDURE CSPICE_EKSSUM(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt              segno;
   SpiceInt              cnames_len;
   SpiceInt              nrows;
   SpiceInt              ncols;
   SpiceEKSegSum         segsum;

   SpiceInt              cclass    [SPICE_EK_MXCLSG];
   SpiceInt              dtype     [SPICE_EK_MXCLSG];
   SpiceInt              sizes     [SPICE_EK_MXCLSG];
   SpiceInt              stlen     [SPICE_EK_MXCLSG];
   SpiceBoolean          indexd    [SPICE_EK_MXCLSG];
   SpiceBoolean          nullok    [SPICE_EK_MXCLSG];

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "segno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "nrows",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "ncols",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "tabnam", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "cnames", (void*)IDL_TYP_STRING,  1, { 0 },    0},
      { OWRIT, "class",  (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { OWRIT, "dtype",  (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { OWRIT, "sizes",  (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { OWRIT, "stlen",  (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { OWRIT, "indexd", (void*)IDL_TYP_BYTE,    1, { 0 },    0},
      { OWRIT, "nullok", (void*)IDL_TYP_BYTE,    1, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 12)
      {
      USAGE("CSPICE_EKSSUM, handle, segno, NROWS, NCOLS, `TABNAM`, CNAMES[], "
            "CCLASS[], DTYPE[], SIZES[], STRLEN[], INDEXD[], NULLOK[]" );
      }



   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   cnames_len = SPICE_EK_CSTRLN;
   handle     = S_INT_ARGV( 0 );
   segno      = S_INT_ARGV( 1 );
   nrows      = S_INT_ARGV( 2 );
   ncols      = S_INT_ARGV( 3 );

   ekssum_c(handle,segno,&segsum);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   Argv[2]->value.l = segsum.nrows;
   Argv[3]->value.l = segsum.ncols;

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV( 4, segsum.tabnam );

   if ( segsum.ncols != 0)
      {
      char    *cnames_copy;
      int      tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];
      int      i;

      tmp_ndims   = 1;
      tmp_dims[0] = segsum.ncols;
      cnames_copy = IDL_MakeTempArray(IDL_TYP_STRING, tmp_ndims,
                                    tmp_dims, IDL_ARR_INI_NOP, &Argv[5]);

      for (i=0; i < segsum.ncols; i++)
         {
         int str_end = cnames_len - 2;
         while (isspace((int)(segsum.cnames)[i][str_end]))
            {
             segsum.cnames[i][str_end--] = '\0';
             }
         IDL_StrStore( &((IDL_STRING*)cnames_copy)[i], segsum.cnames[i]);
         }
      }

   if ( segsum.ncols != 0)
      {
      char *cclass_copy;
      char *dtype_copy;
      char *sizes_copy;
      char *stlen_copy;
      char *indexd_copy;
      char *nullok_copy;

      int      tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];
      int      i;

      tmp_ndims   = 1;
      tmp_dims[0] = segsum.ncols;

      cclass_copy = IDL_MakeTempArray(IDL_TYP_LONG, tmp_ndims, tmp_dims,
                                      IDL_ARR_INI_NOP, &Argv[6]);

      dtype_copy  = IDL_MakeTempArray(IDL_TYP_LONG, tmp_ndims, tmp_dims,
                                      IDL_ARR_INI_NOP, &Argv[7]);

      sizes_copy  = IDL_MakeTempArray(IDL_TYP_LONG, tmp_ndims, tmp_dims,
                                      IDL_ARR_INI_NOP, &Argv[8]);

      stlen_copy  = IDL_MakeTempArray(IDL_TYP_LONG, tmp_ndims, tmp_dims,
                                      IDL_ARR_INI_NOP, &Argv[9]);

      indexd_copy = IDL_MakeTempArray(IDL_TYP_BYTE, tmp_ndims, tmp_dims,
                                      IDL_ARR_INI_NOP, &Argv[10]);

      nullok_copy = IDL_MakeTempArray(IDL_TYP_BYTE, tmp_ndims, tmp_dims,
                                      IDL_ARR_INI_NOP, &Argv[11]);

      for (i=0; i < segsum.ncols; i++)
         {
         cclass[i]      = segsum.cdescrs[i].cclass;
         dtype[i]       = segsum.cdescrs[i].dtype;
         sizes[i]       = segsum.cdescrs[i].size;
         stlen[i]       = segsum.cdescrs[i].strlen;
         indexd[i]      = segsum.cdescrs[i].indexd;
         indexd_copy[i] = (char) indexd[i];
         nullok[i]      = segsum.cdescrs[i].nullok;
         nullok_copy[i] = (char) nullok[i];
         }

      /*
      Move the data from the variables returned from CSPICE to the
      IDL return arrays.
      */
      memmove( cclass_copy, cclass, segsum.ncols * sizeof(SpiceInt));
      memmove( dtype_copy,  dtype,  segsum.ncols * sizeof(SpiceInt));
      memmove( sizes_copy,  sizes,  segsum.ncols * sizeof(SpiceInt));
      memmove( stlen_copy,  stlen,  segsum.ncols * sizeof(SpiceInt));
      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ektnam_c ( SpiceInt            n,
                                SpiceInt            lenout,
                                SpiceChar         * table  )
*/
PROCEDURE CSPICE_EKTNAM(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              n;
   SpiceChar             table_buf[SPICE_EK_TSTRLN+1];

   struct argcheck argcheck[] =
      {
      { OREAD, "n",     (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "table", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_EKTNAM, n, `TABLE`");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   n            = S_INT_ARGV( 0 );

   ektnam_c(n,SPICE_EK_TSTRLN,table_buf);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV( 1, table_buf);

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekucec_c ( SpiceInt              handle,
                                SpiceInt              segno,
                                SpiceInt              recno,
                                ConstSpiceChar      * column,
                                SpiceInt              nvals,
                                SpiceInt              vallen,
                                const void          * cvals,
                                SpiceBoolean          isnull )
*/
PROCEDURE CSPICE_EKUCEC(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceInt             segno;
   SpiceInt             recno;
   SpiceChar          * column;
   SpiceInt             nvals;
   SpiceInt             cvals_len;
   SpiceInt             cvals_size;
   long                 i;
   SpiceChar         ** cvals;
   SpiceBoolean         isnull;

   struct argcheck    argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "segno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "recno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "column", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "nvals",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "length", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "cvals",  (void*)IDL_TYP_STRING,  1, { 0 },    0},
      { OREAD, "isnull", (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 8)
      {
      USAGE("CSPICE_EKUCEC, handle, segno, recno, `column`, nvals, "
            "cvals_len, cvals[], isnull");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV(0);
   segno      = S_INT_ARGV(1);
   recno      = S_INT_ARGV(2);
   column     = S_STR_ARGV(3);
   nvals      = S_INT_ARGV(4);
   cvals_len  = S_INT_ARGV(5) + 1;
   cvals_size = A_LEN_ARGV(6);

   if ( nvals > cvals_size )
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(4, "nvals", IDL_VarName(Argv_orig[4]),
      "`nvals` exceeds array size of `cvals`");
      }

   cvals = alloc_SpiceString_C_array ( cvals_len, cvals_size );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Initialize local variables, to pass to CSPICE */
   for (i=0; i < nvals; i++)
      {
      strncpy( *cvals + i * cvals_len,
               IDL_STRING_STR(&((IDL_STRING*)(Argv[6]->value.arr->data))[i]),
               cvals_len);
      }

   isnull = S_BOOL_ARGV( 7 );

   ekucec_c(handle,segno,recno,column,nvals,cvals_len,*cvals,isnull);

   CHECK_CALL_FAILURE_MEM( 1, cvals );

   /* Free the memory allocated to cvals. */
   free_SpiceString_C_array ( 1, cvals );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekuced_c ( SpiceInt              handle,
                                SpiceInt              segno,
                                SpiceInt              recno,
                                ConstSpiceChar      * column,
                                SpiceInt              nvals,
                                ConstSpiceDouble    * dvals,
                                SpiceBoolean          isnull )
*/
PROCEDURE CSPICE_EKUCED(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceInt             segno;
   SpiceInt             recno;
   SpiceChar          * column;
   SpiceInt             nvals;
   SpiceInt             dvals_size;
   SpiceDouble        * dvals;
   SpiceBoolean         isnull;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "segno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "recno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "column", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "nvals",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "dvals",  (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OREAD, "isnull", (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_EKUCED, handle, segno, recno, `column`, nvals, "
            "dvals[], isnull");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle = S_INT_ARGV( 0 );
   segno  = S_INT_ARGV( 1 );
   recno  = S_INT_ARGV( 2 );
   column = S_STR_ARGV( 3 );
   nvals  = S_INT_ARGV( 4 );
   dvals  = A_DBL_ARGV( 5 );
   isnull = S_BOOL_ARGV( 6 );

   dvals_size = A_LEN_ARGV(5);

   if ( nvals > dvals_size )
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(5, "dvals", IDL_VarName(Argv_orig[5]),
                     "`nvals` exceeds array size of `dvals`");
      }

   ekuced_c(handle,segno,recno,column,nvals,dvals,isnull);

   CHECK_CALL_FAILURE( SCALAR );

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekucei_c ( SpiceInt              handle,
                                SpiceInt              segno,
                                SpiceInt              recno,
                                ConstSpiceChar      * column,
                                SpiceInt              nvals,
                                ConstSpiceInt       * ivals,
                                SpiceBoolean          isnull )
*/
PROCEDURE CSPICE_EKUCEI(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceInt             segno;
   SpiceInt             recno;
   SpiceChar          * column;
   SpiceInt             nvals;
   SpiceInt             ivals_size;
   SpiceInt           * ivals;
   SpiceBoolean         isnull;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "segno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "recno",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "column", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "nvals",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "ivals",  (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { OREAD, "isnull", (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_EKUCEI, handle, segno, recno, `column`, nvals, "
            "ivals[], isnull");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   segno      = S_INT_ARGV( 1 );
   recno      = S_INT_ARGV( 2 );
   column     = S_STR_ARGV( 3 );
   nvals      = S_INT_ARGV( 4 );
   ivals      = A_INT_ARGV( 5 );
   isnull     = S_BOOL_ARGV( 6 );
   ivals_size = A_LEN_ARGV(5);

   if ( nvals > ivals_size )
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(5, "ivals", IDL_VarName(Argv_orig[5]),
      "`nvals` exceeds array size of `ivals`");
      }

   ekucei_c(handle,segno,recno,column,nvals,ivals,isnull);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ekuef_c  ( SpiceInt            handle )
*/
PROCEDURE CSPICE_EKUEF(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_EKUEF, handle");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );

   ekuef_c(handle);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              el2cgv_c ( ConstSpiceEllipse * ellipse,
                                SpiceDouble         center[3],
                                SpiceDouble         smajor[3],
                                SpiceDouble         sminor[3]  )
*/
PROCEDURE CSPICE_EL2CGV(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceEllipse       * ellipse;
   SpiceDouble        * center;
   SpiceDouble        * smajor;
   SpiceDouble        * sminor;

   struct argcheck argcheck[] =
      {
      { OREAD, "ellipse", (void*)IDL_TYP_STRUCT,  0, { 0 },    0},
      { OWRIT, "center",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "smajor",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "sminor",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_EL2CGV, ellipse, CENTER[3], SMAJOR[3], SMINOR[3]");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[0].type = s_SpiceEllipse;

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   ellipse  = S_ELL_ARGV( 0 );
   center   = A_DBL_ARGV( 1 );
   smajor   = A_DBL_ARGV( 2 );
   sminor   = A_DBL_ARGV( 3 );

   el2cgv_c(ellipse,center,smajor,sminor);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              eqncpv_c ( SpiceDouble          et,
                                SpiceDouble          epoch,
                                SpiceDouble          eqel[9],
                                SpiceDouble          rapol,
                                SpiceDouble          decpol,
                                SpiceDouble          state[6] );
*/
PROCEDURE CSPICE_EQNCPV(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          et;
   SpiceDouble          epoch;
   SpiceDouble        * eqel;
   SpiceDouble          rapol;
   SpiceDouble          decpol;
   SpiceDouble        * state;

   struct argcheck argcheck[] =
      {
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "epoch",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "eqel",   (void*)IDL_TYP_DOUBLE,  1, { 9 },    0},
      { OREAD, "rapol",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "decpol", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "state",  (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_EQNCPV, et, epoch, eqel[9], rapol, decpol, STATE[6]");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   state = A_DBL_ARGV( 2 );

   et     = S_DBL_ARGV( 0 );
   epoch  = S_DBL_ARGV( 1 );
   eqel   = A_DBL_ARGV( 2 );
   rapol  = S_DBL_ARGV( 3 );
   decpol = S_DBL_ARGV( 4 );
   state  = A_DBL_ARGV( 5 );

   eqncpv_c ( et, epoch, eqel, rapol, decpol, state );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceBoolean      eqstr_c  ( ConstSpiceChar    * a,
                                ConstSpiceChar    * b  )
*/
FUNCTION CSPICE_EQSTR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceBoolean         retval_c;
   SpiceChar          * a;
   SpiceChar          * b;

   struct argcheck argcheck[] =
      {
      { OREAD, "a", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "b", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("boolean = CSPICE_EQSTR( `a`, `b` )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   a  = S_STR_ARGV( 0 );
   b  = S_STR_ARGV( 1 );

   retval_c = eqstr_c(a,b);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_BYTE;
   retval_idl->value.c  = (RETURN_BOOL) retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              etcal_c  ( SpiceDouble         et,
                                SpiceInt            lenout,
                                SpiceChar         * string  )
*/
PROCEDURE CSPICE_ETCAL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble           et;
   SpiceChar             string_buf[RET_ARRAY_LEN+1];

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 }, 1},
      { OWRIT, "string", (void*)IDL_TYP_STRING,  0, { 0 }, 1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_ETCAL, _et_, _`STRING`_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */


   /* Called with vectorized' input arguments? */
   if (extra->ndims == 0)
      {
      /* Scalar input. */
      et            = S_DBL_ARGV( 0 );

      etcal_c ( et, RET_ARRAY_LEN, string_buf);

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      /*
      Note, this is a copy operation.
      */
      S_STR_RET_ARGV( 1, string_buf);
      }
   else
      {
      /* Vector input. */
      IDL_STRING * string_sptr = (IDL_STRING*)Argv[1]->value.arr->data;

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         et = ((SpiceDouble*)(Argv[0]->value.arr->data))[i];

         etcal_c ( et, RET_ARRAY_LEN, string_buf);

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);

         IDL_StrStore(&string_sptr[i], string_buf);
         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*

   void              et2lst_c ( SpiceDouble         et,
                                SpiceInt            body,
                                SpiceDouble         lon,
                                ConstSpiceChar    * type,
                                SpiceInt            timlen,
                                SpiceInt            ampmlen,
                                SpiceInt          * hr,
                                SpiceInt          * mn,
                                SpiceInt          * sc,
                                SpiceChar         * time,
                                SpiceChar         * ampm    )

*/
PROCEDURE CSPICE_ET2LST( int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          et;
   SpiceInt             body;
   SpiceDouble          lon;
   SpiceChar          * type;
   SpiceChar            time[RET_ARRAY_LEN+1];
   SpiceChar            ampm[RET_ARRAY_LEN+1];

   long                 i;

   struct argcheck argcheck[] =
      {
      { OREAD, "et",      (void*)IDL_TYP_DOUBLE, 0, { 0 }, 1 },
      { OREAD, "body",    (void*)IDL_TYP_LONG,   0, { 0 }, 0 },
      { OREAD, "lon",     (void*)IDL_TYP_DOUBLE, 0, { 0 }, 0 },
      { OREAD, "type",    (void*)IDL_TYP_STRING, 0, { 0 }, 0 },
      { OWRIT, "hr",      (void*)IDL_TYP_LONG,   0, { 0 }, 1 },
      { OWRIT, "mn",      (void*)IDL_TYP_LONG,   0, { 0 }, 1 },
      { OWRIT, "sc",      (void*)IDL_TYP_LONG,   0, { 0 }, 1 },
      { OWRIT, "time",    (void*)IDL_TYP_STRING, 0, { 0 }, 1 },
      { OWRIT, "ampm",    (void*)IDL_TYP_STRING, 0, { 0 }, 1 }
      };


   /*
   Check the input contains the correct number of arguments.
   */
   if ( Argc != 9 )
      {
      USAGE("CSPICE_ET2LST, _et_, body, lon, `type`, "
             "_HR_, _MN_, _SC_, _`TIME`_, _`AMPM`_" );
      }

   /*
   Perform input argument type checks, allocate any needed memory for
   output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /*
   Initialize the local variables to pass to CSPICE.
   */
   body    = S_INT_ARGV( 1 );
   lon     = S_DBL_ARGV( 2 );
   type    = S_STR_ARGV( 3 );

   /* Called with vectorized' input arguments? */
   if (extra->ndims == 0)
      {
      /* Scalar input. */

      SpiceInt             hr;
      SpiceInt             mn;
      SpiceInt             sc;

      et = S_DBL_ARGV( 0 );

      et2lst_c ( et,
                 body,
                 lon,
                 type,
                 RET_ARRAY_LEN,
                 RET_ARRAY_LEN,
                 &hr,
                 &mn,
                 &sc,
                 time,
                 ampm);

      /*
      Test for a SPICE error signal. If found, display an error message
      to the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      /*
      Transfer the outputs to the IDL argument list.
      */
      Argv[4]->value.l = hr;
      Argv[5]->value.l = mn;
      Argv[6]->value.l = sc;

      /*
      Note, this is a copy operation.
      */
      S_STR_RET_ARGV ( 7, time );
      S_STR_RET_ARGV ( 8, ampm );

      }
   else
      {

      /* Vector input. */

      SpiceInt           * hr;
      SpiceInt           * mn;
      SpiceInt           * sc;

      IDL_STRING * time_sptr = (IDL_STRING*)Argv[7]->value.arr->data;
      IDL_STRING * ampm_sptr = (IDL_STRING*)Argv[8]->value.arr->data;

      hr = A_INT_ARGV( 4 );
      mn = A_INT_ARGV( 5 );
      sc = A_INT_ARGV( 6 );

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         et = ((SpiceDouble*)(Argv[0]->value.arr->data))[i];

         et2lst_c ( et, body, lon, type,
                 RET_ARRAY_LEN, RET_ARRAY_LEN, (hr+i), (mn+i), (sc+i),
                 time, ampm);

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);

         IDL_StrStore(&time_sptr[i], time);
         IDL_StrStore(&ampm_sptr[i], ampm);
         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              et2utc_c ( SpiceDouble         et,
                                ConstSpiceChar    * format,
                                SpiceInt            prec,
                                SpiceInt            lenout,
                                SpiceChar         * utcstr )
*/
PROCEDURE CSPICE_ET2UTC(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          et;
   SpiceChar          * format;
   SpiceInt             prec;
   SpiceChar            utcstr_buf[RET_ARRAY_LEN+1];

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "format", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "prec",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "utcstr", (void*)IDL_TYP_STRING,  0, { 0 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_ET2UTC, _et_, `format`, prec, _`UTCSTR`_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   format        = S_STR_ARGV( 1 );
   prec          = S_INT_ARGV( 2 );

   /* Called with vectorized' input arguments? */
   if (extra->ndims == 0)
      {
      /* Scalar input. */
      et = S_DBL_ARGV( 0 );

      et2utc_c ( et,format,prec,RET_ARRAY_LEN,utcstr_buf);

      /*
      Test for a SPICE error signal. If found, display an error message
      to the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      /*
      Note, this is a copy operation.
      */
      S_STR_RET_ARGV( 3, utcstr_buf );

      }
   else
      {
      /* Vector input. */
      IDL_STRING * utcstr_sptr = (IDL_STRING*)Argv[3]->value.arr->data;

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         et = ((SpiceDouble*)(Argv[0]->value.arr->data))[i];

         et2utc_c ( et,format,prec,RET_ARRAY_LEN,utcstr_buf);

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);

         IDL_StrStore(&utcstr_sptr[i], utcstr_buf);
         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              eul2m_c  ( SpiceDouble         angle3,
                                SpiceDouble         angle2,
                                SpiceDouble         angle1,
                                SpiceInt            axis3,
                                SpiceInt            axis2,
                                SpiceInt            axis1,
                                SpiceDouble         r [3][3] )
*/
PROCEDURE CSPICE_EUL2M(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          angle3;
   SpiceDouble          angle2;
   SpiceDouble          angle1;
   SpiceInt             axis3;
   SpiceInt             axis2;
   SpiceInt             axis1;
   SpiceDouble        * r;

   struct argcheck argcheck[] =
      {
      { OREAD, "angle3", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "angle2", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "angle1", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "axis3",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "axis2",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "axis1",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "r",      (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_EUL2M, angle3, angle2, angle1, axis3, axis2, axis1, "
            "R[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   angle3  = S_DBL_ARGV( 0 );
   angle2  = S_DBL_ARGV( 1 );
   angle1  = S_DBL_ARGV( 2 );
   axis3   = S_INT_ARGV( 3 );
   axis2   = S_INT_ARGV( 4 );
   axis1   = S_INT_ARGV( 5 );
   r       = A_DBL_ARGV( 6 );

   eul2m_c(angle3,angle2,angle1,axis3,axis2,axis1,(SpiceDouble (*)[3])r);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              eul2xf_c ( ConstSpiceDouble    eulang[6],
                                SpiceInt            axisa,
                                SpiceInt            axisb,
                                SpiceInt            axisc,
                                SpiceDouble         xform [6][6] )
*/
PROCEDURE CSPICE_EUL2XF(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * eulang;
   SpiceInt             axisa;
   SpiceInt             axisb;
   SpiceInt             axisc;
   SpiceDouble        * xform;

   struct argcheck argcheck[] =
      {
      { OREAD, "eulang", (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      { OREAD, "axisa",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "axisb",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "axisc",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "xform",  (void*)IDL_TYP_DOUBLE,  2, { 6, 6 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 5)
      {
      USAGE("CSPICE_EUL2XF, eulang[6], axisa, axisb, axisc, XFORM[6,6]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   eulang  = A_DBL_ARGV( 0 );
   axisa   = S_INT_ARGV( 1 );
   axisb   = S_INT_ARGV( 2 );
   axisc   = S_INT_ARGV( 3 );
   xform   = A_DBL_ARGV( 4 );

   eul2xf_c(eulang,axisa,axisb,axisc,(SpiceDouble (*)[6])xform);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceBoolean      exists_c ( ConstSpiceChar    * name )
*/
FUNCTION CSPICE_EXISTS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceBoolean         retval_c;
   SpiceChar          * name;

   struct argcheck argcheck[] =
      {
      { OREAD, "name", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("boolean = CSPICE_EXISTS( `name` )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   name  = S_STR_ARGV( 0 );

   retval_c = exists_c(name);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_BYTE;
   retval_idl->value.c  = (RETURN_BOOL) retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              expool_c ( ConstSpiceChar    * name,
                                SpiceBoolean      * found )
*/
PROCEDURE CSPICE_EXPOOL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * name;
   SpiceBoolean         found;

   struct argcheck argcheck[] =
      {
      { OREAD, "name",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "found", (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_EXPOOL, `name`, FOUND");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   name   = S_STR_ARGV( 0 );

   expool_c( name, &found);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void fovray_c ( ConstSpiceChar   * inst,
                   ConstSpiceDouble   raydir [3],
                   ConstSpiceChar   * rframe,
                   ConstSpiceChar   * abcorr,
                   ConstSpiceChar   * observer,
                   SpiceDouble      * et,
                   SpiceBoolean     * visible  )
*/
PROCEDURE CSPICE_FOVRAY(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar      * instrument;
   SpiceDouble    * raydir;
   SpiceChar      * ray_frame;
   SpiceChar      * abcorr;
   SpiceChar      * observer;
   SpiceDouble      et;
   SpiceBoolean     visible;

   long             i;

   struct argcheck argcheck[] =
      {
      { OREAD, "instrument",   (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "raydir",       (void*)IDL_TYP_DOUBLE,  1, { 3 }, 0},
      { OREAD, "ray_frame",    (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "abcorr",       (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "observer",     (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "et",           (void*)IDL_TYP_DOUBLE,  0, { 0 }, 1},
      { OWRIT, "visible",      (void*)IDL_TYP_BYTE,    0, { 0 }, 1},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_FOVRAY, `instrument`, _raydir[3]_, "
            "`ray_frame`, `abcorr`, `observer`, _et_, _VISIBLE_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   instrument   = S_STR_ARGV ( 0 );
   raydir       = A_DBL_ARGV ( 1 );
   ray_frame    = S_STR_ARGV ( 2 );
   abcorr       = S_STR_ARGV ( 3 );
   observer     = S_STR_ARGV ( 4 );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
    */
   if (extra->ndims == 0)
      {

      /* Scalar input. */
      et      = S_DBL_ARGV ( 5 );
      visible = S_BOOL_ARGV( 6 );


      fovray_c( instrument,
                raydir,
                ray_frame,
                abcorr,
                observer,
                &et,
                &visible);

      Argv[6]->value.c = visible;

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );
      }
   else
      {

      char  * visible_return;
      visible_return =  (char*)  Argv[6]->value.arr->data;


      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         et = ((SpiceDouble*)(Argv[5]->value.arr->data))[i];

         fovray_c( instrument,
                   raydir,
                   ray_frame,
                   abcorr,
                   observer,
                   &et,
                   &visible );

         visible_return[i] = (UCHAR)visible;

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void fovtrg_c ( ConstSpiceChar   * inst,
                   ConstSpiceChar   * target,
                   ConstSpiceChar   * tshape,
                   ConstSpiceChar   * tframe,
                   ConstSpiceChar   * abcorr,
                   ConstSpiceChar   * obsrvr,
                   SpiceDouble      * et,
                   SpiceBoolean     * visible  )
*/
PROCEDURE CSPICE_FOVTRG(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar      * instrument;
   SpiceChar      * target;
   SpiceChar      * target_shape;
   SpiceChar      * target_frame;
   SpiceChar      * abcorr ;
   SpiceChar      * observer;
   SpiceDouble      et;
   SpiceBoolean     visible;

   long             i;

   struct argcheck argcheck[] =
      {
      { OREAD, "instrument",   (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "target",       (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "target_shape", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "target_frame", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "abcorr",       (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "observer",     (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "et",           (void*)IDL_TYP_DOUBLE,  0, { 0 }, 1},
      { OWRIT, "visible",      (void*)IDL_TYP_BYTE,    0, { 0 }, 1},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 8)
      {
      USAGE("CSPICE_FOVTRG, `instrument`, `target`, "
            "`target_shape`, `target_frame`, `abcorr`, "
            "`observer`, _et_, _VISIBLE_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   instrument   = S_STR_ARGV ( 0 );
   target       = S_STR_ARGV ( 1 );
   target_shape = S_STR_ARGV ( 2 );
   target_frame = S_STR_ARGV ( 3 );
   abcorr       = S_STR_ARGV ( 4 );
   observer     = S_STR_ARGV ( 5 );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
    */
   if (extra->ndims == 0)
      {
      /*
      SpiceBoolean  visible;  */


      /* Scalar input. */
      et      = S_DBL_ARGV ( 6 );
      visible = S_BOOL_ARGV( 7 );

      fovtrg_c( instrument,
                target,
                target_shape,
                target_frame,
                abcorr,
                observer,
                &et,
                &visible);

      Argv[7]->value.c = visible;

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );
      }
   else
      {

      char  * visible_return;
      visible_return =  (char*)  Argv[7]->value.arr->data;


      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         et = ((SpiceDouble*)(Argv[6]->value.arr->data))[i];

         fovtrg_c( instrument,
                   target,
                   target_shape,
                   target_frame,
                   abcorr,
                   observer,
                   &et,
                   &visible );

         visible_return[i] = (UCHAR)visible;

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              frame_c  ( SpiceDouble         x[3],
                                SpiceDouble         y[3],
                                SpiceDouble         z[3] )
*/
PROCEDURE CSPICE_FRAME(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * x;
   SpiceDouble        * y;
   SpiceDouble        * z;

   struct argcheck argcheck[] =
      {
      { RDWRT, "x", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { RDWRT, "y", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { RDWRT, "z", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_FRAME, (X[3]), (Y[3]), (Z[3])");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   x  = A_DBL_ARGV( 0 );
   y  = A_DBL_ARGV( 1 );
   z  = A_DBL_ARGV( 2 );

   if ( A_LEN_ARGV(0) != 3)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(0, "X", IDL_VarName(Argv_orig[0]),
      "Vector `X` must have order 3.");
      }
   if ( A_LEN_ARGV(1) != 3)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(1, "Y", IDL_VarName(Argv_orig[1]),
      "Vector `Y` must have order 3.");
      }
   if ( A_LEN_ARGV(2) != 3)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(2, "Z", IDL_VarName(Argv_orig[2]),
      "Vector `Z` must have order 3.");
      }

   frame_c(x,y,z);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              frinfo_c ( SpiceInt            frcode,
                                SpiceInt          * cent,
                                SpiceInt          * clss,
                                SpiceInt          * clssid,
                                SpiceBoolean      * found )
*/
PROCEDURE CSPICE_FRINFO(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             frcode;
   SpiceInt             cent;
   SpiceInt             clss;
   SpiceInt             clssid;
   SpiceBoolean         found;

   struct argcheck argcheck[] =
      {
      { OREAD, "frcode", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "cent",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "clss",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "clssid", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 5)
      {
      USAGE("CSPICE_FRINFO, frcode, CENT, CLSS, CLSSID, FOUND");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   frcode = S_INT_ARGV( 0 );

   frinfo_c( frcode,
             &cent,
             &clss,
             &clssid,
             &found);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.l = cent;
   Argv[2]->value.l = clss;
   Argv[3]->value.l = clssid;
   Argv[4]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              frmnam_c ( SpiceInt            frcode,
                                SpiceInt            lenout,
                                SpiceChar         * frname  )
*/
PROCEDURE CSPICE_FRMNAM(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             frcode;
   SpiceChar            frname_buf[RET_ARRAY_LEN+1];

   struct argcheck argcheck[] =
      {
      { OREAD, "frcode", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "frname", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_FRMNAM, frcode, `FRNAME`");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   frcode     = S_INT_ARGV( 0 );

   frmnam_c ( frcode, RET_ARRAY_LEN,frname_buf);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV( 1, frname_buf);

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              furnsh_c ( ConstSpiceChar    * file )
*/
PROCEDURE CSPICE_FURNSH(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * file;
   SpiceInt              i;

   struct argcheck argcheck[] =
      {
      { OREAD, "file", (void*)IDL_TYP_STRING,  0, { 0 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_FURNSH, _`file`_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */

   /* Did the user pass a vector for input? */
   if (extra->ndims == 0)
      {
      /* Scalar input. */
      file = S_STR_ARGV( 0 );

      furnsh_c( (ConstSpiceChar*) file);

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );
      }
  else
      {
      /* Vector input.*/

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {

         file = IDL_STRING_STR(&((IDL_STRING*)(Argv[0]->value.arr->data))[i]);

         furnsh_c( (ConstSpiceChar*) file);

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              gcpool_c ( ConstSpiceChar    * name,
                                SpiceInt            start,
                                SpiceInt            room,
                                SpiceInt            lenout,
                                SpiceInt          * n,
                                void              * cvals,
                                SpiceBoolean      * found )
*/
PROCEDURE CSPICE_GCPOOL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * name;
   SpiceInt              start;
   SpiceInt              cvals_size;
   SpiceInt              cvals_len;
   SpiceInt              cvals_dim;
   SpiceBoolean          found;
   SpiceChar          ** cvals;
   char               ** str_array;

   IDL_STRING          * idl_ret_str;
   IDL_MEMINT            lDimensions[IDL_MAX_ARRAY_DIM];
   SpiceInt              i;

   struct argcheck argcheck[] =
      {
      { OREAD, "name",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "start",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "room",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "length", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "cvals",  (void*)IDL_TYP_STRING,  1, { 0 },    0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_GCPOOL, `name`, start, room, length, CVALS[], FOUND");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   name       = S_STR_ARGV( 0 );
   start      = S_INT_ARGV( 1 );
   cvals_size = S_INT_ARGV( 2 );
   cvals_len  = S_INT_ARGV( 3 );
   cvals_dim  = 0;

   cvals = alloc_SpiceString_C_array( cvals_len, cvals_size );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   gcpool_c( name,
             start,
             cvals_size,
             cvals_len,
             &cvals_dim,
             *cvals,
             &found);

   /* Check for SPICE call failure, clean up if failed. */
   CHECK_CALL_FAILURE_MEM( 1, cvals );

   /* If the call found data... */
   if ( cvals_dim > 0 )
      {

      /* Create a string array for passing to the IDL created array. */
      str_array = alloc_SpiceString_C_Copy_array ( cvals_dim, cvals_len,
                                                   cvals );

      CHECK_CALL_FAILURE_MEM( 1, cvals );

      /*
      Create the IDL array for the right size and cast
      it to an IDL_STRING pointer.
      */
      lDimensions[0] = cvals_dim;
      idl_ret_str    = (IDL_STRING *)IDL_MakeTempArray((int) IDL_TYP_STRING,
                       1, lDimensions, IDL_ARR_INI_NOP, &Argv[4]);

      /*
      Store the string in the IDL string with the string length for
      each element.
      */
      for ( i=0; i<cvals_dim; i++ )
         {
         IDL_StrStore( &(idl_ret_str[i]), (char*)str_array[i] );
         idl_ret_str[i].slen = strlen(str_array[i]);
         }


      /* Free the memory allocated to str_array. */
      free_SpiceString_C_array ( (int) cvals_dim, str_array );

      }

   Argv[5]->value.c = found;

   /* Free the memory allocated to cvals. */
   free_SpiceString_C_array ( 1, cvals );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              gdpool_c ( ConstSpiceChar    * name,
                                SpiceInt            start,
                                SpiceInt            room,
                                SpiceInt          * n,
                                SpiceDouble       * values,
                                SpiceBoolean      * found )
*/
PROCEDURE CSPICE_GDPOOL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * name;
   SpiceInt              start;
   SpiceInt              room;
   SpiceInt              values_dim;
   SpiceDouble         * values;
   SpiceBoolean          found;

   struct argcheck argcheck[] =
      {
      { OREAD, "name",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "start",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "room",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "values", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 5)
      {
      USAGE("CSPICE_GDPOOL, `name`, start, room, VALUES[], FOUND");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   name       = S_STR_ARGV( 0 );
   start      = S_INT_ARGV( 1 );
   room       = S_INT_ARGV( 2 );
   values_dim = 0;

   /*
   Allocate the necessary memory for 'values'. Check for an error signal.
   */
   values = alloc_SpiceDouble_C_array ( 1, (int) room );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   gdpool_c( name,
             start,
             room,
             &values_dim,
             values,
             &found);

   /* Check for SPICE call failure, clean up if failed. */
   if ( failed_c())
      {
      free_SpiceMemory( values );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   if (values_dim != 0)
      {
      char      *values_copy;
      int        tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = values_dim;
      values_copy = IDL_MakeTempArray( IDL_TYP_DOUBLE,
                                       tmp_ndims,
                                       tmp_dims,
                                       IDL_ARR_INI_NOP,
                                       &Argv[3]);

      memmove(values_copy, values, values_dim * sizeof(SpiceDouble) );
      }

   Argv[4]->value.c = found;

   /*
   Clean up temporary variables
   */
   free_SpiceMemory( values );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              georec_c ( SpiceDouble         lon,
                                SpiceDouble         lat,
                                SpiceDouble         alt,
                                SpiceDouble         re,
                                SpiceDouble         f,
                                SpiceDouble         rectan[3] )
*/
PROCEDURE CSPICE_GEOREC(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceDouble            lon;
   SpiceDouble            lat;
   SpiceDouble            alt;
   SpiceDouble            re;
   SpiceDouble            f;
   SpiceDouble          * rectan;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "lon",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "lat",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "alt",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "re",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "f",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "rectan", (void*)IDL_TYP_DOUBLE,  1, { 3 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_GEOREC, _lon_, _lat_, _alt_, re, f, _RECTAN[3]_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   re      = S_DBL_ARGV( 3 );
   f       = S_DBL_ARGV( 4 );
   rectan  = A_DBL_ARGV( 5 );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
   */
   if (extra->ndims == 0)
      {
      /* Scalar input. */
      lon = S_DBL_ARGV( 0 );
      lat = S_DBL_ARGV( 1 );
      alt = S_DBL_ARGV( 2 );

      georec_c(lon,lat,alt,re,f,rectan);

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      }
   else
      {
      /* Vector input. */

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         lon = ((SpiceDouble*)(Argv[0]->value.arr->data))[i];
         lat = ((SpiceDouble*)(Argv[1]->value.arr->data))[i];
         alt = ((SpiceDouble*)(Argv[2]->value.arr->data))[i];

         georec_c(lon,lat,alt,re,f,(rectan+i*3) );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              getelm_c ( SpiceInt            frstyr,
                                SpiceInt            lineln,
                                const void        * lines,
                                SpiceDouble       * epoch,
                                SpiceDouble       * elems   );
*/
PROCEDURE CSPICE_GETELM(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   #define  LINELN   70

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             frstyr;
   SpiceChar            lines [2][LINELN];
   SpiceDouble          epoch;
   SpiceDouble        * elems;

   long                 i;
   struct argcheck argcheck[] =
      {
      { OREAD, "frstyr", (void*)IDL_TYP_LONG,   0, { 0 }, 0},
      { OREAD, "lines",  (void*)IDL_TYP_STRING, 1, { 0 }, 0},
      { OWRIT, "epoch",  (void*)IDL_TYP_DOUBLE, 0, { 0 }, 0},
      { OWRIT, "elems",  (void*)IDL_TYP_DOUBLE, 1, { 10}, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_GETELM, frstyr, lines, EPOCH, ELEMS[10]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );


   /* Initialize local variables, to pass to CSPICE */
   frstyr  = S_INT_ARGV( 0 );

   /* Initialize local variables, to pass to CSPICE */
   for (i=0; i < 2; i++)
      {
      strncpy( lines[i],
               IDL_STRING_STR(&((IDL_STRING*)(Argv[1]->value.arr->data))[i]),
               LINELN);
      lines[i][LINELN-1] = '\0';
      }

   elems   = A_DBL_ARGV( 3 );

   getelm_c ( frstyr, LINELN, lines, &epoch, elems );
   CHECK_CALL_FAILURE( SCALAR );

   Argv[2]->value.d = epoch;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }





/*
   void              getfat_c ( ConstSpiceChar    * file,
                                SpiceInt            arclen,
                                SpiceInt            typlen,
                                SpiceChar         * arch,
                                SpiceChar         * type   )
*/
PROCEDURE CSPICE_GETFAT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * file;
   SpiceChar             arch_buf[RET_ARRAY_LEN+1];
   SpiceChar             type_buf[RET_ARRAY_LEN+1];

   struct argcheck argcheck[] =
      {
      { OREAD, "file", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "arch", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "type", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_GETFAT, `file`, `ARCH`, `TYPE`");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   file        = S_STR_ARGV( 0 );

   getfat_c ( file, RET_ARRAY_LEN, RET_ARRAY_LEN, arch_buf, type_buf);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV( 1, arch_buf);
   S_STR_RET_ARGV( 2, type_buf);

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              getfov_c ( SpiceInt            instid,
                                SpiceInt            room,
                                SpiceInt            shapelen,
                                SpiceInt            framelen,
                                SpiceChar         * shape,
                                SpiceChar         * frame,
                                SpiceDouble         bsight [3],
                                SpiceInt          * n,
                                SpiceDouble         bounds [][3] )
*/
PROCEDURE CSPICE_GETFOV(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              instid;
   SpiceInt              room;
   SpiceChar             shape_buf[RET_ARRAY_LEN+1];
   SpiceChar             frame_buf[RET_ARRAY_LEN+1];
   SpiceDouble         * bsight;
   SpiceInt              bounds_dim;
   SpiceDouble         * bounds;

   struct argcheck argcheck[] =
      {
      { OREAD, "instid", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "room",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "shape",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "frame",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "bsight", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "bounds", (void*)IDL_TYP_DOUBLE,  2, { 3, 0 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_GETFOV, instid, room, `SHAPE`, `FRAME`, "
            "BSIGHT[3], BOUNDS[3,N]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   instid     = S_INT_ARGV( 0 );
   room       = S_INT_ARGV( 1 );
   bsight     = A_DBL_ARGV( 4 );

   bounds_dim = 0;

   bounds = alloc_SpiceDouble_C_array ( (int)room, 3 );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   getfov_c( instid,
             room,
             RET_ARRAY_LEN,
             RET_ARRAY_LEN,
             shape_buf,
             frame_buf,
             bsight,
             &bounds_dim,
             (SpiceDouble (*)[3])bounds);

   /* Check for SPICE call failure, clean up if failed. */
   if ( failed_c())
      {
      free_SpiceMemory( bounds );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   /* Store the strings to Argv for return to IDL. */

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV ( 2, shape_buf );
   S_STR_RET_ARGV ( 3, frame_buf );

   if (bounds_dim != 0)
      {
      char    *bounds_copy;
      int      tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 2;
      tmp_dims[0] = 3;
      tmp_dims[1] = bounds_dim;
      bounds_copy = IDL_MakeTempArray(IDL_TYP_DOUBLE, tmp_ndims, tmp_dims,
                                      IDL_ARR_INI_NOP, &Argv[5]);
      memmove(bounds_copy, bounds, 3 * bounds_dim * sizeof(SpiceDouble));
      }

   /* Clean up temporary variables */
   free_SpiceMemory( bounds );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   }




/*
   void              gfdist_c ( ConstSpiceChar     * target,
                                ConstSpiceChar     * abcorr,
                                ConstSpiceChar     * obsrvr,
                                ConstSpiceChar     * relate,
                                SpiceDouble          refval,
                                SpiceDouble          adjust,
                                SpiceDouble          step,
                                SpiceInt             nintvls,
                                SpiceCell          * cnfine,
                                SpiceCell          * result     )

*/
PROCEDURE CSPICE_GFDIST(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * target;
   SpiceChar           * abcorr;
   SpiceChar           * obsrvr;
   SpiceChar            * relate;
   SpiceDouble           refval;
   SpiceDouble           adjust;
   SpiceDouble           step;
   SpiceInt              nintvls;
   SpiceCell             cnfine;
   SpiceCell             result;

   SpiceInt             * tag_offset1;
   SpiceInt             * tag_offset2;

   struct argcheck argcheck[] =
      {
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "relate", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "refval", (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "adjust", (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "step",   (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "nintvls",(void*)IDL_TYP_LONG,    0, { 0 }, 0},
      { OREAD, "cnfine", (void*)IDL_TYP_STRUCT,  0, { 0 }, 0},
      { RDWRT, "result", (void*)IDL_TYP_STRUCT,  0, { 0 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 10)
      {
      USAGE("CSPICE_GFDIST, `target`, `abcorr`, `obsrvr`, "
                           "`relate`, refval, adjust, "
                           "step, nintvls, (cnfine), (RESULT)" );
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[8].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[9].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   target  = S_STR_ARGV( 0 );
   abcorr  = S_STR_ARGV( 1 );
   obsrvr  = S_STR_ARGV( 2 );
   relate  = S_STR_ARGV( 3 );
   refval  = S_DBL_ARGV( 4 );
   adjust  = S_DBL_ARGV( 5 );
   step    = S_DBL_ARGV( 6 );
   nintvls = S_INT_ARGV( 7 );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset1 = (SpiceInt*) (Argv[8]->value.s.arr->data);
   pack_cell( &cnfine, 8, tag_offset1, Argv );

   tag_offset2 = (SpiceInt*) (Argv[9]->value.s.arr->data);
   pack_cell( &result, 9, tag_offset2, Argv );

   (void) gfdist_c ( target,
                     abcorr,
                     obsrvr,
                     relate,
                     refval,
                     adjust,
                     step,
                     nintvls,
                     &cnfine,
                     &result  );
   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM3( cnfine, result, SCALAR );

   /*
   Unpack the data from 'result' to 'Argv'.
   */
   unpack_cell( 9, tag_offset2, &result, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              gfilum_c ( ConstSpiceChar     * method,
                                ConstSpiceChar     * angtyp,
                                ConstSpiceChar     * target,
                                ConstSpiceChar     * illum,
                                ConstSpiceChar     * fixref,
                                ConstSpiceChar     * abcorr,
                                ConstSpiceChar     * obsrvr,
                                ConstSpiceDouble     spoint [3],
                                ConstSpiceChar     * relate,
                                SpiceDouble          refval,
                                SpiceDouble          adjust,
                                SpiceDouble          step,
                                SpiceInt             nintvls,
                                SpiceCell          * cnfine,
                                SpiceCell          * result     )
*/
PROCEDURE CSPICE_GFILUM(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * method;
   SpiceChar           * angtyp;
   SpiceChar           * target;
   SpiceChar           * illum;
   SpiceChar           * fixref;
   SpiceChar           * abcorr;
   SpiceChar           * obsrvr;
   SpiceDouble         * spoint;
   SpiceChar           * relate;
   SpiceDouble           refval;
   SpiceDouble           adjust;
   SpiceDouble           step;
   SpiceInt              nintvls;
   SpiceCell             cnfine;
   SpiceCell             result;

   SpiceInt             * tag_offset1;
   SpiceInt             * tag_offset2;

   struct argcheck argcheck[] =
      {
      { OREAD, "method", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "angtyp", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "illum",  (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "fixref", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "spoint", (void*)IDL_TYP_DOUBLE,  1, { 3 }, 0},
      { OREAD, "relate", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "refval", (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "adjust", (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "step",   (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "nintvls",(void*)IDL_TYP_LONG,    0, { 0 }, 0},
      { OREAD, "cnfine", (void*)IDL_TYP_STRUCT,  0, { 0 }, 0},
      { RDWRT, "result", (void*)IDL_TYP_STRUCT,  0, { 0 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 15)
      {
      USAGE("CSPICE_GFILUM, `method`, `angtyp`, `target`, `illum`, "
                            "`fixref`, `abcorr`, `obsrvr`, spoint, "
                            "`relate`, refval, adjust, "
                            "step, nintvls, (cnfine), (RESULT)" );
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[13].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[14].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   method = S_STR_ARGV( 0 );
   angtyp = S_STR_ARGV( 1 );
   target = S_STR_ARGV( 2 );
   illum  = S_STR_ARGV( 3 );
   fixref = S_STR_ARGV( 4 );
   abcorr = S_STR_ARGV( 5 );
   obsrvr = S_STR_ARGV( 6 );
   spoint = A_DBL_ARGV( 7 );
   relate = S_STR_ARGV( 8 );
   refval = S_DBL_ARGV( 9 );
   adjust = S_DBL_ARGV( 10 );
   step   = S_DBL_ARGV( 11 );
   nintvls= S_INT_ARGV( 12 );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset1 = (SpiceInt*) (Argv[13]->value.s.arr->data);
   pack_cell( &cnfine, 13, tag_offset1, Argv );

   tag_offset2 = (SpiceInt*) (Argv[14]->value.s.arr->data);
   pack_cell( &result, 14, tag_offset2, Argv );

   (void) gfilum_c ( method,
                     angtyp,
                     target,
                     illum,
                     fixref,
                     abcorr,
                     obsrvr,
                     spoint,
                     relate,
                     refval,
                     adjust,
                     step,
                     nintvls,
                     &cnfine,
                     &result );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM3( cnfine, result, SCALAR );

   /*
   Unpack the data from 'result' to 'Argv'.
   */
   unpack_cell( 14, tag_offset2, &result, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              gfoclt_c ( ConstSpiceChar   * occtyp,
                                ConstSpiceChar   * front,
                                ConstSpiceChar   * fshape,
                                ConstSpiceChar   * fframe,
                                ConstSpiceChar   * back,
                                ConstSpiceChar   * bshape,
                                ConstSpiceChar   * bframe,
                                ConstSpiceChar   * abcorr,
                                ConstSpiceChar   * obsrvr,
                                SpiceDouble        step,
                                SpiceCell        * cnfine,
                                SpiceCell        * result )

*/
PROCEDURE CSPICE_GFOCLT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * occtyp;
   SpiceChar           * front;
   SpiceChar           * fshape;
   SpiceChar           * fframe;
   SpiceChar           * back;
   SpiceChar           * bshape;
   SpiceChar           * bframe;
   SpiceChar           * abcorr;
   SpiceChar           * obsrvr;
   SpiceDouble           step;
   SpiceCell             cnfine;
   SpiceCell             result;

   SpiceInt             * tag_offset1;
   SpiceInt             * tag_offset2;

   struct argcheck argcheck[] =
      {
      { OREAD, "occtyp", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "front",  (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "fshape", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "fframe", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "back",   (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "bshape", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "bframe", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "step",   (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "cnfine", (void*)IDL_TYP_STRUCT,  0, { 0 }, 0},
      { RDWRT, "result", (void*)IDL_TYP_STRUCT,  0, { 0 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 12)
      {
      USAGE("CSPICE_GFOCLT, `occtyp`, `front`, `fshape`, `fframe`, `back`, "
                           "`bshape`, `bframe`, `abcorr`, `obsrvr`, step, "
                           "(cnfine), (RESULT)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[10].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[11].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   occtyp = S_STR_ARGV( 0 );
   front  = S_STR_ARGV( 1 );
   fshape = S_STR_ARGV( 2 );
   fframe = S_STR_ARGV( 3 );
   back   = S_STR_ARGV( 4 );
   bshape = S_STR_ARGV( 5 );
   bframe = S_STR_ARGV( 6 );
   abcorr = S_STR_ARGV( 7 );
   obsrvr = S_STR_ARGV( 8 );
   step   = S_DBL_ARGV( 9 );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset1 = (SpiceInt*) (Argv[10]->value.s.arr->data);
   pack_cell( &cnfine, 10, tag_offset1, Argv );

   tag_offset2 = (SpiceInt*) (Argv[11]->value.s.arr->data);
   pack_cell( &result, 11, tag_offset2, Argv );

   (void) gfoclt_c ( occtyp,
                     front,
                     fshape,
                     fframe,
                     back,
                     bshape,
                     bframe,
                     abcorr,
                     obsrvr,
                     step,
                     &cnfine,
                     &result );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM3( cnfine, result, SCALAR );

   /*
   Unpack the data from 'result' to 'Argv'.
   */
   unpack_cell( 11, tag_offset2, &result, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }





/*
   void              gfpa_c ( ConstSpiceChar     * target,
                              ConstSpiceChar     * illum,
                              ConstSpiceChar     * abcorr,
                              ConstSpiceChar     * obsrvr,
                              ConstSpiceChar     * relate,
                              SpiceDouble          refval,
                              SpiceDouble          adjust,
                              SpiceDouble          step,
                              SpiceInt             nintvls,
                              SpiceCell          * cnfine,
                              SpiceCell          * result     )

*/
PROCEDURE CSPICE_GFPA (int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * target;
   SpiceChar           * illum;
   SpiceChar           * abcorr;
   SpiceChar           * obsrvr;
   SpiceChar            * relate;
   SpiceDouble           refval;
   SpiceDouble           adjust;
   SpiceDouble           step;
   SpiceInt              nintvls;
   SpiceCell             cnfine;
   SpiceCell             result;

   SpiceInt             * tag_offset1;
   SpiceInt             * tag_offset2;

   struct argcheck argcheck[] =
      {
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "illum",  (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "relate", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "refval", (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "adjust", (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "step",   (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "nintvls",(void*)IDL_TYP_LONG,    0, { 0 }, 0},
      { OREAD, "cnfine", (void*)IDL_TYP_STRUCT,  0, { 0 }, 0},
      { RDWRT, "result", (void*)IDL_TYP_STRUCT,  0, { 0 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 11)
      {
      USAGE("CSPICE_GFPA, `target`, `illum`, `abcorr`, `obsrvr`, "
                           "`relate`, refval, adjust, "
                           "step, nintvls, (cnfine), (RESULT)" );
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[9].type  = (void*)(IDL_MAX_TYPE + 1);
   argcheck[10].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   target  = S_STR_ARGV( 0 );
   illum   = S_STR_ARGV( 1 );
   abcorr  = S_STR_ARGV( 2 );
   obsrvr  = S_STR_ARGV( 3 );
   relate  = S_STR_ARGV( 4 );
   refval  = S_DBL_ARGV( 5 );
   adjust  = S_DBL_ARGV( 6 );
   step    = S_DBL_ARGV( 7 );
   nintvls = S_INT_ARGV( 8 );

   /*
   Pack the IDL cell structure to a cell. (I may want a less clunky
   implementation for this operation.)
   */
   tag_offset1 = (SpiceInt*) (Argv[9]->value.s.arr->data);
   pack_cell( &cnfine, 9, tag_offset1, Argv );

   tag_offset2 = (SpiceInt*) (Argv[10]->value.s.arr->data);
   pack_cell( &result, 10, tag_offset2, Argv );

   (void) gfpa_c ( target,
                   illum,
                   abcorr,
                   obsrvr,
                   relate,
                   refval,
                   adjust,
                   step,
                   nintvls,
                   &cnfine,
                   &result  );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM3( cnfine, result, SCALAR );

   /*
   Unpack the data from 'result' to 'Argv'.
   */
   unpack_cell( 10, tag_offset2, &result, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              gfposc_c ( ConstSpiceChar     * target,
                                ConstSpiceChar     * frame,
                                ConstSpiceChar     * abcorr,
                                ConstSpiceChar     * obsrvr,
                                ConstSpiceChar     * crdsys,
                                ConstSpiceChar     * coord,
                                ConstSpiceChar     * relate,
                                SpiceDouble          refval,
                                SpiceDouble          adjust,
                                SpiceDouble          step,
                                SpiceInt             nintvls,
                                SpiceCell          * cnfine,
                                SpiceCell          * result  )

*/
PROCEDURE CSPICE_GFPOSC(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * target;
   SpiceChar           * frame;
   SpiceChar           * abcorr;
   SpiceChar           * obsrvr;
   SpiceChar           * crdsys;
   SpiceChar           * coord;
   SpiceChar           * relate;
   SpiceDouble           refval;
   SpiceDouble           adjust;
   SpiceDouble           step;
   SpiceInt              nintvls;
   SpiceCell             cnfine;
   SpiceCell             result;

   SpiceInt             * tag_offset1;
   SpiceInt             * tag_offset2;

   struct argcheck argcheck[] =
      {
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "frame",  (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "crdsys", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "coord",  (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "relate", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "refval", (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "adjust", (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "step",   (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "nintvls",(void*)IDL_TYP_LONG,    0, { 0 }, 0},
      { OREAD, "cnfine", (void*)IDL_TYP_STRUCT,  0, { 0 }, 0},
      { RDWRT, "result", (void*)IDL_TYP_STRUCT,  0, { 0 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 13)
      {
      USAGE("CSPICE_GFPOSC, `target`, `frame`, `abcorr`, `obsrvr`, "
                           "`crdsys`, `coord`, `relate`, refval, adjust, "
                           "step, nintvls, (cnfine), (RESULT)" );
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[11].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[12].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   target  = S_STR_ARGV( 0 );
   frame   = S_STR_ARGV( 1 );
   abcorr  = S_STR_ARGV( 2 );
   obsrvr  = S_STR_ARGV( 3 );
   crdsys  = S_STR_ARGV( 4 );
   coord   = S_STR_ARGV( 5 );
   relate  = S_STR_ARGV( 6 );
   refval  = S_DBL_ARGV( 7 );
   adjust  = S_DBL_ARGV( 8 );
   step    = S_DBL_ARGV( 9 );
   nintvls = S_INT_ARGV( 10 );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset1 = (SpiceInt*) (Argv[11]->value.s.arr->data);
   pack_cell( &cnfine, 11, tag_offset1, Argv );

   tag_offset2 = (SpiceInt*) (Argv[12]->value.s.arr->data);
   pack_cell( &result, 12, tag_offset2, Argv );

   (void) gfposc_c ( target,
                     frame,
                     abcorr,
                     obsrvr,
                     crdsys,
                     coord,
                     relate,
                     refval,
                     adjust,
                     step,
                     nintvls,
                     &cnfine,
                     &result  );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM3( cnfine, result, SCALAR );

   /*
   Unpack the data from 'result' to 'Argv'.
   */
   unpack_cell( 12, tag_offset2, &result, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              gfrfov_c ( ConstSpiceChar    * inst,
                                ConstSpiceDouble    raydir [3],
                                ConstSpiceChar    * rframe,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceChar    * obsrvr,
                                SpiceDouble         step,
                                SpiceCell         * cnfine,
                                SpiceCell         * result     );
*/
PROCEDURE CSPICE_GFRFOV(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * inst;
   SpiceDouble         * raydir;
   SpiceChar           * rframe;
   SpiceChar           * abcorr;
   SpiceChar           * obsrvr;
   SpiceDouble           step;
   SpiceCell             cnfine;
   SpiceCell             result;

   SpiceInt             * tag_offset1;
   SpiceInt             * tag_offset2;

   struct argcheck argcheck[] =
      {
      { OREAD, "inst",   (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "raydir", (void*)IDL_TYP_DOUBLE,  1, { 3 }, 0},
      { OREAD, "rframe", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "step",   (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "cnfine", (void*)IDL_TYP_STRUCT,  0, { 0 }, 0},
      { RDWRT, "result", (void*)IDL_TYP_STRUCT,  0, { 0 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 8)
      {
      USAGE("CSPICE_GFRFOV, `inst`, raydir[3], `rframe`,  "
            "`abcorr`, `obsrvr`, step, (cnfine), (RESULT)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[6].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[7].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   inst   = S_STR_ARGV( 0 );
   raydir = A_DBL_ARGV( 1 );
   rframe = S_STR_ARGV( 2 );
   abcorr = S_STR_ARGV( 3 );
   obsrvr = S_STR_ARGV( 4 );
   step   = S_DBL_ARGV( 5 );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset1 = (SpiceInt*) (Argv[6]->value.s.arr->data);
   pack_cell( &cnfine, 6, tag_offset1, Argv );

   tag_offset2 = (SpiceInt*) (Argv[7]->value.s.arr->data);
   pack_cell( &result, 7, tag_offset2, Argv );

   (void) gfrfov_c ( inst,
                     raydir,
                     rframe,
                     abcorr,
                     obsrvr,
                     step,
                     &cnfine,
                     &result );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM3( cnfine, result, SCALAR );

   /*
   Unpack the data from 'result' to 'Argv'.
   */
   unpack_cell( 7, tag_offset2, &result, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              gfrr_c ( ConstSpiceChar     * target,
                              ConstSpiceChar     * abcorr,
                              ConstSpiceChar     * obsrvr,
                              ConstSpiceChar     * relate,
                              SpiceDouble          refval,
                              SpiceDouble          adjust,
                              SpiceDouble          step,
                              SpiceInt             nintvls,
                              SpiceCell          * cnfine,
                              SpiceCell          * result  )

*/
PROCEDURE CSPICE_GFRR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * target;
   SpiceChar           * abcorr;
   SpiceChar           * obsrvr;
   SpiceChar           * relate;
   SpiceDouble           refval;
   SpiceDouble           adjust;
   SpiceDouble           step;
   SpiceInt              nintvls;
   SpiceCell             cnfine;
   SpiceCell             result;

   SpiceInt             * tag_offset1;
   SpiceInt             * tag_offset2;

   struct argcheck argcheck[] =
      {
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "relate", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "refval", (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "adjust", (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "step",   (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "nintvls",(void*)IDL_TYP_LONG,    0, { 0 }, 0},
      { OREAD, "cnfine", (void*)IDL_TYP_STRUCT,  0, { 0 }, 0},
      { RDWRT, "result", (void*)IDL_TYP_STRUCT,  0, { 0 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 10)
      {
      USAGE("CSPICE_GFRR, `target`, `abcorr`, `obsrvr`, "
                           "`relate`, refval, adjust, "
                           "step, nintvls, (cnfine), (RESULT)" );
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[8].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[9].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   target  = S_STR_ARGV( 0 );
   abcorr  = S_STR_ARGV( 1 );
   obsrvr  = S_STR_ARGV( 2 );
   relate  = S_STR_ARGV( 3 );
   refval  = S_DBL_ARGV( 4 );
   adjust  = S_DBL_ARGV( 5 );
   step    = S_DBL_ARGV( 6 );
   nintvls = S_INT_ARGV( 7 );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset1 = (SpiceInt*) (Argv[8]->value.s.arr->data);
   pack_cell( &cnfine, 8, tag_offset1, Argv );

   tag_offset2 = (SpiceInt*) (Argv[9]->value.s.arr->data);
   pack_cell( &result, 9, tag_offset2, Argv );

   (void) gfrr_c ( target,
                   abcorr,
                   obsrvr,
                   relate,
                   refval,
                   adjust,
                   step,
                   nintvls,
                   &cnfine,
                   &result );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM3( cnfine, result, SCALAR );

   /*
   Unpack the data from 'result' to 'Argv'.
   */
   unpack_cell( 9, tag_offset2, &result, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              gfsep_c (  ConstSpiceChar     * targ1,
                                ConstSpiceChar     * shape1,
                                ConstSpiceChar     * frame1,
                                ConstSpiceChar     * targ2,
                                ConstSpiceChar     * shape2,
                                ConstSpiceChar     * frame2,
                                ConstSpiceChar     * abcorr,
                                ConstSpiceChar     * obsrvr,
                                ConstSpiceChar     * relate,
                                SpiceDouble          refval,
                                SpiceDouble          adjust,
                                SpiceDouble          step,
                                SpiceInt             nintvls,
                                SpiceCell          * cnfine,
                                SpiceCell          * result  )

*/
PROCEDURE CSPICE_GFSEP(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * targ1;
   SpiceChar           * shape1;
   SpiceChar           * frame1;
   SpiceChar           * targ2;
   SpiceChar           * shape2;
   SpiceChar           * frame2;
   SpiceChar           * abcorr;
   SpiceChar           * obsrvr;
   SpiceChar           * relate;
   SpiceDouble           refval;
   SpiceDouble           adjust;
   SpiceDouble           step;
   SpiceInt              nintvls;
   SpiceCell             cnfine;
   SpiceCell             result;

   SpiceInt             * tag_offset1;
   SpiceInt             * tag_offset2;

   struct argcheck argcheck[] =
      {
      { OREAD, "targ1",  (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "shape1", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "frame1", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "targ2",  (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "shape2", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "frame2", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "relate", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "refval", (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "adjust", (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "step",   (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "nintvls",(void*)IDL_TYP_LONG,    0, { 0 }, 0},
      { OREAD, "cnfine", (void*)IDL_TYP_STRUCT,  0, { 0 }, 0},
      { RDWRT, "result", (void*)IDL_TYP_STRUCT,  0, { 0 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 15)
      {
      USAGE("CSPICE_GFSEP, `targ1`, `shape1`, `frame1`, `targ2`, "
                   "`shape2`, `frame2`, `abcorr`, `obsrvr`, `relate`, refval, "
                   "adjust, step, nintvls, (cnfine), (RESULT)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[13].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[14].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   targ1  = S_STR_ARGV( 0 );
   shape1 = S_STR_ARGV( 1 );
   frame1 = S_STR_ARGV( 2 );
   targ2  = S_STR_ARGV( 3 );
   shape2 = S_STR_ARGV( 4 );
   frame2 = S_STR_ARGV( 5 );
   abcorr = S_STR_ARGV( 6 );
   obsrvr = S_STR_ARGV( 7 );
   relate = S_STR_ARGV( 8 );
   refval = S_DBL_ARGV( 9 );
   adjust = S_DBL_ARGV( 10 );
   step   = S_DBL_ARGV( 11 );
   nintvls= S_INT_ARGV( 12 );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset1 = (SpiceInt*) (Argv[13]->value.s.arr->data);
   pack_cell( &cnfine, 13, tag_offset1, Argv );

   tag_offset2 = (SpiceInt*) (Argv[14]->value.s.arr->data);
   pack_cell( &result, 14, tag_offset2, Argv );

   (void) gfsep_c (  targ1,
                     shape1,
                     frame1,
                     targ2,
                     shape2,
                     frame2,
                     abcorr,
                     obsrvr,
                     relate,
                     refval,
                     adjust,
                     step,
                     nintvls,
                     &cnfine,
                     &result );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM3( cnfine, result, SCALAR );

   /*
   Unpack the data from 'result' to 'Argv'.
   */
   unpack_cell( 14, tag_offset2, &result, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              gfsntc_c ( ConstSpiceChar     * target,
                                ConstSpiceChar     * fixref,
                                ConstSpiceChar     * method,
                                ConstSpiceChar     * abcorr,
                                ConstSpiceChar     * obsrvr,
                                ConstSpiceChar     * dref,
                                ConstSpiceDouble     dvec   [3],
                                ConstSpiceChar     * crdsys,
                                ConstSpiceChar     * coord,
                                ConstSpiceChar     * relate,
                                SpiceDouble          refval,
                                SpiceDouble          adjust,
                                SpiceDouble          step,
                                SpiceInt             nintvls,
                                SpiceCell          * cnfine,
                                SpiceCell          * result  );
*/
PROCEDURE CSPICE_GFSNTC(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar            * target;
   SpiceChar           * fixref;
   SpiceChar           * method;
   SpiceChar           * abcorr;
   SpiceChar           * obsrvr;
   SpiceChar           * dref;
   SpiceDouble         * dvec;
   SpiceChar           * crdsys;
   SpiceChar           * coord;
   SpiceChar            * relate;
   SpiceDouble           refval;
   SpiceDouble           adjust;
   SpiceDouble           step;
   SpiceInt              nintvls;
   SpiceCell             cnfine;
   SpiceCell             result;

   SpiceInt             * tag_offset1;
   SpiceInt             * tag_offset2;

   struct argcheck argcheck[] =
      {
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "fixref", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "method", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "dref",   (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "dvec",   (void*)IDL_TYP_DOUBLE,  1, { 3 }, 0},
      { OREAD, "crdsys", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "coord",  (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "relate", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "refval", (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "adjust", (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "step",   (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "nintvls",(void*)IDL_TYP_LONG,    0, { 0 }, 0},
      { OREAD, "cnfine", (void*)IDL_TYP_STRUCT,  0, { 0 }, 0},
      { RDWRT, "result", (void*)IDL_TYP_STRUCT,  0, { 0 }, 0},
      };




   /* Check the input contains the correct number of arguments. */
   if (Argc != 16)
      {
      USAGE("CSPICE_GFSNTC, `target`, `fixref`, `method`, `abcorr`, "
                    "`obsrvr`, `dref`, dvec[3], `crdsys`, `coord`, `relate`, "
                     " refval, adjust, step, nintvls, (cnfine), (RESULT)" );
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[14].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[15].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   target  = S_STR_ARGV( 0 );
   fixref  = S_STR_ARGV( 1 );
   method  = S_STR_ARGV( 2 );
   abcorr  = S_STR_ARGV( 3 );
   obsrvr  = S_STR_ARGV( 4 );
   dref    = S_STR_ARGV( 5 );
   dvec    = A_DBL_ARGV( 6 );
   crdsys  = S_STR_ARGV( 7 );
   coord   = S_STR_ARGV( 8 );
   relate  = S_STR_ARGV( 9 );
   refval  = S_DBL_ARGV( 10 );
   adjust  = S_DBL_ARGV( 11 );
   step    = S_DBL_ARGV( 12 );
   nintvls = S_INT_ARGV( 13 );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset1 = (SpiceInt*) (Argv[14]->value.s.arr->data);
   pack_cell( &cnfine, 14, tag_offset1, Argv );

   tag_offset2 = (SpiceInt*) (Argv[15]->value.s.arr->data);
   pack_cell( &result, 15, tag_offset2, Argv );

   (void) gfsntc_c ( target,
                     fixref,
                     method,
                     abcorr,
                     obsrvr,
                     dref,
                     dvec,
                     crdsys,
                     coord,
                     relate,
                     refval,
                     adjust,
                     step,
                     nintvls,
                     &cnfine,
                     &result  );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM3( cnfine, result, SCALAR );

   /*
   Unpack the data from 'result' to 'Argv'.
   */
   unpack_cell( 15, tag_offset2, &result, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              gfstol_c ( SpiceDouble         value )
*/
PROCEDURE CSPICE_GFSTOL( int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          year;

   struct argcheck argcheck[] =
      {
      { OREAD, "value", (void*)IDL_TYP_DOUBLE, 0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_GFSTOL, value");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   year  = S_DBL_ARGV( 0 );

   gfstol_c(year);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void gfsubc_c ( ConstSpiceChar     * target,
                   ConstSpiceChar     * fixref,
                   ConstSpiceChar     * method,
                   ConstSpiceChar     * abcorr,
                   ConstSpiceChar     * obsrvr,
                   ConstSpiceChar     * crdsys,
                   ConstSpiceChar     * coord,
                   ConstSpiceChar     * relate,
                   SpiceDouble          refval,
                   SpiceDouble          adjust,
                   SpiceDouble          step,
                   SpiceInt             nintvls,
                   SpiceCell          * cnfine,
                   SpiceCell          * result  )

*/
PROCEDURE CSPICE_GFSUBC(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar            * target;
   SpiceChar           * fixref;
   SpiceChar           * method;
   SpiceChar           * abcorr;
   SpiceChar           * obsrvr;
   SpiceChar           * crdsys;
   SpiceChar           * coord;
   SpiceChar           * relate;
   SpiceDouble           refval;
   SpiceDouble           adjust;
   SpiceDouble           step;
   SpiceInt              nintvls;
   SpiceCell             cnfine;
   SpiceCell             result;

   SpiceInt             * tag_offset1;
   SpiceInt             * tag_offset2;

   struct argcheck argcheck[] =
      {
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "fixref", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "method", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "crdsys", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "coord",  (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "relate", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "refval", (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "adjust", (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "step",   (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "nintvls",(void*)IDL_TYP_LONG,    0, { 0 }, 0},
      { OREAD, "cnfine", (void*)IDL_TYP_STRUCT,  0, { 0 }, 0},
      { RDWRT, "result", (void*)IDL_TYP_STRUCT,  0, { 0 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 14)
      {
      USAGE("CSPICE_GFSUBC, `target`, `fixref`, `method`, `abcorr`, "
                   "`obsrvr`, `crdsys`, `coord`, `relate`, refval, adjust, "
                   "step, nintvls, (cnfine), (RESULT)" );
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[12].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[13].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   target  = S_STR_ARGV( 0 );
   fixref  = S_STR_ARGV( 1 );
   method  = S_STR_ARGV( 2 );
   abcorr  = S_STR_ARGV( 3 );
   obsrvr  = S_STR_ARGV( 4 );
   crdsys  = S_STR_ARGV( 5 );
   coord   = S_STR_ARGV( 6 );
   relate  = S_STR_ARGV( 7 );
   refval  = S_DBL_ARGV( 8 );
   adjust  = S_DBL_ARGV( 9 );
   step    = S_DBL_ARGV( 10 );
   nintvls = S_INT_ARGV( 11 );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset1 = (SpiceInt*) (Argv[12]->value.s.arr->data);
   pack_cell( &cnfine, 12, tag_offset1, Argv );

   tag_offset2 = (SpiceInt*) (Argv[13]->value.s.arr->data);
   pack_cell( &result, 13, tag_offset2, Argv );

   (void) gfsubc_c ( target,
                     fixref,
                     method,
                     abcorr,
                     obsrvr,
                     crdsys,
                     coord,
                     relate,
                     refval,
                     adjust,
                     step,
                     nintvls,
                     &cnfine,
                     &result  );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM3( cnfine, result, SCALAR );

   /*
   Unpack the data from 'result' to 'Argv'.
   */
   unpack_cell( 13, tag_offset2, &result, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }






/*
   void              gftfov_c ( ConstSpiceChar     * inst,
                                ConstSpiceChar     * target,
                                ConstSpiceChar     * tshape,
                                ConstSpiceChar     * tframe,
                                ConstSpiceChar     * abcorr,
                                ConstSpiceChar     * obsrvr,
                                SpiceDouble          step,
                                SpiceCell          * cnfine,
                                SpiceCell          * result  )

*/
PROCEDURE CSPICE_GFTFOV(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * inst;
   SpiceChar           * target;
   SpiceChar           * tshape;
   SpiceChar           * tframe;
   SpiceChar           * abcorr;
   SpiceChar           * obsrvr;
   SpiceDouble           step;
   SpiceCell             cnfine;
   SpiceCell             result;

   SpiceInt             * tag_offset1;
   SpiceInt             * tag_offset2;

   struct argcheck argcheck[] =
      {
      { OREAD, "inst",   (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "tshape", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "tframe", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "step",   (void*)IDL_TYP_DOUBLE,  0, { 0 }, 0},
      { OREAD, "cnfine", (void*)IDL_TYP_STRUCT,  0, { 0 }, 0},
      { RDWRT, "result", (void*)IDL_TYP_STRUCT,  0, { 0 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 9)
      {
      USAGE("CSPICE_GFTFOV, `inst`, `target`, `tshape`, "
            "`tframe`, `abcorr`, `obsrvr`, step, (cnfine), (RESULT)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[7].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[8].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   inst   = S_STR_ARGV( 0 );
   target = S_STR_ARGV( 1 );
   tshape = S_STR_ARGV( 2 );
   tframe = S_STR_ARGV( 3 );
   abcorr = S_STR_ARGV( 4 );
   obsrvr = S_STR_ARGV( 5 );
   step   = S_DBL_ARGV( 6 );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset1 = (SpiceInt*) (Argv[7]->value.s.arr->data);
   pack_cell( &cnfine, 7, tag_offset1, Argv );

   tag_offset2 = (SpiceInt*) (Argv[8]->value.s.arr->data);
   pack_cell( &result, 8, tag_offset2, Argv );

   (void) gftfov_c ( inst,
                     target,
                     tshape,
                     tframe,
                     abcorr,
                     obsrvr,
                     step,
                     &cnfine,
                     &result );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM3( cnfine, result, SCALAR );

   /*
   Unpack the data from 'result' to 'Argv'.
   */
   unpack_cell( 8, tag_offset2, &result, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              gipool_c ( ConstSpiceChar    * name,
                                SpiceInt            start,
                                SpiceInt            room,
                                SpiceInt          * n,
                                SpiceInt          * ivals,
                                SpiceBoolean      * found )
*/
PROCEDURE CSPICE_GIPOOL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * name;
   SpiceInt              start;
   SpiceInt              room;
   SpiceInt              ivals_dim;
   SpiceInt            * ivals;
   SpiceBoolean          found;

   struct argcheck argcheck[] =
      {
      { OREAD, "name",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "start", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "room",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "ivals", (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { OWRIT, "found", (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 5)
      {
      USAGE("CSPICE_GIPOOL, `name`, start, room, IVALS[], FOUND");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   name       = S_STR_ARGV( 0 );
   start      = S_INT_ARGV( 1 );
   room       = S_INT_ARGV( 2 );
   ivals_dim  = 0;

   /*
   Allocate the necessary memory for values. Check for an error signal.
   */
   ivals = alloc_SpiceInt_C_array ( 1, (int) room );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   gipool_c( name,
             start,
             room,
             &ivals_dim,
             ivals,
             &found);

   /* Check for SPICE call failure, clean up if failed. */
   if ( failed_c())
      {
      free_SpiceMemory( ivals );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   if (ivals_dim != 0)
      {
      char    *ivals_copy;
      int      tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = ivals_dim;
      ivals_copy  = IDL_MakeTempArray(IDL_TYP_LONG,    tmp_ndims, tmp_dims,
                                      IDL_ARR_INI_NOP, &Argv[3]);
      memmove(ivals_copy, ivals, ivals_dim * sizeof(SpiceInt          ));
      }

   Argv[4]->value.c = found;

   /*
   Clean up temporary variables
   */
   free_SpiceMemory( ivals );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              gnpool_c ( ConstSpiceChar    * name,
                                SpiceInt            start,
                                SpiceInt            room,
                                SpiceInt            lenout,
                                SpiceInt          * n,
                                void              * kvars,
                                SpiceBoolean      * found  )
*/
PROCEDURE CSPICE_GNPOOL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * name;
   SpiceInt              start;
   SpiceInt              kvars_size;
   SpiceInt              kvars_len;
   SpiceInt              kvars_dim;
   SpiceBoolean          found;
   SpiceChar          ** kvars;
   char               ** str_array;

   IDL_STRING          * idl_ret_str;
   IDL_MEMINT            lDimensions[IDL_MAX_ARRAY_DIM];
   SpiceInt              i;

   struct argcheck argcheck[] =
      {
      { OREAD, "name",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "start",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "room",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "length", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "kvars",  (void*)IDL_TYP_STRING,  1, { 0 },    0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_GNPOOL, `name`, start, room, length, "
                    "KVARS[], FOUND");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   name       = S_STR_ARGV( 0 );
   start      = S_INT_ARGV( 1 );
   kvars_size = S_INT_ARGV( 2 );
   kvars_len  = S_INT_ARGV( 3 );
   kvars_dim  = 0;

   kvars = alloc_SpiceString_C_array ( kvars_len, kvars_size );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   gnpool_c( name,
             start,
             kvars_size,
             kvars_len,
             &kvars_dim,
             *kvars,
             &found);

   /* Check for SPICE call failure, clean up if failed. */
   CHECK_CALL_FAILURE_MEM(  1, kvars );

   /* If the call found data... */
   if ( kvars_dim > 0 )
      {

      /* Create a string array for passing to the IDL created array. */
      str_array = alloc_SpiceString_C_Copy_array ( kvars_dim, kvars_len,
                                                   kvars );

      CHECK_CALL_FAILURE_MEM(  1, kvars );

      /*
      Create the IDL array for the right size and cast
      it to an IDL_STRING pointer.
      */
      lDimensions[0] = kvars_dim;
      idl_ret_str    = (IDL_STRING *)IDL_MakeTempArray((int) IDL_TYP_STRING,
                       1, lDimensions, IDL_ARR_INI_NOP, &Argv[4]);

      /*
      Store the string in the IDL string with the string length for
      each element.
      */
      for ( i=0; i<kvars_dim; i++ )
         {
         IDL_StrStore( &(idl_ret_str[i]), (char*)str_array[i]);
         idl_ret_str[i].slen = strlen(str_array[i]);
         }

      /* Free the memory allocated to str_array. */
      free_SpiceString_C_array ( (int) kvars_dim, str_array );

      }

   Argv[5]->value.c = found;

   /* Free the memory allocated to kvars. */
   free_SpiceString_C_array ( 1, kvars );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceDouble       halfpi_c ( void )
*/
FUNCTION CSPICE_HALFPI(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR     retval_idl;
   SpiceDouble  retval_c;

   /* Check the input contains the correct number of arguments. */
   if (Argc != 0)
      {
      USAGE("double  = CSPICE_HALFPI()");
      }

   retval_c = halfpi_c();

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   return retval_idl;
   }




/*
   void              hx2dp_c ( ConstSpiceChar  * string,
                               SpiceInt          lenout,
                               SpiceDouble     * number,
                               SpiceBoolean    * error,
                               SpiceChar       * errmsg  )

*/
PROCEDURE CSPICE_HX2DP(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * string;
   SpiceDouble           number;
   SpiceBoolean          error;
   SpiceChar             errmsg_buf[RET_ARRAY_LEN+1];

   struct argcheck argcheck[] =
      {
      { OREAD, "string", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "number", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "error",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      { OWRIT, "errmsg", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_HX2DP, `string`, NUMBER, ERROR, `ERRMSG`");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   string     = S_STR_ARGV( 0 );

   (void) hx2dp_c ( string, RET_ARRAY_LEN, &number, &error, errmsg_buf );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.d = number;
   Argv[2]->value.c = error;

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV( 3, errmsg_buf);

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ident_c  ( SpiceDouble         matrix[3][3] )
*/
PROCEDURE CSPICE_IDENT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR          * Argv;
   struct extra_dims * extra;
   SpiceDouble       * matrix;

   struct argcheck argcheck[] =
      {
      { OWRIT, "matrix", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_IDENT, MATRIX[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   matrix     = A_DBL_ARGV( 0 );

   ident_c((SpiceDouble (*)[3])matrix);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              illum_c  ( ConstSpiceChar    * target,
                                SpiceDouble         et,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceChar    * obsrvr,
                                ConstSpiceDouble    spoint [3],
                                SpiceDouble       * phase,
                                SpiceDouble       * solar,
                                SpiceDouble       * emissn     )
*/
PROCEDURE CSPICE_ILLUM(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * target;
   SpiceDouble           et;
   SpiceChar           * abcorr;
   SpiceChar           * obsrvr;
   SpiceDouble         * spoint;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "spoint", (void*)IDL_TYP_DOUBLE,  1, { 3 },    1},
      { OWRIT, "phase",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "solar",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "emissn", (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 8)
      {
      USAGE("CSPICE_ILLUM, `target`, _et_, `abcorr`, `obsrvr`, "
                    "_spoint[3]_, _PHASE_, _SOLAR_, _EMISSN_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   target  = S_STR_ARGV( 0 );
   abcorr  = S_STR_ARGV( 2 );
   obsrvr  = S_STR_ARGV( 3 );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
   */
   if (extra->ndims == 0)
      {

      /* Scalar input. */

      SpiceDouble           phase;
      SpiceDouble           solar;
      SpiceDouble           emissn;

      et      = S_DBL_ARGV( 1 );
      spoint  = A_DBL_ARGV( 4 );

      illum_c( target,
               et,
               abcorr,
               obsrvr,
               spoint,
               &phase,
               &solar,
               &emissn);

      /*
      Test for a SPICE error signal. If found, display an error message to the
      user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      Argv[5]->value.d = phase;
      Argv[6]->value.d = solar;
      Argv[7]->value.d = emissn;

      }
   else
      {

      /* Vector input. */
      SpiceDouble         * phase;
      SpiceDouble         * solar;
      SpiceDouble         * emissn;

      spoint  = (SpiceDouble*)(Argv[4]->value.arr->data) ;
      phase   = A_DBL_ARGV(5);
      solar   = A_DBL_ARGV(6);
      emissn  = A_DBL_ARGV(7);

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         et = ((SpiceDouble*)(Argv[1]->value.arr->data))[i];

         /*
         The 'spoint' vector has length 3 input to illum_c so increment
         the pointer to the data by factors of 3.
         */
         illum_c( target,
                  et,
                  abcorr,
                  obsrvr,
                  (spoint + i*3),
                  (phase+i),
                  (solar+i),
                  (emissn+i) );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              illumf_c ( ConstSpiceChar        * method,
                                ConstSpiceChar        * target,
                                ConstSpiceChar        * ilusrc,
                                SpiceDouble             et,
                                ConstSpiceChar        * fixref,
                                ConstSpiceChar        * abcorr,
                                ConstSpiceChar        * obsrvr,
                                ConstSpiceDouble        spoint [3],
                                SpiceDouble           * trgepc,
                                SpiceDouble             srfvec [3],
                                SpiceDouble           * phase,
                                SpiceDouble           * incdnc,
                                SpiceDouble           * emissn,
                                SpiceBoolean          * visibl,
                                SpiceBoolean          * lit       )
*/
PROCEDURE CSPICE_ILLUMF(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * method;
   SpiceChar          * target;
   SpiceChar          * ilusrc;
   SpiceDouble          et;
   SpiceChar          * fixref;
   SpiceChar          * abcorr;
   SpiceChar          * obsrvr;
   SpiceDouble        * spoint;
   SpiceDouble          trgepc;
   SpiceDouble        * srfvec;
   SpiceDouble          phase;
   SpiceDouble          incdnc;
   SpiceDouble          emissn;
   SpiceBoolean         visibl;
   SpiceBoolean         lit;

   struct argcheck argcheck[] =
      {
      { OREAD, "method", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "ilusrc", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "fixref", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "spoint", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "trgepc", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "srfvec", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "phase",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "incdnc", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "emissn", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "visibl", (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      { OWRIT, "lit",    (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 15)
      {
      USAGE("CSPICE_ILLUMF, `method`, `target`, `ilusrc`, et, `fixref`, "
             "`abcorr`, `obsrvr`, spoint[3], "
             "TRGEPC, SRFVEC[3], PHASE, INCDNC, EMISSN, VISIBL, LIT");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   method     = S_STR_ARGV( 0 );
   target     = S_STR_ARGV( 1 );
   ilusrc     = S_STR_ARGV( 2 );
   et         = S_DBL_ARGV( 3 );
   fixref     = S_STR_ARGV( 4 );
   abcorr     = S_STR_ARGV( 5 );
   obsrvr     = S_STR_ARGV( 6 );
   spoint     = A_DBL_ARGV( 7 );
   srfvec     = A_DBL_ARGV( 9 );

   illumf_c( method,
             target,
             ilusrc,
             et,
             fixref,
             abcorr,
             obsrvr,
             spoint,
             &trgepc,
             srfvec,
             &phase,
             &incdnc,
             &emissn,
             &visibl,
             &lit );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[8 ]->value.d  = trgepc;
   Argv[10]->value.d  = phase;
   Argv[11]->value.d  = incdnc;
   Argv[12]->value.d  = emissn;
   Argv[13]->value.c  = visibl;
   Argv[14]->value.c  = lit;

  /* Clean up temporary variables */
  zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
  }




/*
   void              illumg_c ( ConstSpiceChar        * method,
                                ConstSpiceChar        * target,
                                ConstSpiceChar        * ilusrc,
                                SpiceDouble             et,
                                ConstSpiceChar        * fixref,
                                ConstSpiceChar        * abcorr,
                                ConstSpiceChar        * obsrvr,
                                ConstSpiceDouble        spoint [3],
                                SpiceDouble           * trgepc,
                                SpiceDouble             srfvec [3],
                                SpiceDouble           * phase,
                                SpiceDouble           * incdnc,
                                SpiceDouble           * emissn     )
*/
PROCEDURE CSPICE_ILLUMG(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * method;
   SpiceChar          * target;
   SpiceChar          * ilusrc;
   SpiceDouble          et;
   SpiceChar          * fixref;
   SpiceChar          * abcorr;
   SpiceChar          * obsrvr;
   SpiceDouble        * spoint;
   SpiceDouble          trgepc;
   SpiceDouble        * srfvec;
   SpiceDouble          phase;
   SpiceDouble          incdnc;
   SpiceDouble          emissn;

   struct argcheck argcheck[] =
      {
      { OREAD, "method", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "ilusrc", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "fixref", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "spoint", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "trgepc", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "srfvec", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "phase",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "incdnc",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "emissn", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 13)
      {
      USAGE("CSPICE_ILLUMG, `method`, `target`, `ilusrc`, et, `fixref`, "
             "`abcorr`, `obsrvr`, spoint[3], "
             "TRGEPC, SRFVEC[3], PHASE, INCDNC, EMISSN");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   method     = S_STR_ARGV( 0 );
   target     = S_STR_ARGV( 1 );
   ilusrc     = S_STR_ARGV( 2 );
   et         = S_DBL_ARGV( 3 );
   fixref     = S_STR_ARGV( 4 );
   abcorr     = S_STR_ARGV( 5 );
   obsrvr     = S_STR_ARGV( 6 );
   spoint     = A_DBL_ARGV( 7 );
   srfvec     = A_DBL_ARGV( 9 );

   illumg_c( method,
             target,
             ilusrc,
             et,
             fixref,
             abcorr,
             obsrvr,
             spoint,
             &trgepc,
             srfvec,
             &phase,
             &incdnc,
             &emissn );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[8 ]->value.d  = trgepc;
   Argv[10]->value.d  = phase;
   Argv[11]->value.d  = incdnc;
   Argv[12]->value.d  = emissn;

  /* Clean up temporary variables */
  zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
  }




/*
   void              illum_pl02 ( SpiceInt            handle,
                                  ConstSpiceInt     * dladsc,
                                  ConstSpiceChar    * target,
                                  SpiceDouble         et,
                                  ConstSpiceChar    * abcorr,
                                  ConstSpiceChar    * obsrvr,
                                  ConstSpiceDouble    spoint[3],
                                  SpiceDouble       * phase,
                                  SpiceDouble       * solar,
                                  SpiceDouble       * emissn    )
*/
PROCEDURE CSPICE_ILLUM_PL02(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt            * dladsc;
   SpiceChar           * target;
   SpiceDouble           et;
   SpiceChar           * abcorr;
   SpiceChar           * obsrvr;
   SpiceDouble         * spoint;
   SpiceDouble           phase;
   SpiceDouble           solar;
   SpiceDouble           emissn;

   SpiceDLADescr         descr;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "dladsc", (void*)IDL_TYP_LONG,    1, {SPICE_DLA_DSCSIZ}, 0},
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "spoint", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "phase",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "solar",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "emissn", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 10)
      {
      USAGE("CSPICE_ILLUM_PL02, handle, dladsc[8], `target`, et, `abcorr`, "
            "`obsrvr`, spoint[3], PHASE, SOLAR, EMISSN" );
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   dladsc     = A_INT_ARGV( 1 );
   target     = S_STR_ARGV( 2 );
   et         = S_DBL_ARGV( 3 );
   abcorr     = S_STR_ARGV( 4 );
   obsrvr     = S_STR_ARGV( 5 );
   spoint     = A_DBL_ARGV( 6 );

   /*
   Fill in the members of the local DLA descriptor.
   */
   descr.bwdptr = dladsc[0];
   descr.fwdptr = dladsc[1];
   descr.ibase  = dladsc[2];
   descr.isize  = dladsc[3];
   descr.dbase  = dladsc[4];
   descr.dsize  = dladsc[5];
   descr.cbase  = dladsc[6];
   descr.csize  = dladsc[7];


   illum_pl02 ( handle, &descr, target, et,      abcorr,
                obsrvr, spoint, &phase, &solar, &emissn );


   /* Check for SPICE call failure, clean up if failed. */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[7]->value.d = phase;
   Argv[8]->value.d = solar;
   Argv[9]->value.d = emissn;

   /*
   Clean up temporary variables
   */
   ICY_ALLOC_CHECK;
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              illum_plid_pl02 ( SpiceInt               handle,
                                       ConstSpiceDLADescr   * dladsc,
                                       ConstSpiceChar       * target,
                                       SpiceDouble            et,
                                       ConstSpiceChar       * abcorr,
                                       ConstSpiceChar       * obsrvr,
                                       SpiceDouble            spoint [3],
                                       SpiceInt               plid,
                                       SpiceDouble          * trgepc,
                                       SpiceDouble            srfvec [3],
                                       SpiceDouble          * phase,
                                       SpiceDouble          * solar,
                                       SpiceDouble          * emissn,
                                       SpiceBoolean         * visible,
                                       SpiceBoolean         * lit       )
*/
PROCEDURE CSPICE_ILLUM_PLID_PL02(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt            * dladsc;
   SpiceChar           * target;
   SpiceDouble           et;
   SpiceChar           * abcorr;
   SpiceChar           * obsrvr;
   SpiceDouble         * spoint;
   SpiceInt              plid;
   SpiceDouble           trgepc;
   SpiceDouble         * srfvec;
   SpiceDouble           phase;
   SpiceDouble           solar;
   SpiceDouble           emissn;
   SpiceBoolean          visible;
   SpiceBoolean          lit;

   SpiceDLADescr         descr;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "dladsc", (void*)IDL_TYP_LONG,    1, {SPICE_DLA_DSCSIZ}, 0},
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "spoint", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "plid",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "trgepc", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "srfvec", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "phase",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "solar",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "emissn", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "visible",(void*)IDL_TYP_BYTE,    0, { 0 },    0},
      { OWRIT, "lit",    (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 15)
      {
      USAGE("CSPICE_ILLUM_PLID_PL02, handle, dladsc[SPICE_DLA_DSCSIZ], "
            "`target`, et, `abcorr`, "
            "`obsrvr`, spoint[3], plid, TRGEPC, SRFVEC, "
            "PHASE, SOLAR, EMISSN, VISIBLE, LIT" );
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   dladsc     = A_INT_ARGV( 1 );
   target     = S_STR_ARGV( 2 );
   et         = S_DBL_ARGV( 3 );
   abcorr     = S_STR_ARGV( 4 );
   obsrvr     = S_STR_ARGV( 5 );
   spoint     = A_DBL_ARGV( 6 );
   plid       = S_INT_ARGV( 7 );
   srfvec     = A_DBL_ARGV( 9 );

   /*
   Fill in the members of the local DLA descriptor.
   */
   descr.bwdptr = dladsc[0];
   descr.fwdptr = dladsc[1];
   descr.ibase  = dladsc[2];
   descr.isize  = dladsc[3];
   descr.dbase  = dladsc[4];
   descr.dsize  = dladsc[5];
   descr.cbase  = dladsc[6];
   descr.csize  = dladsc[7];


   illum_plid_pl02 ( handle,
                     &descr,
                     target,
                     et,
                     abcorr,
                     obsrvr,
                     spoint,
                     plid,
                     &trgepc,
                     srfvec,
                     &phase,
                     &solar,
                     &emissn,
                     &visible,
                     &lit      );


   /* Check for SPICE call failure, clean up if failed. */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[8 ]->value.d = trgepc;
   Argv[10]->value.d = phase;
   Argv[11]->value.d = solar;
   Argv[12]->value.d = emissn;
   Argv[13]->value.c = visible;
   Argv[14]->value.c = lit;

   /*
   Clean up temporary variables
   */
   ICY_ALLOC_CHECK;
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ilumin_c ( ConstSpiceChar    * method,
                                ConstSpiceChar    * target,
                                SpiceDouble         et,
                                ConstSpiceChar    * fixref,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceChar    * obsrvr,
                                ConstSpiceDouble    spoint [3],
                                SpiceDouble       * trgepc,
                                SpiceDouble         srfvec [3],
                                SpiceDouble       * phase,
                                SpiceDouble       * solar,
                                SpiceDouble       * emissn     );
*/
PROCEDURE CSPICE_ILUMIN(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * method;
   SpiceChar          * target;
   SpiceDouble          et;
   SpiceChar          * fixref;
   SpiceChar          * abcorr;
   SpiceChar          * obsrvr;
   SpiceDouble        * spoint;
   SpiceDouble          trgepc;
   SpiceDouble        * srfvec;
   SpiceDouble          phase;
   SpiceDouble          solar;
   SpiceDouble          emissn;

   struct argcheck argcheck[] =
      {
      { OREAD, "method", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "fixref", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "spoint", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "trgepc", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "srfvec", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "phase",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "solar",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "emissn", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 12)
      {
      USAGE("CSPICE_ILUMIN, `method`, `target`, et, `fixref`, "
             "`abcorr`, `obsrvr`, spoint[3], "
             "TRGEPC, SRFVEC[3], PHASE, SOLAR, EMISSN ");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   method     = S_STR_ARGV( 0 );
   target     = S_STR_ARGV( 1 );
   et         = S_DBL_ARGV( 2 );
   fixref     = S_STR_ARGV( 3 );
   abcorr     = S_STR_ARGV( 4 );
   obsrvr     = S_STR_ARGV( 5 );
   spoint     = A_DBL_ARGV( 6 );
   srfvec     = A_DBL_ARGV( 8 );

   ilumin_c( method,
             target,
             et,
             fixref,
             abcorr,
             obsrvr,
             spoint,
             &trgepc,
             srfvec,
             &phase,
             &solar,
             &emissn );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[7 ]->value.d  = trgepc;
   Argv[9 ]->value.d  = phase;
   Argv[10]->value.d  = solar;
   Argv[11]->value.d  = emissn;

  /* Clean up temporary variables */
  zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
  }




/*
   void              inedpl_c ( SpiceDouble         a,
                                SpiceDouble         b,
                                SpiceDouble         c,
                                ConstSpicePlane   * plane,
                                SpiceEllipse      * ellipse,
                                SpiceBoolean      * found    )
*/
PROCEDURE CSPICE_INEDPL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          a;
   SpiceDouble          b;
   SpiceDouble          c;
   SpicePlane         * plane;
   SpiceEllipse       * ellipse;
   SpiceBoolean         found;

   struct argcheck argcheck[] =
      {
      { OREAD, "a",       (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "b",       (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "c",       (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "plane",   (void*)IDL_TYP_STRUCT,  0, { 0 },    0},
      { OWRIT, "ellipse", (void*)IDL_TYP_STRUCT,  0, { 0 },    0},
      { OWRIT, "found",   (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_INEDPL, a, b, c, plane, ELLIPSE, FOUND");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[3].type = s_SpicePlane;
   argcheck[4].type = s_SpiceEllipse;

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   a       = S_DBL_ARGV( 0 );
   b       = S_DBL_ARGV( 1 );
   c       = S_DBL_ARGV( 2 );
   plane   = S_PLN_ARGV( 3 );
   ellipse = S_ELL_ARGV( 4 );

   inedpl_c( a, b, c, plane, ellipse, &found);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[5]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              inelpl_c ( ConstSpiceEllipse * ellips,
                                ConstSpicePlane   * plane,
                                SpiceInt          * nxpts,
                                SpiceDouble         xpt1[3],
                                SpiceDouble         xpt2[3] );
*/
PROCEDURE CSPICE_INELPL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceEllipse       * ellips;
   SpicePlane         * plane;
   SpiceInt             nxpts;
   SpiceDouble        * xpt1;
   SpiceDouble        * xpt2;

   struct argcheck argcheck[] =
      {
      { OREAD, "ellips", (void*)IDL_TYP_STRUCT,  0, { 0 },    0},
      { OREAD, "plane",  (void*)IDL_TYP_STRUCT,  0, { 0 },    0},
      { OWRIT, "nxpts",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "xpt1",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "xpt2",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 5)
      {
      USAGE("CSPICE_INELPL, ellips, plane, NXPTS, XPT1, XPT2");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[0].type = s_SpiceEllipse;
   argcheck[1].type = s_SpicePlane;

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   ellips = S_ELL_ARGV( 0 );
   plane  = S_PLN_ARGV( 1 );
   xpt1   = A_DBL_ARGV( 3 );
   xpt2   = A_DBL_ARGV( 4 );

   inelpl_c ( ellips, plane, &nxpts, xpt1, xpt2 );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[2]->value.l = nxpts;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              inrypl_c ( ConstSpiceDouble    vertex [3],
                                ConstSpiceDouble    dir    [3],
                                ConstSpicePlane   * plane,
                                SpiceInt          * nxpts,
                                SpiceDouble         xpt    [3] )
*/
PROCEDURE CSPICE_INRYPL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * vertex;
   SpiceDouble         * dir;
   SpicePlane          * plane;
   SpiceInt              nxpts;
   SpiceDouble         * xpt;

   struct argcheck argcheck[] =
      {
      { OREAD, "vertex", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "dir",    (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "plane",  (void*)IDL_TYP_STRUCT,  0, { 0 },    0},
      { OWRIT, "nxpts",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "xpt",    (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 5)
      {
      USAGE("CSPICE_INRYPL, vertex[3], dir[3], plane, NXPTS, XPT[3]");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[2].type = s_SpicePlane;

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   vertex  = A_DBL_ARGV( 0 );
   dir     = A_DBL_ARGV( 1 );
   plane   = S_PLN_ARGV( 2 );
   xpt     = A_DBL_ARGV( 4 );

   inrypl_c( vertex, dir, plane, &nxpts, xpt);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[3]->value.l = nxpts;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*

 void              insrtd_c ( SpiceInt        item,
                              SpiceCell     * set  );

 */
PROCEDURE CSPICE_INSRTD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset;
   SpiceDouble            item;
   SpiceCell              set;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "item", (void*)IDL_TYP_DOUBLE, 0, { 0 }, 1},
      { RDWRT, "set",  (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_INSRTD, _item_, (SET)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[1].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[1]->value.s.arr->data);
   pack_cell( &set, 1, tag_offset, Argv );

   /* Did the user pass a vector for input? */
   if (extra->ndims == 0)
      {

      item = S_DBL_ARGV( 0 );

      insrtd_c ( item, &set );

      /*
       Test for a SPICE error signal. If found, display an error message to the
       user then return to the IDL application.
       */
      CHECK_CALL_FAILURE_MEM2( set, SCALAR );
      }
   else
      {
      /* Vector input.*/

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         item = ((SpiceDouble*)(Argv[0]->value.arr->data))[i];

         insrtd_c ( item, &set );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE_MEM2( set, i );
         }

      }

   /*
   Unpack the data from 'window' to 'Argv'.
   */
   unpack_cell( 1, tag_offset, &set, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*

 void              insrti_c ( SpiceInt        item,
                              SpiceCell     * set  );

*/
PROCEDURE CSPICE_INSRTI(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset;
   SpiceInt               item;
   SpiceCell              set;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "item", (void*)IDL_TYP_LONG,   0, { 0 }, 1},
      { RDWRT, "set",  (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_INSRTI, _item_, (SET)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[1].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[1]->value.s.arr->data);
   pack_cell( &set, 1, tag_offset, Argv );

   /* Did the user pass a vector for input? */
   if (extra->ndims == 0)
      {

      item = S_INT_ARGV( 0 );

      insrti_c ( item, &set );

      /*
      Test for a SPICE error signal. If found, display an error message to the
      user then return to the IDL application.
      */
      CHECK_CALL_FAILURE_MEM2( set, SCALAR );
      }
   else
      {
      /* Vector input.*/

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         item = ((SpiceInt*)(Argv[0]->value.arr->data))[i];

         insrti_c ( item, &set );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE_MEM2( set, i );
         }

      }

   /*
   Unpack the data from 'window' to 'Argv'.
   */
   unpack_cell( 1, tag_offset, &set, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*

   void              inter_c  (  SpiceCell        * a,
                                 SpiceCell        * b,
                                 SpiceCell        * c  );

*/
PROCEDURE CSPICE_INTER(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset1;
   SpiceInt             * tag_offset2;
   SpiceInt             * tag_offset3;
   SpiceCell              a;
   SpiceCell              b;
   SpiceCell              c;

   struct argcheck argcheck[] =
      {
      { OREAD, "a", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0},
      { OREAD, "b", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0},
      { RDWRT, "c", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_INTER, a, b, (C)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[0].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[1].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[2].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );


   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset1 = (SpiceInt*) (Argv[0]->value.s.arr->data);
   tag_offset2 = (SpiceInt*) (Argv[1]->value.s.arr->data);
   tag_offset3 = (SpiceInt*) (Argv[2]->value.s.arr->data);

   pack_cell( &a, 0, tag_offset1, Argv );
   pack_cell( &b, 1, tag_offset2, Argv );
   pack_cell( &c, 2, tag_offset3, Argv );

   inter_c ( &a, &b, &c );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM4( a, b, c, SCALAR );

   /*
   Unpack the cells, return the data from 'c' to 'Argv'.
   */
   unpack_cell( 0, tag_offset1, &a, Argv );
   unpack_cell( 1, tag_offset2, &b, Argv );
   unpack_cell( 2, tag_offset3, &c, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }





/*
   SpiceInt          intmax_c ( void )
*/
FUNCTION CSPICE_INTMAX(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR  retval_idl;
   SpiceInt  retval_c;

   /* Check the input contains the correct number of arguments. */
   if (Argc != 0)
      {
      USAGE("integer = CSPICE_INTMAX()");
      }

   retval_c = intmax_c();

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_LONG;
   retval_idl->value.l  = retval_c;

   return retval_idl;
   }




/*
   SpiceInt          intmin_c ( void )
*/
FUNCTION CSPICE_INTMIN(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR  retval_idl;
   SpiceInt  retval_c;

   /* Check the input contains the correct number of arguments. */
   if (Argc != 0)
      {
      USAGE("integer = CSPICE_INTMIN()");
      }

   retval_c = intmin_c();

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_LONG;
   retval_idl->value.l  = retval_c;

   return retval_idl;
   }




/*
   void              invert_c ( ConstSpiceDouble    m1[3][3],
                                SpiceDouble         m2[3][3]  )
*/
PROCEDURE CSPICE_INVERT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR          * Argv;
   struct extra_dims * extra;
   SpiceDouble       * m1;
   SpiceDouble       * m2;

   struct argcheck argcheck[] =
      {
      { OREAD, "m1", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      { OWRIT, "m2", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_INVERT, m1[3,3], M2[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   m1  = A_DBL_ARGV( 0 );
   m2  = A_DBL_ARGV( 1 );

   invert_c((Nx3d)m1,(SpiceDouble (*)[3])m2);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              invort_c ( ConstSpiceDouble    m1[3][3],
                                SpiceDouble         m2[3][3]  )
*/
PROCEDURE CSPICE_INVORT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR          * Argv;
   struct extra_dims * extra;
   SpiceDouble       * m1;
   SpiceDouble       * m2;

   struct argcheck argcheck[] =
      {
      { OREAD, "m1", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      { OWRIT, "m2", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_INVORT, m1[3,3], M2[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   m1  = A_DBL_ARGV( 0 );
   m2  = A_DBL_ARGV( 1 );

   invort_c((Nx3d)m1,(SpiceDouble (*)[3])m2);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceBoolean      isrot_c  ( ConstSpiceDouble    m   [3][3],
                                SpiceDouble         ntol,
                                SpiceDouble         dtol       )
*/
FUNCTION CSPICE_ISROT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceBoolean         retval_c;
   SpiceDouble        * m;
   SpiceDouble          ntol;
   SpiceDouble          dtol;

   struct argcheck argcheck[] =
      {
      { OREAD, "m",    (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      { OREAD, "ntol", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "dtol", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("boolean = CSPICE_ISROT( m[3,3], ntol, dtol )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   m    = A_DBL_ARGV( 0 );
   ntol = S_DBL_ARGV( 1 );
   dtol = S_DBL_ARGV( 2 );

   retval_c = isrot_c((Nx3d)m,ntol,dtol);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_BYTE;
   retval_idl->value.c  = (RETURN_BOOL) retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   SpiceBoolean      iswhsp_c ( ConstSpiceChar    * string )
*/
FUNCTION CSPICE_ISWHSP(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceBoolean         retval_c;
   SpiceChar          * string;

   struct argcheck argcheck[] =
      {
      { OREAD, "string", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("boolean = CSPICE_ISWHSP( `STRING` )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   string = S_STR_ARGV( 0 );

   retval_c = iswhsp_c(string);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_BYTE;
   retval_idl->value.c  = (RETURN_BOOL) retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   SpiceDouble       j1900_c  ( void )
*/
FUNCTION CSPICE_J1900(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR     retval_idl;
   SpiceDouble  retval_c;

   /* Check the input contains the correct number of arguments. */
   if (Argc != 0)
      {
      USAGE("double  = CSPICE_J1900()");
      }

   retval_c = j1900_c();

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   return retval_idl;
   }




/*
   SpiceDouble       j1950_c  ( void )
*/
FUNCTION CSPICE_J1950(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR     retval_idl;
   SpiceDouble  retval_c;

   /* Check the input contains the correct number of arguments. */
   if (Argc != 0)
      {
      USAGE("double  = CSPICE_J1950()");
      }

   retval_c = j1950_c();

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   return retval_idl;
   }




/*
   SpiceDouble       j2000_c  ( void )
*/
FUNCTION CSPICE_J2000(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR     retval_idl;
   SpiceDouble  retval_c;

   /* Check the input contains the correct number of arguments. */
   if (Argc != 0)
      {
      USAGE("double  = CSPICE_J2000()");
      }

   retval_c = j2000_c();

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   return retval_idl;
   }




/*
   SpiceDouble       j2100_c  ( void )
*/
FUNCTION CSPICE_J2100(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR     retval_idl;
   SpiceDouble  retval_c;

   /* Check the input contains the correct number of arguments. */
   if (Argc != 0)
      {
      USAGE("double  = CSPICE_J2100()");
      }

   retval_c = j2100_c();

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   return retval_idl;
   }




/*
   SpiceDouble       jyear_c  ( void )
*/
FUNCTION CSPICE_JYEAR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR     retval_idl;
   SpiceDouble  retval_c;

   /* Check the input contains the correct number of arguments. */
   if (Argc != 0)
      {
      USAGE("double  = CSPICE_JYEAR()");
      }

   retval_c = jyear_c();

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   return retval_idl;
   }




/*
   void              kclear_c ( void )
*/
PROCEDURE CSPICE_KCLEAR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   /* Check the input contains the correct number of arguments. */
   if (Argc != 0)
      {
      USAGE("CSPICE_KCLEAR");
      }

   kclear_c();

   if ( failed_c())
      {
      icy_fail(SCALAR);
      }

   }




/*
   void              kdata_c  ( SpiceInt          which,
                                ConstSpiceChar  * kind,
                                SpiceInt          fillen,
                                SpiceInt          typlen,
                                SpiceInt          srclen,
                                SpiceChar       * file,
                                SpiceChar       * filtyp,
                                SpiceChar       * source,
                                SpiceInt        * handle,
                                SpiceBoolean    * found   )
*/
PROCEDURE CSPICE_KDATA(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             which;
   SpiceChar          * kind;
   SpiceChar            file_buf  [RET_ARRAY_LEN+1];
   SpiceChar            filtyp_buf[RET_ARRAY_LEN+1];
   SpiceChar            source_buf[RET_ARRAY_LEN+1];
   SpiceInt             handle;
   SpiceBoolean         found;

   struct argcheck argcheck[] =
      {
      { OREAD, "which",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "kind",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "file",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "filtyp", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "source", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_KDATA, which, `kind`, `FILE`, `FILTYP`, `SOURCE`, "
            "HANDLE, FOUND");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   which          = S_INT_ARGV( 0 );
   kind           = S_STR_ARGV( 1 );

   (void) kdata_c( which,
            kind,
            RET_ARRAY_LEN,
            RET_ARRAY_LEN,
            RET_ARRAY_LEN,
            file_buf,
            filtyp_buf,
            source_buf,
            &handle,
            &found);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV( 2, file_buf);
   S_STR_RET_ARGV( 3, filtyp_buf);
   S_STR_RET_ARGV( 4, source_buf);

   Argv[5]->value.l = handle;
   Argv[6]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              kinfo_c  ( ConstSpiceChar  * file,
                                SpiceInt          typlen,
                                SpiceInt          srclen,
                                SpiceChar       * filtyp,
                                SpiceChar       * source,
                                SpiceInt        * handle,
                                SpiceBoolean    * found  )
*/
PROCEDURE CSPICE_KINFO(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * file;
   SpiceChar           filtyp_buf[RET_ARRAY_LEN+1];
   SpiceChar           source_buf[RET_ARRAY_LEN+1];
   SpiceInt            handle;
   SpiceBoolean        found;

   struct argcheck argcheck[] =
      {
      { OREAD, "file",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "filtyp", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "source", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 5)
      {
      USAGE("CSPICE_KINFO, `file`, `FILTYP`, `SOURCE`, HANDLE, FOUND");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   file       = S_STR_ARGV( 0 );

   kinfo_c( file,
            RET_ARRAY_LEN,
            RET_ARRAY_LEN,
            filtyp_buf,
            source_buf,
            &handle,
            &found);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV( 1, filtyp_buf);
   S_STR_RET_ARGV( 2, source_buf);

   Argv[3]->value.l = handle;
   Argv[4]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ktotal_c ( ConstSpiceChar   * kind,
                                SpiceInt         * count )
*/
PROCEDURE CSPICE_KTOTAL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * kind;
   SpiceInt             count;

   struct argcheck argcheck[] =
      {
      { OREAD, "kind",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "count", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_KTOTAL, `kind`, COUNT");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   kind   = S_STR_ARGV( 0 );

   ktotal_c( kind, &count);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.l = count;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceInt          lastnb_c ( ConstSpiceChar    * string )
*/
FUNCTION CSPICE_LASTNB(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceInt             retval_c;
   SpiceChar          * string;

   struct argcheck argcheck[] =
      {
      { OREAD, "string", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("integer = CSPICE_LASTNB( `STRING` )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   string  = S_STR_ARGV( 0 );

   retval_c = lastnb_c(string);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_LONG;
   retval_idl->value.l  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              latcyl_c ( SpiceDouble         radius,
                                SpiceDouble         lon,
                                SpiceDouble         lat,
                                SpiceDouble       * r,
                                SpiceDouble       * lonc,
                                SpiceDouble       * z      )
*/
PROCEDURE CSPICE_LATCYL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble           radius;
   SpiceDouble           lon;
   SpiceDouble           lat;
   SpiceDouble           r;
   SpiceDouble           lonc;
   SpiceDouble           z;

   struct argcheck argcheck[] =
      {
      { OREAD, "radius", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "lon",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "lat",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "r",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "lonc",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "z",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_LATCYL, radius, lon, lat, R, LONC, Z");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   radius  = S_DBL_ARGV( 0 );
   lon     = S_DBL_ARGV( 1 );
   lat     = S_DBL_ARGV( 2 );

   latcyl_c( radius,
             lon,
             lat,
             &r,
             &lonc,
             &z);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[3]->value.d = r;
   Argv[4]->value.d = lonc;
   Argv[5]->value.d = z;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              latrec_c ( SpiceDouble         radius,
                                SpiceDouble         longitude,
                                SpiceDouble         latitude,
                                SpiceDouble         rectan [3] )
*/
PROCEDURE CSPICE_LATREC(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceDouble            radius;
   SpiceDouble            longitude;
   SpiceDouble            latitude;
   SpiceDouble          * rectan;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "radius",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "longitude", (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "latitude",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "rectan",    (void*)IDL_TYP_DOUBLE,  1, { 3 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_LATREC, _radius_, _longitude_, _latitude_, "
                    "_RECTAN[3]_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   rectan = A_DBL_ARGV( 3 );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
   */
   if (extra->ndims == 0)
      {
      /* Scalar input. */
      radius     = S_DBL_ARGV( 0 );
      longitude  = S_DBL_ARGV( 1 );
      latitude   = S_DBL_ARGV( 2 );

      latrec_c(radius,longitude,latitude,rectan);

      /*
       Test for a SPICE error signal. If found, display an error message to
       the user then return to the IDL application.
       */
      CHECK_CALL_FAILURE( SCALAR );

      }
   else
      {
      /* Vector input. */

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         radius     = ((SpiceDouble*)(Argv[0]->value.arr->data))[i];
         longitude  = ((SpiceDouble*)(Argv[1]->value.arr->data))[i];
         latitude   = ((SpiceDouble*)(Argv[2]->value.arr->data))[i];

         latrec_c(radius,longitude,latitude, (rectan+i*3) );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              latsph_c ( SpiceDouble         radius,
                                SpiceDouble         lon,
                                SpiceDouble         lat,
                                SpiceDouble       * rho,
                                SpiceDouble       * colat,
                                SpiceDouble       * lons   )
*/
PROCEDURE CSPICE_LATSPH(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble           radius;
   SpiceDouble           lon;
   SpiceDouble           lat;
   SpiceDouble           rho;
   SpiceDouble           colat;
   SpiceDouble           lons;

   struct argcheck argcheck[] =
      {
      { OREAD, "radius", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "lon",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "lat",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "rho",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "colat",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "lons",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_LATSPH, radius, lon, lat, RHO, COLAT, LONS");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   radius  = S_DBL_ARGV( 0 );
   lon     = S_DBL_ARGV( 1 );
   lat     = S_DBL_ARGV( 2 );

   latsph_c( radius,
             lon,
             lat,
             &rho,
             &colat,
             &lons);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[3]->value.d = rho;
   Argv[4]->value.d = colat;
   Argv[5]->value.d = lons;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              latsrf_c ( ConstSpiceChar     * method,
                                ConstSpiceChar     * target,
                                SpiceDouble          et,
                                ConstSpiceChar     * fixref,
                                SpiceInt             npts,
                                ConstSpiceDouble     lonlat[][2],
                                SpiceDouble          srfpts[][3]  )
*/
PROCEDURE CSPICE_LATSRF(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   ConstSpiceChar      * method;
   ConstSpiceChar      * target;
   SpiceDouble           et;
   ConstSpiceChar      * fixref;
   SpiceInt              npts;
   ConstSpiceDouble    * lonlat;
   SpiceDouble         * srfpts;

   struct argcheck argcheck[] =
      {
      { OREAD, "method", (void*)IDL_TYP_STRING, 0, { 0 },    0},
      { OREAD, "target", (void*)IDL_TYP_STRING, 0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE, 0, { 0 },    0},
      { OREAD, "fixref", (void*)IDL_TYP_STRING, 0, { 0 },    0},
      { OREAD, "lonlat", (void*)IDL_TYP_DOUBLE, 2, { 2, 0 }, 0},
      { OWRIT, "srfpts", (void*)IDL_TYP_DOUBLE, 2, { 3, 0 }, 0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_LATSRF, `method`, `target`, et, `fixref`, "
            "lonlat[2,N], SRFPTS[3,N]" );
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   method     =  S_STR_ARGV( 0 );
   target     =  S_STR_ARGV( 1 );
   et         =  S_DBL_ARGV( 2 );
   fixref     =  S_STR_ARGV( 3 );
   lonlat     =  A_DBL_ARGV( 4 );

   npts       =  Argv[4]->value.arr->dim[1];

   /*
   Allocate the necessary memory for 'normls'. Check for an error signal.
   */
   srfpts = alloc_SpiceDouble_C_array ( (int) npts, 3 );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   latsrf_c ( method,
                 target,
                 et,
                 fixref,
                 npts,
                 (Nx2d)lonlat,
                 (SpiceDouble(*)[3])srfpts );

   /* Check for SPICE call failure, clean up if failed. */
   if ( failed_c())
      {
      free_SpiceMemory( srfpts );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   if ( npts > 0 )
      {
      char      *srfpts_copy;
      int        tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 2;
      tmp_dims[0] = 3;
      tmp_dims[1] = npts;
      srfpts_copy = IDL_MakeTempArray( IDL_TYP_DOUBLE,
                                       tmp_ndims,
                                       tmp_dims,
                                       IDL_ARR_INI_NOP,
                                       &Argv[5]);

      memmove(srfpts_copy, srfpts, 3 * npts * sizeof(SpiceDouble) );
      }

   /*
   Clean up temporary variables
   */
   free_SpiceMemory( srfpts );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              lcase_c  ( SpiceChar         * in,
                                SpiceInt            lenout,
                                SpiceChar         * out     )
*/
PROCEDURE CSPICE_LCASE(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * in;
   SpiceChar           * out_buf;

   struct argcheck argcheck[] =
      {
      { OREAD, "in",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "out", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_LCASE, `in`, `OUT`");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   in = S_STR_ARGV( 0 );

   /*
   Allow a null input string as a no-op.
   */
   if ( (int) strlen(in) > 0)
      {

      /*
      Allocate the needed memory for the output string. Assign the length
      as 1 plus the string length of the input string. We need the '+1'
      for the C string null terminator.
      */
      out_buf = (SpiceChar*)alloc_SpiceString ( (int) strlen(in) + 1 );

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      lcase_c( in, (SpiceInt) strlen(in) + (SpiceInt)1, out_buf);

      /* Check for SPICE call failure, clean up if failed. */
      if ( failed_c())
         {
         free_SpiceMemory( out_buf );

         zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
         icy_fail(SCALAR);
         }

      /*
      Note, this is a copy operation.
      */
      S_STR_RET_ARGV( 1, out_buf );

      /* Done, so free the allocated memory. */
      free_SpiceMemory( out_buf );
      }
   else
      {

      /*
      Return nothing for a empty input string.
      */
      out_buf = NULL;

      /*
      Note, this is a copy operation.
      */
      S_STR_RET_ARGV( 1, out_buf );
      }

   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ldpool_c ( ConstSpiceChar    * filename )
*/
PROCEDURE CSPICE_LDPOOL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * filename;

   struct argcheck argcheck[] =
      {
      { OREAD, "filename", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_LDPOOL, `filename`");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   filename   = S_STR_ARGV( 0 );

   ldpool_c(filename);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              limb_pl02 ( SpiceInt              handle,
                                 ConstSpiceDLADescr  * dladsc,
                                 ConstSpiceChar      * target,
                                 SpiceDouble           et,
                                 ConstSpiceChar      * fixfrm,
                                 ConstSpiceChar      * abcorr,
                                 ConstSpiceChar      * obsrvr,
                                 SpiceInt              npoints,
                                 SpiceDouble         * trgepc,
                                 SpiceDouble           obspos   [3],
                                 SpiceDouble           limbpts  [][3],
                                 SpiceInt              plateIDs []     )
*/
PROCEDURE CSPICE_LIMB_PL02(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt            * dladsc;
   SpiceChar           * target;
   SpiceDouble           et;
   SpiceChar           * fixfrm;
   SpiceChar           * abcorr;
   SpiceChar           * obsrvr;
   SpiceInt              npoints;
   SpiceDouble           trgepc;
   SpiceDouble         * obspos;
   SpiceDouble         * limbpts   = NULL;
   SpiceInt            * plateIDs  = NULL;


   SpiceDLADescr         descr;


   struct argcheck argcheck[] =
      {
      { OREAD, "handle",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "dladsc",   (void*)IDL_TYP_LONG,    1, {SPICE_DLA_DSCSIZ}, 0},
      { OREAD, "target",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",       (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "fixfrm",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "abcorr",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obsrvr",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "npoints",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "trgepc",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "obspos",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "limbpts",  (void*)IDL_TYP_DOUBLE,  2, { 3, 0 }, 0},
      { OWRIT, "plateIDs", (void*)IDL_TYP_LONG,    1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 12)
      {
      USAGE("CSPICE_LIMB_PL02, handle, dladsc[SPICE_DLA_DSCSIZ], "
            "`target`, et, "
            "`fixfrm`, `abcorr`, `obsrvr`, npoints, TRGEPC, "
            "OBSPOS[], LIMBPTS[3][], PLATEIDS[]" );
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   dladsc     = A_INT_ARGV( 1 );
   target     = S_STR_ARGV( 2 );
   et         = S_DBL_ARGV( 3 );
   fixfrm     = S_STR_ARGV( 4 );
   abcorr     = S_STR_ARGV( 5 );
   obsrvr     = S_STR_ARGV( 6 );
   npoints    = S_INT_ARGV( 7 );

   /*
   Note: an assignment for trgepc (arg 8) is not needed here.
   */
   obspos     = A_DBL_ARGV( 9 );

   if ( npoints <= 0)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(7, "npoints", IDL_VarName(Argv_orig[7]),
                     "`npoints` must be greater-than zero.");
      }


   /*
   Fill in the members of the local DLA descriptor.
   */
   descr.bwdptr = dladsc[0];
   descr.fwdptr = dladsc[1];
   descr.ibase  = dladsc[2];
   descr.isize  = dladsc[3];
   descr.dbase  = dladsc[4];
   descr.dsize  = dladsc[5];
   descr.cbase  = dladsc[6];
   descr.csize  = dladsc[7];


   /*
   Allocate the necessary memory for the `limbpts' and
   `plateIDs' output arrays. Check for an error signal.

   Allocate memory only if npoints > 0. It's an error if
   this condition is not met; limb_pl02 will signal it.
   */
   if ( npoints > 0 )
      {

      limbpts = alloc_SpiceDouble_C_array ( 1, (int)(3*npoints) );

      if ( failed_c() )
         {
         ICY_ALLOC_CHECK;
         zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

         icy_fail(SCALAR);
         }


      plateIDs = alloc_SpiceInt_C_array ( 1, (int)npoints );

      if ( failed_c() )
         {
         free_SpiceMemory( limbpts );

         ICY_ALLOC_CHECK;
         zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

         icy_fail(SCALAR);
         }

      }


   limb_pl02 ( handle,  &descr,   target,  et,      fixfrm,
               abcorr,  obsrvr,   npoints, &trgepc, obspos,
               (SpiceDouble(*)[3])limbpts,          plateIDs );


   /* Check for SPICE call failure, clean up if failed. */
   if ( failed_c() )
      {
      free_SpiceMemory( limbpts  );
      free_SpiceMemory( plateIDs );

      ICY_ALLOC_CHECK;
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

      icy_fail(SCALAR);
      }

   /*
   Set our one scalar output argument.
   */
   Argv[8]->value.d = trgepc;


   /*
   Create limbpts and plateIDs output arguments.

   Note that we don't handle the case npoints == 0 here since
   limb_pl02 will already have signaled an error.
   */

   {
      char      *limbpts_copy;
      int        tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims    = 2;
      tmp_dims[0]  = 3;
      tmp_dims[1]  = npoints;
      limbpts_copy = IDL_MakeTempArray( IDL_TYP_DOUBLE,
                                        tmp_ndims,
                                        tmp_dims,
                                        IDL_ARR_INI_NOP,
                                        &Argv[10]);

      memmove( limbpts_copy, limbpts, npoints * 3 * sizeof(SpiceDouble) );
   }

   {
      char       * plateIDs_copy;
      int          tmp_ndims;
      IDL_MEMINT   tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims     = 1;
      tmp_dims[0]   = npoints;
      plateIDs_copy = IDL_MakeTempArray(IDL_TYP_LONG,    tmp_ndims, tmp_dims,
                                        IDL_ARR_INI_NOP, &Argv[11]);
      memmove( plateIDs_copy, plateIDs, npoints * sizeof(SpiceInt) );
   }


   /*
   Clean up temporary variables
   */
   free_SpiceMemory( limbpts  );
   free_SpiceMemory( plateIDs );


   /*
   Clean up temporary variables
   */
   ICY_ALLOC_CHECK;
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void            limbpt_c ( ConstSpiceChar    * method,
                              ConstSpiceChar    * target,
                              SpiceDouble         et,
                              ConstSpiceChar    * fixref,
                              ConstSpiceChar    * abcorr,
                              ConstSpiceChar    * corloc,
                              ConstSpiceChar    * obsrvr,
                              ConstSpiceDouble    refvec[3],
                              SpiceDouble         rolstp,
                              SpiceInt            ncuts,
                              SpiceDouble         schstp,
                              SpiceDouble         soltol,
                              SpiceInt            maxn,
                              SpiceInt          * npts,
                              SpiceDouble         points[][3],
                              SpiceDouble         epochs[],
                              SpiceDouble         tangts[][3]  )
*/
PROCEDURE CSPICE_LIMBPT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar          * method;
   SpiceChar          * target;
   SpiceDouble          et;
   SpiceChar          * fixref;
   SpiceChar          * abcorr;
   SpiceChar          * corloc;
   SpiceChar          * obsrvr;
   SpiceDouble        * refvec;
   SpiceDouble          rolstp;
   SpiceInt             ncuts;
   SpiceDouble          schstp;
   SpiceDouble          soltol;
   SpiceInt             maxn;
   SpiceInt           * npts;
   SpiceDouble        * points;
   SpiceDouble        * epochs;
   SpiceDouble        * tangts;


   struct argcheck argcheck[] =
      {
      { OREAD, "method", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "fixref", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "corloc", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "refvec", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "rolstp", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "ncuts",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "schstp", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "soltol", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "maxn",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "npts",   (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { OWRIT, "points", (void*)IDL_TYP_DOUBLE,  2, { 3, 0 }, 0},
      { OWRIT, "epochs", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OWRIT, "tangts", (void*)IDL_TYP_DOUBLE,  2, { 3, 0 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 17)
      {
      USAGE("CSPICE_LIMBPT, `method`, `target`, et, `fixref`, "
                           "`abcorr`, corloc, `obsrvr`, refvec, rolstp, "
                           "ncuts, schstp, soltol, maxn, NPTS[maxn], "
                           "POINTS[3,maxn], EPOCHS[maxn], TANGTS[3,maxn]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   method     = S_STR_ARGV( 0 );
   target     = S_STR_ARGV( 1 );
   et         = S_DBL_ARGV( 2 );
   fixref     = S_STR_ARGV( 3 );
   abcorr     = S_STR_ARGV( 4 );
   corloc     = S_STR_ARGV( 5 );
   obsrvr     = S_STR_ARGV( 6 );
   refvec     = A_DBL_ARGV( 7 );
   rolstp     = S_DBL_ARGV( 8 );
   ncuts      = S_INT_ARGV( 9 );
   schstp     = S_DBL_ARGV( 10 );
   soltol     = S_DBL_ARGV( 11 );
   maxn       = S_INT_ARGV( 12 );

   /*
   Allocate the necessary memory for 'npts', 'points', 'epochs',
   and 'tangts'. Check for an error signal.
   */
   npts = alloc_SpiceInt_C_array( 1, (int)maxn);
   if ( failed_c())
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   points = alloc_SpiceDouble_C_array( (int)maxn, 3);
   if ( failed_c())
      {
      free_SpiceMemory( npts );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   tangts = alloc_SpiceDouble_C_array( (int)maxn, 3);
   if ( failed_c())
      {
      free_SpiceMemory( npts );
      free_SpiceMemory( points );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   epochs = alloc_SpiceDouble_C_array( 1, (int)maxn );
   if ( failed_c())
      {
      free_SpiceMemory( npts );
      free_SpiceMemory( points );
      free_SpiceMemory( tangts );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   limbpt_c ( method,
              target,
              et,
              fixref,
              abcorr,
              corloc,
              obsrvr,
              refvec,
              rolstp,
              ncuts,
              schstp,
              soltol,
              maxn,
              npts,
              (SpiceDouble(*)[3])points,
              epochs,
              (SpiceDouble(*)[3])tangts );

   if ( failed_c())
      {
      free_SpiceMemory( npts );
      free_SpiceMemory( points );
      free_SpiceMemory( tangts );
      free_SpiceMemory( epochs );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   if ( maxn > 0)
      {
      char      *npts_copy;
      char      *points_copy;
      char      *epochs_copy;
      char      *tangts_copy;
      int        tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = maxn;
      tmp_dims[1] = 0;
      npts_copy   = IDL_MakeTempArray( IDL_TYP_LONG,
                                       tmp_ndims,
                                       tmp_dims,
                                       IDL_ARR_INI_NOP,
                                       &Argv[13]);

      tmp_ndims   = 2;
      tmp_dims[0] = 3;
      tmp_dims[1] = maxn;
      points_copy = IDL_MakeTempArray( IDL_TYP_DOUBLE,
                                       tmp_ndims,
                                       tmp_dims,
                                       IDL_ARR_INI_NOP,
                                       &Argv[14]);

      tmp_ndims   = 1;
      tmp_dims[0] = maxn;
      tmp_dims[1] = 0;
      epochs_copy = IDL_MakeTempArray( IDL_TYP_DOUBLE,
                                       tmp_ndims,
                                       tmp_dims,
                                       IDL_ARR_INI_NOP,
                                       &Argv[15]);

      tmp_ndims   = 2;
      tmp_dims[0] = 3;
      tmp_dims[1] = maxn;
      tangts_copy = IDL_MakeTempArray( IDL_TYP_DOUBLE,
                                       tmp_ndims,
                                       tmp_dims,
                                       IDL_ARR_INI_NOP,
                                       &Argv[16]);

      memmove(npts_copy,   npts,       maxn * sizeof(SpiceInt)    );
      memmove(points_copy, points, 3 * maxn * sizeof(SpiceDouble) );
      memmove(epochs_copy, epochs,     maxn * sizeof(SpiceDouble) );
      memmove(tangts_copy, tangts, 3 * maxn * sizeof(SpiceDouble) );
      }

   /*
   Clean up temporary variables
   */
   free_SpiceMemory( npts );
   free_SpiceMemory( points );
   free_SpiceMemory( epochs );
   free_SpiceMemory( tangts );
   ICY_ALLOC_CHECK;

   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void            llgrid_pl02 ( SpiceInt               handle,
                                 ConstSpiceDLADescr   * dladsc,
                                 SpiceInt               npoints,
                                 ConstSpiceDouble       grid     [][2],
                                 SpiceDouble            spoints  [][3],
                                 SpiceInt               plateIDs []     )
*/
PROCEDURE CSPICE_LLGRID_PL02(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt            * dladsc;
   SpiceInt              npoints;
   SpiceDouble         * grid;
   SpiceDouble         * spoints   = NULL;
   SpiceInt            * plateIDs  = NULL;


   SpiceDLADescr         descr;


   struct argcheck argcheck[] =
      {
      { OREAD, "handle",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "dladsc",   (void*)IDL_TYP_LONG,    1, {SPICE_DLA_DSCSIZ}, 0},
      { OREAD, "npoints",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "grid",     (void*)IDL_TYP_DOUBLE,  2, { 2, 0 }, 0},
      { OWRIT, "spoints",  (void*)IDL_TYP_DOUBLE,  2, { 3, 0 }, 0},
      { OWRIT, "plateIDs", (void*)IDL_TYP_LONG,    1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_LLGRID_PL02, handle, dladsc[SPICE_DLA_DSCSIZ], "
            "npoints, grid, SPOINTS[3][npoints], PLATEIDS[npoints]" );
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   dladsc     = A_INT_ARGV( 1 );
   npoints    = S_INT_ARGV( 2 );
   grid       = A_DBL_ARGV( 3 );

   if ( npoints <= 0)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(2, "npoints", IDL_VarName(Argv_orig[2]),
                     "`npoints` must be greater-than zero.");
      }


   /*
   Fill in the members of the local DLA descriptor.
   */
   descr.bwdptr = dladsc[0];
   descr.fwdptr = dladsc[1];
   descr.ibase  = dladsc[2];
   descr.isize  = dladsc[3];
   descr.dbase  = dladsc[4];
   descr.dsize  = dladsc[5];
   descr.cbase  = dladsc[6];
   descr.csize  = dladsc[7];


   /*
   Allocate the necessary memory for the `spoints' and
   `plateIDs' output arrays. Check for an error signal.

   Allocate memory only if npoints > 0. It's an error if
   this condition is not met; limb_pl02 will signal it.
   */
   if ( npoints > 0 )
   {

      spoints = alloc_SpiceDouble_C_array ( 1, (int)(3*npoints) );

      if ( failed_c() )
      {
         ICY_ALLOC_CHECK;
         zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

         icy_fail(SCALAR);
      }


      plateIDs = alloc_SpiceInt_C_array ( 1, (int)npoints );

      if ( failed_c() )
      {
         free_SpiceMemory( spoints );

         ICY_ALLOC_CHECK;
         zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

         icy_fail(SCALAR);
      }
   }


   llgrid_pl02 ( handle,
                 &descr,
                 npoints,
                 (ConstSpiceDouble(*)[2]) grid,
                 (SpiceDouble     (*)[3]) spoints,
                 plateIDs                         );


   /* Check for SPICE call failure, clean up if failed. */
   if ( failed_c() )
   {
      free_SpiceMemory( spoints  );
      free_SpiceMemory( plateIDs );

         ICY_ALLOC_CHECK;
         zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

         icy_fail(SCALAR);
   }


   /*
   Create spoints and plateIDs output arguments.

   Note that we don't handle the case npoints == 0 here since
   llgrid_pl02 will already have signaled an error.
   */

   {
      char      *spoints_copy;
      int        tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims    = 2;
      tmp_dims[0]  = 3;
      tmp_dims[1]  = npoints;
      spoints_copy = IDL_MakeTempArray( IDL_TYP_DOUBLE,
                                        tmp_ndims,
                                        tmp_dims,
                                        IDL_ARR_INI_NOP,
                                        &Argv[4]);

      memmove( spoints_copy, spoints, npoints * 3 * sizeof(SpiceDouble) );
   }

   {
      char       * plateIDs_copy;
      int          tmp_ndims;
      IDL_MEMINT   tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims     = 1;
      tmp_dims[0]   = npoints;
      plateIDs_copy = IDL_MakeTempArray(IDL_TYP_LONG,    tmp_ndims, tmp_dims,
                                        IDL_ARR_INI_NOP, &Argv[5]);
      memmove( plateIDs_copy, plateIDs, npoints * sizeof(SpiceInt) );
   }


   /*
   Clean up temporary variables
   */
   free_SpiceMemory( spoints  );
   free_SpiceMemory( plateIDs );


   /*
   Clean up temporary variables
   */
   ICY_ALLOC_CHECK;
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              lmpool_c ( const void        * cvals,
                                SpiceInt            lenvals,
                                SpiceInt            n       )
*/
PROCEDURE CSPICE_LMPOOL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar          ** cvals;
   SpiceInt              cvals_len;
   SpiceInt              cvals_size;
   SpiceInt              i;

   struct argcheck argcheck[] =
      {
      { OREAD, "length", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "cvals",  (void*)IDL_TYP_STRING,  1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_LMPOOL, length, cvals[]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Retrieve input array dimensions (to pass on to C) */
   cvals_len  = S_INT_ARGV(0) + 1;
   cvals_size = A_LEN_ARGV(1);

   cvals = alloc_SpiceString_C_array ( cvals_len, cvals_size );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Initialize local variables, to pass to CSPICE */
   for (i=0; i < cvals_size; i++)
      {
      strncpy( *cvals + i*cvals_len,
               IDL_STRING_STR( &((IDL_STRING*)(Argv[1]->value.arr->data))[i]),
               cvals_len);
      }

   lmpool_c( *cvals, cvals_len, cvals_size);
   CHECK_CALL_FAILURE_MEM( 1, cvals );

   /* Free the memory allocated to cvals. */
   free_SpiceString_C_array ( 1, cvals );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              lparse_c ( ConstSpiceChar    * list,
                                ConstSpiceChar    * delim,
                                SpiceInt            nmax,
                                SpiceInt            lenout,
                                SpiceInt          * n,
                                void              * items   )
*/
PROCEDURE CSPICE_LPARSE(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   IDL_STRING          * idl_ret_str;
   IDL_MEMINT            lDimensions[IDL_MAX_ARRAY_DIM];
   SpiceInt              i;

   SpiceChar          *  list;
   SpiceChar          *  delim;
   char               ** str_array;
   SpiceChar          ** items;
   SpiceInt              items_dim;
   SpiceInt              items_len;
   SpiceInt              n_max;

   struct argcheck argcheck[] =
      {
      { OREAD, "list",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "delim",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "n_max",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "items",  (void*)IDL_TYP_STRING,  1, { 0 },    0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_LPARSE, `list`, `delim`, n_max, ITEMS[]");
      }

   /* Initialize local variables, to pass to CSPICE */
   extra     = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );
   list      = S_STR_ARGV( 0 );
   delim     = S_STR_ARGV( 1 );
   n_max     = S_INT_ARGV( 2 );
   items_len = strlen(list) + 1;

   items = alloc_SpiceString_C_array ( items_len, n_max );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /*
   Make the CSPICE call. Check for a failed. Free memory if failed_c equals
   TRUE.
   */
   lparse_c( list, delim, n_max, items_len, &items_dim, *items);

   /* Check for SPICE call failure, clean up if failed. */
   CHECK_CALL_FAILURE_MEM( 1, items );

   if( items_dim > 0 )
      {

      /* Create a string array for passing to the IDL created array. */
      str_array  = alloc_SpiceString_C_Copy_array ( items_dim, items_len,
                                                    items );

      CHECK_CALL_FAILURE_MEM( 1, items );

      /*
      Create the IDL array for the right size and cast it to an
      IDL_STRING pointer.
      */
      lDimensions[0] = items_dim;
      idl_ret_str    = (IDL_STRING *)IDL_MakeTempArray((int) IDL_TYP_STRING,
                       1, lDimensions, IDL_ARR_INI_NOP,  &Argv[3]);

      /*
      Store the string in the IDL string with the string length for
      each element.
      */
      for ( i=0; i<items_dim; i++ )
         {
         IDL_StrStore( &(idl_ret_str[i]), (char*)str_array[i]);
         idl_ret_str[i].slen = strlen(str_array[i]);
         }

      /* Free the memory allocated to str_array. */
      free_SpiceString_C_array ( (int) items_dim, str_array );

      }

   /* Free the memory allocated to items. */
   free_SpiceString_C_array ( 1, items );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
 SpiceDouble       lspcn_c ( ConstSpiceChar   * body,
                             SpiceDouble        et,
                             ConstSpiceChar   * abcorr )
 */
FUNCTION CSPICE_LSPCN(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceDouble          retval_c;
   SpiceChar          * body;
   SpiceDouble          et;
   SpiceChar          * abcorr;

   struct argcheck argcheck[] =
      {
      { OREAD, "body",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("double  = CSPICE_LSPCN( `body`, et, `abcorr` )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   body   = S_STR_ARGV( 0 );
   et     = S_DBL_ARGV( 1 );
   abcorr = S_STR_ARGV( 2 );

   retval_c =  lspcn_c ( body, et, abcorr );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              ltime_c  ( SpiceDouble         etobs,
                                SpiceInt            obs,
                                ConstSpiceChar    * dir,
                                SpiceInt            targ,
                                SpiceDouble       * ettarg,
                                SpiceDouble       * elapsd  )
*/
PROCEDURE CSPICE_LTIME(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          etobs;
   SpiceInt             obs;
   SpiceChar          * dir;
   SpiceInt             targ;
   SpiceDouble          ettarg;
   SpiceDouble          elapsd;

   struct argcheck argcheck[] =
      {
      { OREAD, "etobs",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "obs",    (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "dir",    (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "targ",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "ettarg", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "elapsd", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_LTIME, etobs, obs, `dir`, targ, ETTARG, ELAPSD");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   etobs      = S_DBL_ARGV( 0 );
   obs        = S_INT_ARGV( 1 );
   dir        = S_STR_ARGV( 2 );
   targ       = S_INT_ARGV( 3 );

   ltime_c( etobs,
            obs,
            dir,
            targ,
            &ettarg,
            &elapsd);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[4]->value.d = ettarg;
   Argv[5]->value.d = elapsd;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              m2eul_c  ( ConstSpiceDouble    r[3][3],
                                SpiceInt            axis3,
                                SpiceInt            axis2,
                                SpiceInt            axis1,
                                SpiceDouble       * angle3,
                                SpiceDouble       * angle2,
                                SpiceDouble       * angle1  )
*/
PROCEDURE CSPICE_M2EUL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * r;
   SpiceInt              axis3;
   SpiceInt              axis2;
   SpiceInt              axis1;
   SpiceDouble           angle3;
   SpiceDouble           angle2;
   SpiceDouble           angle1;

   struct argcheck argcheck[] =
      {
      { OREAD, "r",      (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      { OREAD, "axis3",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "axis2",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "axis1",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "angle3", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "angle2", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "angle1", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_M2EUL, r[3,3], axis3, axis2, axis1, "
            "ANGLE3, ANGLE2, ANGLE1");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   r       = A_DBL_ARGV( 0 );
   axis3   = S_INT_ARGV( 1 );
   axis2   = S_INT_ARGV( 2 );
   axis1   = S_INT_ARGV( 3 );

   m2eul_c( (Nx3d)r,
             axis3,
             axis2,
             axis1,
             &angle3,
             &angle2,
             &angle1);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[4]->value.d = angle3;
   Argv[5]->value.d = angle2;
   Argv[6]->value.d = angle1;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              m2q_c    ( ConstSpiceDouble    r[3][3],
                                SpiceDouble         q[4]     )
*/
PROCEDURE CSPICE_M2Q(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * r;
   SpiceDouble        * q;

   struct argcheck argcheck[] =
      {
      { OREAD, "r", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      { OWRIT, "q", (void*)IDL_TYP_DOUBLE,  1, { 4 },    0},
     };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_M2Q, r[3,3], Q[4]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   r  = A_DBL_ARGV( 0 );
   q  = A_DBL_ARGV( 1 );

   m2q_c((Nx3d)r,q);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceBoolean      matchi_c ( ConstSpiceChar    * string,
                                ConstSpiceChar    * templ,
                                SpiceChar           wstr,
                                SpiceChar           wchr   )
*/
FUNCTION CSPICE_MATCHI(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceBoolean         retval_c;
   SpiceChar          * string;
   SpiceChar          * templ;
   SpiceChar            wstr;
   SpiceChar            wchr;

   struct argcheck argcheck[] =
      {
      { OREAD, "string", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "templ",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "wstr",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "wchr",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("boolean = CSPICE_MATCHI( `string`, `templ`, "
                    "`wstr`, `wchr` )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   string = S_STR_ARGV( 0 );
   templ  = S_STR_ARGV( 1 );

   wstr = S_STR_ARGV( 2 )[0];
   if (Argv[2]->value.str.slen > 1)
      {
      IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_RET,
                  "All but the first character of 'wstr' are ignored");
      }

   wchr = S_STR_ARGV( 3 )[0];
   if (Argv[3]->value.str.slen > 1)
      {
      IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_RET,
                  "All but the first character of 'wchr' are ignored");
      }

   retval_c = matchi_c(string,templ,wstr,wchr);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_BYTE;
   retval_idl->value.c  = (RETURN_BOOL) retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   SpiceBoolean      matchw_c ( ConstSpiceChar    * string,
                                ConstSpiceChar    * templ,
                                SpiceChar           wstr,
                                SpiceChar           wchr   )
*/
FUNCTION CSPICE_MATCHW(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   IDL_VPTR              retval_idl;
   SpiceBoolean          retval_c;
   SpiceChar           * string;
   SpiceChar           * templ;
   SpiceChar             wstr;
   SpiceChar             wchr;

   struct argcheck argcheck[] =
      {
      { OREAD, "string", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "templ",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "wstr",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "wchr",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("boolean = CSPICE_MATCHW( `string`, `templ`, `wstr`, `wchr` )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   string = S_STR_ARGV( 0 );
   templ  = S_STR_ARGV( 1 );
   wstr   = S_STR_ARGV( 2 )[0];

   if (Argv[2]->value.str.slen > 1)
      {
      IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_RET,
                  "All but the first character of 'wstr' are ignored");
      }

   wchr = S_STR_ARGV( 3 )[0];
   if (Argv[3]->value.str.slen > 1)
      {
      IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_RET,
                  "All but the first character of 'wchr' are ignored");
       }

   retval_c = matchw_c(string,templ,wstr,wchr);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_BYTE;
   retval_idl->value.c  = (RETURN_BOOL) retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              mequ_c   ( ConstSpiceDouble    m1  [3][3],
                                SpiceDouble         mout[3][3] )
*/
PROCEDURE CSPICE_MEQU(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * m1;
   SpiceDouble         * mout;

   struct argcheck argcheck[] =
      {
      { OREAD, "m1",   (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      { OWRIT, "mout", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_MEQU, m1[3,3], MOUT[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   m1   = A_DBL_ARGV( 0 );
   mout = A_DBL_ARGV( 1 );

   mequ_c((Nx3d)m1,(SpiceDouble (*)[3])mout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              mtxm_c   ( ConstSpiceDouble    m1  [3][3],
                                ConstSpiceDouble    m2  [3][3],
                                SpiceDouble         mout[3][3] )
*/
PROCEDURE CSPICE_MTXM(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * m1;
   SpiceDouble         * m2;
   SpiceDouble         * mout;

   struct argcheck argcheck[] =
      {
      { OREAD, "m1",   (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      { OREAD, "m2",   (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      { OWRIT, "mout", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_MTXM, m1[3,3], m2[3,3], MOUT[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   m1   = A_DBL_ARGV( 0 );
   m2   = A_DBL_ARGV( 1 );
   mout = A_DBL_ARGV( 2 );

   mtxm_c( (Nx3d)m1,
           (Nx3d)m2,
           (SpiceDouble(*)     [3])mout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              mtxv_c   ( ConstSpiceDouble    m1  [3][3],
                                ConstSpiceDouble    vin [3],
                                SpiceDouble         vout[3]    )
*/
PROCEDURE CSPICE_MTXV(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * m1;
   SpiceDouble         * vin;
   SpiceDouble         * vout;

   struct argcheck argcheck[] =
      {
      { OREAD, "m1",   (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      { OREAD, "vin",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "vout", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_MTXV, m1[3,3], vin[3], VOUT[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   m1         = A_DBL_ARGV( 0 );
   vin        = A_DBL_ARGV( 1 );
   vout       = A_DBL_ARGV( 2 );

   mtxv_c( (Nx3d)m1,
           vin,
           vout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              mxm_c    ( ConstSpiceDouble    m1  [3][3],
                                ConstSpiceDouble    m2  [3][3],
                                SpiceDouble         mout[3][3] )
*/
PROCEDURE CSPICE_MXM(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * m1;
   SpiceDouble         * m2;
   SpiceDouble         * mout;

  struct argcheck argcheck[] =
      {
      { OREAD, "m1",   (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      { OREAD, "m2",   (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      { OWRIT, "mout", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_MXM, m1[3,3], m2[3,3], MOUT[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   m1         = A_DBL_ARGV( 0 );
   m2         = A_DBL_ARGV( 1 );
   mout       = A_DBL_ARGV( 2 );

   mxm_c( (Nx3d)m1,
          (Nx3d)m2,
          (SpiceDouble      (*)[3])mout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              mxmt_c   ( ConstSpiceDouble    m1  [3][3],
                                ConstSpiceDouble    m2  [3][3],
                                SpiceDouble         mout[3][3] )
*/
PROCEDURE CSPICE_MXMT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * m1;
   SpiceDouble         * m2;
   SpiceDouble         * mout;

   struct argcheck argcheck[] =
      {
      { OREAD, "m1",   (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      { OREAD, "m2",   (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      { OWRIT, "mout", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_MXMT, m1[3,3], m2[3,3], MOUT[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   m1         = A_DBL_ARGV( 0 );
   m2         = A_DBL_ARGV( 1 );
   mout       = A_DBL_ARGV( 2 );

   mxmt_c( (Nx3d)m1,
           (Nx3d)m2,
           (SpiceDouble      (*)[3])mout  );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              mxv_c    ( ConstSpiceDouble    m1[3][3],
                                ConstSpiceDouble    vin[3],
                                SpiceDouble         vout[3] )
*/
PROCEDURE CSPICE_MXV(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * m1;
   SpiceDouble         * vin;
   SpiceDouble         * vout;

   struct argcheck argcheck[] =
      {
      { OREAD, "m1",   (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      { OREAD, "vin",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "vout", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


  /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_MXV, m1[3,3], vin[3], VOUT[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   m1         = A_DBL_ARGV( 0 );
   vin        = A_DBL_ARGV( 1 );
   vout       = A_DBL_ARGV( 2 );

   mxv_c((Nx3d)m1,vin,vout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              namfrm_c ( ConstSpiceChar    * frname,
                                SpiceInt          * frcode )
*/
PROCEDURE CSPICE_NAMFRM(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * frname;
   SpiceInt              frcode;

   struct argcheck argcheck[] =
      {
      { OREAD, "frname", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "frcode", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_NAMFRM, `frname`, FRCODE");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   frname = S_STR_ARGV( 0 );

   namfrm_c( frname, &frcode);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.l = frcode;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              nearpt_c ( ConstSpiceDouble    positn[3],
                                SpiceDouble         a,
                                SpiceDouble         b,
                                SpiceDouble         c,
                                SpiceDouble         npoint[3],
                                SpiceDouble       * alt        )
*/
PROCEDURE CSPICE_NEARPT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * positn;
   SpiceDouble           a;
   SpiceDouble           b;
   SpiceDouble           c;
   SpiceDouble         * npoint;
   SpiceDouble           alt;

   struct argcheck argcheck[] =
      {
      { OREAD, "positn", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "a",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "b",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "c",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "npoint", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "alt",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_NEARPT, positn[3], a, b, c, NPOINT[3], ALT");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   positn  = A_DBL_ARGV( 0 );
   a       = S_DBL_ARGV( 1 );
   b       = S_DBL_ARGV( 2 );
   c       = S_DBL_ARGV( 3 );
   npoint  = A_DBL_ARGV( 4 );

   nearpt_c( positn,
             a,
             b,
             c,
             npoint,
             &alt);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[5]->value.d = alt;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              npedln_c ( SpiceDouble         a,
                                SpiceDouble         b,
                                SpiceDouble         c,
                                ConstSpiceDouble    linept[3],
                                ConstSpiceDouble    linedr[3],
                                SpiceDouble         pnear[3],
                                SpiceDouble       * dist      )
*/
PROCEDURE CSPICE_NPEDLN(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble           a;
   SpiceDouble           b;
   SpiceDouble           c;
   SpiceDouble         * linept;
   SpiceDouble         * linedr;
   SpiceDouble         * pnear;
   SpiceDouble           dist;

   struct argcheck argcheck[] =
      {
      { OREAD, "a",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "b",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "c",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "linept", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "linedr", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "pnear",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "dist",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_NPEDLN, a, b, c, linept[3], linedr[3], "
                    "PNEAR[3], DIST");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   a          = S_DBL_ARGV( 0 );
   b          = S_DBL_ARGV( 1 );
   c          = S_DBL_ARGV( 2 );
   linept     = A_DBL_ARGV( 3 );
   linedr     = A_DBL_ARGV( 4 );
   pnear      = A_DBL_ARGV( 5 );

   npedln_c( a,
             b,
             c,
             linept,
             linedr,
             pnear,
             &dist);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[6]->value.d = dist;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              npelpt_c ( ConstSpiceDouble    point[3],
                                ConstSpiceEllipse * ellips,
                                SpiceDouble         pnear[3],
                                SpiceDouble       * dist      )
*/
PROCEDURE CSPICE_NPELPT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * point;
   SpiceEllipse        * ellips;
   SpiceDouble         * pnear;
   SpiceDouble           dist;

   struct argcheck argcheck[] =
      {
      { OREAD, "point",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "ellips", (void*)IDL_TYP_STRUCT,  0, { 0 },    0},
      { OWRIT, "pnear",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "dist",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_NPELPT, point[3], ellips, PNEAR[3], DIST");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[1].type = s_SpiceEllipse;

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   point      = A_DBL_ARGV( 0 );
   ellips     = S_ELL_ARGV( 1 );
   pnear      = A_DBL_ARGV( 2 );

   npelpt_c( point,
             ellips,
             pnear,
             &dist);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[3]->value.d = dist;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              nplnpt_c ( ConstSpiceDouble    linpt  [3],
                                ConstSpiceDouble    lindir [3],
                                ConstSpiceDouble    point  [3],
                                SpiceDouble         pnear  [3],
                                SpiceDouble       * dist       )
*/
PROCEDURE CSPICE_NPLNPT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * linpt;
   SpiceDouble         * lindir;
   SpiceDouble         * point;
   SpiceDouble         * pnear;
   SpiceDouble           dist;

   struct argcheck argcheck[] =
      {
      { OREAD, "linpt",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "lindir", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "point",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "pnear",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "dist",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 5)
      {
      USAGE("CSPICE_NPLNPT, linpt[3], lindir[3], point[3], "
                    "PNEAR[3], DIST");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   linpt   = A_DBL_ARGV( 0 );
   lindir  = A_DBL_ARGV( 1 );
   point   = A_DBL_ARGV( 2 );
   pnear   = A_DBL_ARGV( 3 );

   nplnpt_c( linpt,
             lindir,
             point,
             pnear,
             &dist);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[4]->value.d = dist;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   }




/*
   void              nvc2pl_c ( ConstSpiceDouble    normal[3],
                                SpiceDouble         constant,
                                SpicePlane        * plane     )
*/
PROCEDURE CSPICE_NVC2PL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * normal;
   SpiceDouble           constant;
   SpicePlane          * plane;

   struct argcheck argcheck[] =
      {
      { OREAD, "normal",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "constant", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "plane",    (void*)IDL_TYP_STRUCT,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_NVC2PL, normal[3], constant, PLANE");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[2].type = s_SpicePlane;

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   normal     = A_DBL_ARGV( 0 );
   constant   = S_DBL_ARGV( 1 );
   plane      = S_PLN_ARGV( 2 );

   nvc2pl_c(normal,constant,plane);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              nvp2pl_c ( ConstSpiceDouble    normal[3],
                                ConstSpiceDouble    point[3],
                                SpicePlane        * plane     )
*/
PROCEDURE CSPICE_NVP2PL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * normal;
   SpiceDouble         * point;
   SpicePlane          * plane;

   struct argcheck argcheck[] =
      {
      { OREAD, "normal", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "point",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "plane",  (void*)IDL_TYP_STRUCT,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_NVP2PL, normal[3], point[3], PLANE");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[2].type = s_SpicePlane;

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   normal     = A_DBL_ARGV( 0 );
   point      = A_DBL_ARGV( 1 );
   plane      = S_PLN_ARGV( 2 );

   nvp2pl_c(normal,point,plane);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void occult_c ( ConstSpiceChar   * target1,
                   ConstSpiceChar   * shape1,
                   ConstSpiceChar   * frame1,
                   ConstSpiceChar   * target2,
                   ConstSpiceChar   * shape2,
                   ConstSpiceChar   * frame2,
                   ConstSpiceChar   * abcorr,
                   ConstSpiceChar   * observer,
                   SpiceDouble        et,
                   SpiceInt         * occult_code )
*/

PROCEDURE CSPICE_OCCULT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * target1;
   SpiceChar           * shape1;
   SpiceChar           * frame1;
   SpiceChar           * target2;
   SpiceChar           * shape2;
   SpiceChar           * frame2;
   SpiceChar           * abcorr;
   SpiceChar           * observer;
   SpiceDouble           et;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "target1",     (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "shape1",      (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "frame1",      (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "target2",     (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "shape2",      (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "frame2",      (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "abcorr",      (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "observer",    (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",          (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "occult_code", (void*)IDL_TYP_LONG,    0, { 0 },    1},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 10)
      {
      USAGE("CSPICE_OCCULT, `target1`, `shape1`, `frame1`, "
            " `target2`, `shape2`, `frame2`, `abcorr`, `observer`"
            " _et_, _OCCULT_CODE_" );

      }
   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   target1     = S_STR_ARGV( 0 );
   shape1      = S_STR_ARGV( 1 );
   frame1      = S_STR_ARGV( 2 );
   target2     = S_STR_ARGV( 3 );
   shape2      = S_STR_ARGV( 4 );
   frame2      = S_STR_ARGV( 5 );
   abcorr      = S_STR_ARGV( 6 );
   observer    = S_STR_ARGV( 7 );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
    */
   if (extra->ndims == 0)
      {

      SpiceInt             occult_code;

      et  = S_DBL_ARGV( 8 );
      occult_code = S_INT_ARGV( 9 );

      /*occult_code = S_INT_ARGV( 9 ); */

      occult_c( target1,
                shape1,
                frame1,
                target2,
                shape2,
                frame2,
                abcorr,
                observer,
                et,
                &occult_code );
      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      Argv[9]->value.l = occult_code;

      }
   else
      {
      SpiceInt         * occult_code;

      occult_code = A_INT_ARGV( 9 );
      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         et = ((SpiceDouble*)(Argv[8]->value.arr->data))[i];

         occult_c(  target1,
                    shape1,
                    frame1,
                    target2,
                    shape2,
                    frame2,
                    abcorr,
                    observer,
                    et,
                    (occult_code +i) );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   }




/*
   void              oscelt_c ( ConstSpiceDouble    state[6],
                                SpiceDouble         et,
                                SpiceDouble         mu,
                                SpiceDouble         elts[8]  )
*/
PROCEDURE CSPICE_OSCELT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * state;
   SpiceDouble          et;
   SpiceDouble          mu;
   SpiceDouble        * elts;

   long                 i;

   struct argcheck argcheck[] =
      {
      { OREAD, "state", (void*)IDL_TYP_DOUBLE,  1, { 6 },    1},
      { OREAD, "et",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "mu",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "elts",  (void*)IDL_TYP_DOUBLE,  1, { 8 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_OSCELT, _state[6]_, _et_, mu, _ELTS[8]_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   mu   = S_DBL_ARGV( 2 );
   elts = A_DBL_ARGV( 3 );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
    */
   if (extra->ndims == 0)
      {

      state = A_DBL_ARGV( 0 );
      et    = S_DBL_ARGV( 1 );

      oscelt_c(state,et,mu,elts);

      /*
      Test for a SPICE error signal. If found, display an error message to the
      user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );
      }
   else
      {
      /* Vector input. */
      state  =  (SpiceDouble*)(Argv[0]->value.arr->data) ;

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         et = ((SpiceDouble*)(Argv[1]->value.arr->data))[i];

         oscelt_c( (state +i*6), et, mu, (elts + i*8));

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
 void              pckcov_c ( ConstSpiceChar  * pck,
                              SpiceInt          idcode,
                              SpiceCell       * cover   )

 */
PROCEDURE CSPICE_PCKCOV(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset;
   SpiceChar            * pck;
   SpiceInt               idcode;
   SpiceCell              cover;

   struct argcheck argcheck[] =
      {
      { OREAD, "pck",    (void*)IDL_TYP_STRING, 0, { 0 }, 0},
      { OREAD, "idcode", (void*)IDL_TYP_LONG,   0, { 0 }, 0},
      { RDWRT, "cover",  (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_PCKCOV, `pck`, idcode, (COVER)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[2].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   pck    = S_STR_ARGV( 0 );
   idcode = S_INT_ARGV( 1 );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[2]->value.s.arr->data);
   pack_cell( &cover, 2, tag_offset, Argv );

   (void) pckcov_c ( pck, idcode, &cover );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( cover, SCALAR );

   /*
   Unpack the data from 'cover' to 'Argv'.
   */
   unpack_cell( 2, tag_offset, &cover, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
 void              pckfrm_c ( ConstSpiceChar  * pck,
                              SpiceCell       * ids )

*/
PROCEDURE CSPICE_PCKFRM(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset;
   SpiceChar            * pck;
   SpiceCell              ids;

   struct argcheck argcheck[] =
      {
      { OREAD, "pck", (void*)IDL_TYP_STRING, 0, { 0 }, 0},
      { RDWRT, "ids", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_pckfrm, pck, (IDS)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[1].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   pck = S_STR_ARGV( 0 );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[1]->value.s.arr->data);
   pack_cell( &ids, 1, tag_offset, Argv );

   pckfrm_c ( pck, &ids );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( ids, SCALAR );

   /*
   Unpack the data from 'ids' to 'Argv'.
   */
   unpack_cell( 1, tag_offset, &ids, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              pcklof_c ( ConstSpiceChar    * fname,
                                SpiceInt          * handle )
*/
PROCEDURE CSPICE_PCKLOF(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * fname;
   SpiceInt              handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "fname",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_PCKLOF, `fname`, HANDLE");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   fname = S_STR_ARGV( 0 );

   pcklof_c( fname, &handle);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.l = handle;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              pckuof_c ( SpiceInt            handle )
*/
PROCEDURE CSPICE_PCKUOF(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_PCKUOF, handle");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle  = S_INT_ARGV( 0 );

   pckuof_c(handle);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              pcpool_c ( ConstSpiceChar   * name,
                                SpiceInt           n,
                                SpiceInt           lenvals,
                                const void       * cvals    )
*/
PROCEDURE CSPICE_PCPOOL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * name;
   SpiceChar         ** cvals;
   SpiceInt             cvals_size;
   SpiceInt             cvals_len;
   long                 i;

   struct argcheck argcheck[] =
      {
      { OREAD, "name",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "length", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "cvals",  (void*)IDL_TYP_STRING,  1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_PCPOOL, `name`, length, cvals[]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Retrieve input array dimensions (to pass on to C) */
   cvals_size = A_LEN_ARGV(2);

   /* Initialize local variables, to pass to CSPICE */
   name       = S_STR_ARGV(0);
   cvals_len  = S_INT_ARGV(1) + 1;

   cvals = alloc_SpiceString_C_array ( cvals_len, cvals_size );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Initialize local variables, to pass to CSPICE */
   for (i=0; i < cvals_size; i++)
      {
      strncpy( *cvals + i*cvals_len,
               IDL_STRING_STR(&((IDL_STRING*)(Argv[2]->value.arr->data))[i]),
               cvals_len);
      }

   pcpool_c(name,cvals_size,cvals_len,*cvals);

   CHECK_CALL_FAILURE_MEM ( 1, cvals );

   /* Clean up temporary variables */
   free_SpiceString_C_array ( 1, cvals );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              pdpool_c ( ConstSpiceChar    * name,
                                SpiceInt            n,
                                ConstSpiceDouble  * dvals )
*/
PROCEDURE CSPICE_PDPOOL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * name;
   SpiceInt             dvals_size;
   ConstSpiceDouble   * dvals;

   struct argcheck argcheck[] =
      {
      { OREAD, "name",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "dvals", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_PDPOOL, `name`, dvals[]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Retrieve input array dimensions (to pass on to C) */
   dvals_size = A_LEN_ARGV(1);

   /* Initialize local variables, to pass to CSPICE */
   name   = S_STR_ARGV( 0 );
   dvals  = (ConstSpiceDouble*)Argv[1]->value.arr->data;

   pdpool_c( name, dvals_size, dvals);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*

 void               pgrrec_c ( ConstSpiceChar  * body,
                               SpiceDouble       lon,
                               SpiceDouble       lat,
                               SpiceDouble       alt,
                               SpiceDouble       re,
                               SpiceDouble       f,
                               SpiceDouble       rectan[3] )

*/
PROCEDURE CSPICE_PGRREC(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceChar            * body;
   SpiceDouble            lon;
   SpiceDouble            lat;
   SpiceDouble            alt;
   SpiceDouble            re;
   SpiceDouble            f;
   SpiceDouble          * rectan;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "body",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "lon",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "lat",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "alt",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "re",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "f",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "rectan", (void*)IDL_TYP_DOUBLE,  1, { 3 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_PGRREC, `body`, _lon_, _lat_, _alt_, re, f, "
                    "_RECTAN[3]_");
      }

   /*
    Perform the input argument type checks, allocate any needed
    memory for output args, copy the argument vector to a work copy.
    */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   body    = S_STR_ARGV( 0 );
   re      = S_DBL_ARGV( 4 );
   f       = S_DBL_ARGV( 5 );
   rectan  = A_DBL_ARGV( 6 );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
   */
   if (extra->ndims == 0)
      {
      /* Scalar input. */
      lon = S_DBL_ARGV( 1 );
      lat = S_DBL_ARGV( 2 );
      alt = S_DBL_ARGV( 3 );

      pgrrec_c(body,lon,lat,alt,re,f,rectan);

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      }
   else
      {
      /* Vector input. */

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         lon  = ((SpiceDouble*)(Argv[1]->value.arr->data))[i];
         lat  = ((SpiceDouble*)(Argv[2]->value.arr->data))[i];
         alt  = ((SpiceDouble*)(Argv[3]->value.arr->data))[i];

         pgrrec_c( body, lon, lat, alt, re, f, (rectan+i*3) );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceDouble       phaseq_c ( SpiceDouble       et,
                                ConstSpiceChar  * target,
                                ConstSpiceChar  * illumn,
                                ConstSpiceChar  * obsrvr,
                                ConstSpiceChar  * abcorr );
*/
FUNCTION CSPICE_PHASEQ(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceDouble          retval_c;
   SpiceDouble          et;
   SpiceChar          * target;
   SpiceChar          * illumn;
   SpiceChar          * obsrvr;
   SpiceChar          * abcorr;

   struct argcheck argcheck[] =
      {
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "illumn", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 5)
      {
      USAGE("double  = CSPICE_PHASEQ( et, `target`,"
                                   " `illumn`, `obsrvr`, `abcorr` )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   et     = S_DBL_ARGV( 0 );
   target = S_STR_ARGV( 1 );
   illumn = S_STR_ARGV( 2 );
   obsrvr = S_STR_ARGV( 3 );
   abcorr = S_STR_ARGV( 4 );

   retval_c =  phaseq_c ( et, target, illumn, obsrvr, abcorr );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*

    SpiceDouble       pi_c     ( void )

*/
FUNCTION CSPICE_PI(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR     retval_idl;
   SpiceDouble  retval_c;

   /* Check the input contains the correct number of arguments. */
   if (Argc != 0)
      {
      USAGE("double  = CSPICE_PI()");
      }

   retval_c = pi_c();

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   return retval_idl;
   }




/*
   void              pipool_c ( ConstSpiceChar    * name,
                                SpiceInt            n,
                                ConstSpiceInt     * ivals )
*/
PROCEDURE CSPICE_PIPOOL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * name;
   SpiceInt             ivals_size;
   ConstSpiceInt      * ivals;

   struct argcheck argcheck[] =
      {
      { OREAD, "name",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "ivals", (void*)IDL_TYP_LONG,    1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_PIPOOL, `name`, ivals[]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Retrieve input array dimensions (to pass on to C) */
   ivals_size = A_LEN_ARGV(1);

   /* Initialize local variables, to pass to CSPICE */
   name   = S_STR_ARGV( 0 );
   ivals  = (ConstSpiceInt*)Argv[1]->value.arr->data;

   pipool_c(name,ivals_size,ivals);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              pjelpl_c ( ConstSpiceEllipse * elin,
                                ConstSpicePlane   * plane,
                                SpiceEllipse      * elout  )
*/
PROCEDURE CSPICE_PJELPL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceEllipse        * elin;
   SpicePlane          * plane;
   SpiceEllipse        * elout;

   struct argcheck argcheck[] =
      {
      { OREAD, "elin",  (void*)IDL_TYP_STRUCT,  0, { 0 },    0},
      { OREAD, "plane", (void*)IDL_TYP_STRUCT,  0, { 0 },    0},
      { OWRIT, "elout", (void*)IDL_TYP_STRUCT,  0, { 0 },    0},
    };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_PJELPL, elin, plane, ELOUT");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[0].type = s_SpiceEllipse;
   argcheck[1].type = s_SpicePlane;
   argcheck[2].type = s_SpiceEllipse;

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   elin   = S_ELL_ARGV( 0 );
   plane  = S_PLN_ARGV( 1 );
   elout  = S_ELL_ARGV( 2 );

   pjelpl_c(elin,plane,elout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              pl2nvc_c ( ConstSpicePlane   * plane,
                                SpiceDouble         normal[3],
                                SpiceDouble       * constant  )
*/
PROCEDURE CSPICE_PL2NVC(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpicePlane          * plane;
   SpiceDouble         * normal;
   SpiceDouble           constant;

   struct argcheck argcheck[] =
      {
      { OREAD, "plane",    (void*)IDL_TYP_STRUCT,  0, { 0 },    0},
      { OWRIT, "normal",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "constant", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_PL2NVC, plane, NORMAL[3], CONSTANT");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[0].type = s_SpicePlane;

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   plane      = S_PLN_ARGV( 0 );
   normal     = A_DBL_ARGV( 1 );

   pl2nvc_c( plane,
             normal,
             &constant);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[2]->value.d = constant;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              pl2nvp_c ( ConstSpicePlane   * plane,
                                SpiceDouble         normal[3],
                                SpiceDouble         point[3]  )
*/
PROCEDURE CSPICE_PL2NVP(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpicePlane         * plane;
   SpiceDouble        * normal;
   SpiceDouble        * point;

   struct argcheck argcheck[] =
      {
      { OREAD, "plane",  (void*)IDL_TYP_STRUCT,  0, { 0 },    0},
      { OWRIT, "normal", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "point",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_PL2NVP, plane, NORMAL[3], POINT[3]");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[0].type = s_SpicePlane;

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   plane   = S_PLN_ARGV( 0 );
   normal  = A_DBL_ARGV( 1 );
   point   = A_DBL_ARGV( 2 );

   pl2nvp_c(plane,normal,point);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              pl2psv_c ( ConstSpicePlane   * plane,
                                SpiceDouble         point[3],
                                SpiceDouble         span1[3],
                                SpiceDouble         span2[3]  )
*/
PROCEDURE CSPICE_PL2PSV(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpicePlane         * plane;
   SpiceDouble        * point;
   SpiceDouble        * span1;
   SpiceDouble        * span2;

  struct argcheck argcheck[] =
     {
     { OREAD, "plane", (void*)IDL_TYP_STRUCT,  0, { 0 },    0},
     { OWRIT, "point", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
     { OWRIT, "span1", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
     { OWRIT, "span2", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
     };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_PL2PSV, plane, POINT[3], SPAN1[3], SPAN2[3]");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[0].type = s_SpicePlane;

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   plane  = S_PLN_ARGV( 0 );
   point  = A_DBL_ARGV( 1 );
   span1  = A_DBL_ARGV( 2 );
   span2  = A_DBL_ARGV( 3 );

   pl2psv_c( plane, point, span1, span2);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceDouble       pltar_c  ( SpiceInt           nv,
                                ConstSpiceDouble   vrtces [][3],
                                SpiceInt           np,
                                ConstSpiceInt      plates [][3]  );
*/
FUNCTION CSPICE_PLTAR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl = NULL;
   SpiceInt             nv = 0;
   SpiceDouble        * vrtces;
   SpiceInt             np = 0;
   SpiceInt           * plates;
   SpiceDouble          pltar;

   struct argcheck argcheck[] =
      {
      { OREAD, "vrtces", (void*)IDL_TYP_DOUBLE, 2, { 3, 0 }, 0},
      { OREAD, "plates", (void*)IDL_TYP_LONG,   2, { 3, 0 }, 0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("double = CSPICE_PLTAR( vrtces[3,NV], plates[3,NP] )" );
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   vrtces     =  A_DBL_ARGV( 0 );
   plates     =  A_INT_ARGV( 1 );

   nv         =  Argv[0]->value.arr->dim[1];
   np         =  Argv[1]->value.arr->dim[1];

   pltar = pltar_c( nv,
                    (Nx3d)vrtces,
                    np,
                    (Nx3i)plates );

   /*
   Test for a SPICE error signal, if found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = pltar;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              pltexp_c ( ConstSpiceDouble   iverts[3][3],
                                SpiceDouble        delta,
                                SpiceDouble        overts[3][3] )
*/
PROCEDURE CSPICE_PLTEXP(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * iverts;
   SpiceDouble          delta;
   SpiceDouble        * overts;

   struct argcheck argcheck[] =
      {
      { OREAD, "iverts", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      { OREAD, "delta",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "overts", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_PLTEXP, iverts[3,3], delta, OVERTS[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   iverts     = A_DBL_ARGV( 0 );
   delta      = S_DBL_ARGV( 1 );
   overts     = A_DBL_ARGV( 2 );

   pltexp_c( (Nx3d)iverts, delta, (SpiceDouble (*)[3])overts);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              pltnp_c ( ConstSpiceDouble    point[3],
                               ConstSpiceDouble    v1   [3],
                               ConstSpiceDouble    v2   [3],
                               ConstSpiceDouble    v3   [3],
                               SpiceDouble         pnear[3],
                               SpiceDouble       * dist      )
*/
PROCEDURE CSPICE_PLTNP(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble        * point;
   SpiceDouble        * v1;
   SpiceDouble        * v2;
   SpiceDouble        * v3;
   SpiceDouble        * pnear;
   SpiceDouble          dist;


   struct argcheck argcheck[] =
      {
      { OREAD, "point", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "v1",    (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "v2",    (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "v3",    (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "pnear", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "dist",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_PLTNP, point[3], v1[3], v2[3], v3[3], PNEAR[3], DIST");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   point = A_DBL_ARGV( 0 );
   v1    = A_DBL_ARGV( 1 );
   v2    = A_DBL_ARGV( 2 );
   v3    = A_DBL_ARGV( 3 );
   pnear = A_DBL_ARGV( 4 );

   pltnp_c ( point, v1, v2, v3, pnear, &dist );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[5]->value.d = dist;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              pltnrm_c ( ConstSpiceDouble    v1[3],
                                ConstSpiceDouble    v2[3],
                                ConstSpiceDouble    v3[3],
                                SpiceDouble         normal[3] )
*/
PROCEDURE CSPICE_PLTNRM(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble        * v1;
   SpiceDouble        * v2;
   SpiceDouble        * v3;
   SpiceDouble        * normal;


   struct argcheck argcheck[] =
      {
      { OREAD, "v1",     (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "v2",     (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "v3",     (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "normal", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_PLTNRM, v1[3], v2[3], v3[3], NORMAL[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   v1     = A_DBL_ARGV( 0 );
   v2     = A_DBL_ARGV( 1 );
   v3     = A_DBL_ARGV( 2 );
   normal = A_DBL_ARGV( 3 );

   pltnrm_c ( v1, v2, v3, normal );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceDouble       pltvol_c ( SpiceInt           nv,
                                ConstSpiceDouble   vrtces [][3],
                                SpiceInt           np,
                                ConstSpiceInt      plates [][3]  );
*/
FUNCTION CSPICE_PLTVOL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl = NULL;
   SpiceInt             nv = 0;
   SpiceDouble        * vrtces;
   SpiceInt             np = 0;
   SpiceInt           * plates;
   SpiceDouble          pltvol;

   struct argcheck argcheck[] =
      {
      { OREAD, "vrtces", (void*)IDL_TYP_DOUBLE, 2, { 3, 0 }, 0},
      { OREAD, "plates", (void*)IDL_TYP_LONG,   2, { 3, 0 }, 0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("double = CSPICE_PLTVOL( vrtces[3,NV], plates[3,NP] )" );
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   vrtces     =  A_DBL_ARGV( 0 );
   plates     =  A_INT_ARGV( 1 );

   nv         =  Argv[0]->value.arr->dim[1];
   np         =  Argv[1]->value.arr->dim[1];

   pltvol = pltvol_c( nv,
                    (Nx3d)vrtces,
                    np,
                    (Nx3i)plates );

   /*
   Test for a SPICE error signal, if found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = pltvol;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              prop2b_c ( SpiceDouble         gm,
                                ConstSpiceDouble    pvinit[6],
                                SpiceDouble         dt,
                                SpiceDouble         pvprop[6] )
*/
PROCEDURE CSPICE_PROP2B(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          gm;
   SpiceDouble        * pvinit;
   SpiceDouble          dt;
   SpiceDouble        * pvprop;

   struct argcheck argcheck[] =
      {
      { OREAD, "gm",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "pvinit", (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      { OREAD, "dt",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "pvprop", (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_PROP2B, gm, pvinit[6], dt, PVPROP[6]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   gm      = S_DBL_ARGV( 0 );
   pvinit  = A_DBL_ARGV( 1 );
   dt      = S_DBL_ARGV( 2 );
   pvprop  = A_DBL_ARGV( 3 );

   prop2b_c( gm, pvinit, dt, pvprop);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              prsdp_c  ( ConstSpiceChar    * string,
                                SpiceDouble       * dpval  )
*/
PROCEDURE CSPICE_PRSDP(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * string;
   SpiceDouble           dpval;

   struct argcheck argcheck[] =
      {
      { OREAD, "string", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "dpval",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_PRSDP, `string`, DPVAL");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   string  = S_STR_ARGV( 0 );

   prsdp_c( string, &dpval);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.d = dpval;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              prsint_c ( ConstSpiceChar    * string,
                                SpiceInt          * intval )
*/
PROCEDURE CSPICE_PRSINT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * string;
   SpiceInt              intval;

   struct argcheck argcheck[] =
      {
      { OREAD, "string", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "intval", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_PRSINT, `string`, INTVAL");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   string  = S_STR_ARGV( 0 );

   prsint_c( string, &intval);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.l = intval;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              psv2pl_c ( ConstSpiceDouble    point[3],
                                ConstSpiceDouble    span1[3],
                                ConstSpiceDouble    span2[3],
                                SpicePlane        * plane     )
*/
PROCEDURE CSPICE_PSV2PL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * point;
   SpiceDouble         * span1;
   SpiceDouble         * span2;
   SpicePlane          * plane;

   struct argcheck argcheck[] =
      {
      { OREAD, "point", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "span1", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "span2", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "plane", (void*)IDL_TYP_STRUCT,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_PSV2PL, point[3], span1[3], span2[3], PLANE");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[3].type = s_SpicePlane;

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   point = A_DBL_ARGV( 0 );
   span1 = A_DBL_ARGV( 1 );
   span2 = A_DBL_ARGV( 2 );
   plane = S_PLN_ARGV( 3 );

   psv2pl_c( point, span1, span2, plane);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              pxform_c ( ConstSpiceChar    * from,
                                ConstSpiceChar    * to,
                                SpiceDouble         et,
                                SpiceDouble         rotate[3][3] )
*/
PROCEDURE CSPICE_PXFORM(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR          * Argv;
   struct extra_dims * extra;
   SpiceChar         * from;
   SpiceChar         * to;
   SpiceDouble         et;
   SpiceDouble       * rotate;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "from",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "to",     (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "rotate", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_PXFORM, `from`, `to`, _et_, _ROTATE[3,3]_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   from   = S_STR_ARGV( 0 );
   to     = S_STR_ARGV( 1 );
   rotate = A_DBL_ARGV( 3 );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
   */
   if (extra->ndims == 0)
      {
      /* Scalar input. */
      et = S_DBL_ARGV( 2 );

      pxform_c( from,
                to,
                et,
                (SpiceDouble (*)[3])rotate);

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );
      }
   else
      {
      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         et = ((SpiceDouble*)(Argv[2]->value.arr->data))[i];

         pxform_c( from,
                   to,
                   et,
                   (SpiceDouble (*)[3])(rotate + i*9) );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              pxfrm2_c ( ConstSpiceChar    * from,
                                ConstSpiceChar    * to,
                                SpiceDouble         etfrom,
                                SpiceDouble         etto,
                                SpiceDouble         rotate[3][3] )
*/
PROCEDURE CSPICE_PXFRM2(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR          * Argv;
   struct extra_dims * extra;
   SpiceChar         * from;
   SpiceChar         * to;
   SpiceDouble         etfrom;
   SpiceDouble         etto;
   SpiceDouble       * rotate;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "from",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "to",     (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "etfrom", (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "etto",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "rotate", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 5)
      {
      USAGE("CSPICE_PXFRM2, `from`, `to`, _etfrom_, _etto_,  _ROTATE[3,3]_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   from   = S_STR_ARGV( 0 );
   to     = S_STR_ARGV( 1 );
   rotate = A_DBL_ARGV( 4 );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
   */
   if (extra->ndims == 0)
      {
      /* Scalar input. */
      etfrom = S_DBL_ARGV( 2 );
      etto   = S_DBL_ARGV( 3 );

      pxfrm2_c( from,
                to,
                etfrom,
                etto,
                (SpiceDouble (*)[3])rotate);

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );
      }
   else
      {
      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         etfrom = ((SpiceDouble*)(Argv[2]->value.arr->data))[i];
         etto   = ((SpiceDouble*)(Argv[3]->value.arr->data))[i];

         pxfrm2_c( from,
                   to,
                   etfrom,
                   etto,
                   (SpiceDouble (*)[3])(rotate + i*9) );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              q2m_c    ( ConstSpiceDouble    q[4],
                                SpiceDouble         r[3][3] )
*/
PROCEDURE CSPICE_Q2M(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * q;
   SpiceDouble         * r;

   struct argcheck argcheck[] =
      {
      { OREAD, "q", (void*)IDL_TYP_DOUBLE,  1, { 4 },    0},
      { OWRIT, "r", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_Q2M, q[4], R[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   q  = A_DBL_ARGV( 0 );
   r  = A_DBL_ARGV( 1 );

   q2m_c(q,(SpiceDouble (*)[3])r);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              qdq2av_c ( ConstSpiceDouble    q  [4],
                                ConstSpiceDouble    dq [4],
                                SpiceDouble         av [3]  )
*/
PROCEDURE CSPICE_QDQ2AV(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * q;
   SpiceDouble         * dq;
   SpiceDouble         * av;

  struct argcheck argcheck[] =
      {
      { OREAD, "q",  (void*)IDL_TYP_DOUBLE,  1, { 4 }, 0},
      { OREAD, "dq", (void*)IDL_TYP_DOUBLE,  1, { 4 }, 0},
      { OWRIT, "av", (void*)IDL_TYP_DOUBLE,  1, { 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_QDQ2AV, q[4], dq[4], AV[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   q  = A_DBL_ARGV( 0 );
   dq = A_DBL_ARGV( 1 );
   av = A_DBL_ARGV( 2 );

   qdq2av_c ( q,  dq, av );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              qxq_c ( ConstSpiceDouble    q1   [4],
                             ConstSpiceDouble    q2   [4],
                             SpiceDouble         qout [4]  )
*/
PROCEDURE CSPICE_QXQ(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * q1;
   SpiceDouble         * q2;
   SpiceDouble         * qout;

  struct argcheck argcheck[] =
      {
      { OREAD, "q1",   (void*)IDL_TYP_DOUBLE,  1, { 4 }, 0},
      { OREAD, "q2",   (void*)IDL_TYP_DOUBLE,  1, { 4 }, 0},
      { OWRIT, "qout", (void*)IDL_TYP_DOUBLE,  1, { 4 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_QXQ, q1[4], q2[4], QOUT[4]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   q1   = A_DBL_ARGV( 0 );
   q2   = A_DBL_ARGV( 1 );
   qout = A_DBL_ARGV( 2 );

   qxq_c( q1,q2, qout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              radrec_c ( SpiceDouble         range,
                                SpiceDouble         ra,
                                SpiceDouble         dec,
                                SpiceDouble         rectan[3] )
*/
PROCEDURE CSPICE_RADREC(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceDouble            range;
   SpiceDouble            ra;
   SpiceDouble            dec;
   SpiceDouble          * rectan;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "range",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "ra",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "dec",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "rectan", (void*)IDL_TYP_DOUBLE,  1, { 3 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_RADREC, _range_, _ra_, _dec_, _RECTAN[3]_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   rectan  = A_DBL_ARGV( 3 );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
   */
   if (extra->ndims == 0)
      {
      /* Scalar input. */
      range = S_DBL_ARGV( 0 );
      ra    = S_DBL_ARGV( 1 );
      dec   = S_DBL_ARGV( 2 );

      radrec_c(range,ra,dec,rectan);

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );
      }
   else
      {
      /* Vector input. */

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         range = ((SpiceDouble*)(Argv[0]->value.arr->data))[i];
         ra    = ((SpiceDouble*)(Argv[1]->value.arr->data))[i];
         dec   = ((SpiceDouble*)(Argv[2]->value.arr->data))[i];

         radrec_c(range,ra,dec,(rectan+i*3) );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              rav2xf_c ( ConstSpiceDouble     rot   [3][3],
                                ConstSpiceDouble     av    [3],
                                SpiceDouble          xform [6][6]  )
*/
PROCEDURE CSPICE_RAV2XF(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * rot;
   SpiceDouble        * av;
   SpiceDouble        * xform;

   struct argcheck argcheck[] =
      {
      { OREAD, "rot",   (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      { OREAD, "av",    (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "xform", (void*)IDL_TYP_DOUBLE,  2, { 6, 6 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_RAV2XF, rot[3,3], av[3], XFORM[6,6]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   rot    = A_DBL_ARGV( 0 );
   av     = A_DBL_ARGV( 1 );
   xform  = A_DBL_ARGV( 2 );

   rav2xf_c((Nx3d)rot,av,(SpiceDouble (*)[6])xform);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              raxisa_c ( ConstSpiceDouble     matrix[3][3],
                                SpiceDouble          axis  [3],
                                SpiceDouble        * angle       )
*/
PROCEDURE CSPICE_RAXISA(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceDouble          * matrix;
   SpiceDouble          * axis;
   SpiceDouble            angle;

   struct argcheck argcheck[] =
      {
      { OREAD, "matrix", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      { OWRIT, "axis",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "angle",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_RAXISA, matrix[3,3], AXIS[3], ANGLE");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   matrix  = A_DBL_ARGV( 0 );
   axis    = A_DBL_ARGV( 1 );

   raxisa_c( (Nx3d)matrix,
            axis,
            &angle);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[2]->value.d = angle;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              reccyl_c ( ConstSpiceDouble    rectan[3],
                                SpiceDouble       * r,
                                SpiceDouble       * lon,
                                SpiceDouble       * z         )
*/
PROCEDURE CSPICE_RECCYL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceDouble          * rectan;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "rectan", (void*)IDL_TYP_DOUBLE,  1, { 3 },    1},
      { OWRIT, "r",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "lon",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "z",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_RECCYL, _rectan[3]_, _R_, _LON_, _Z_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
    */
   if (extra->ndims == 0)
      {

      /* Scalar input. */

      SpiceDouble            r;
      SpiceDouble            lon;
      SpiceDouble            z;

      rectan  = A_DBL_ARGV( 0 );

      reccyl_c( rectan, &r, &lon, &z);

      /*
      Test for a SPICE error signal. If found, display an error message to the
      user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      Argv[1]->value.d = r;
      Argv[2]->value.d = lon;
      Argv[3]->value.d = z;

      }
   else
      {

      /* Vector input. */

      SpiceDouble          * r;
      SpiceDouble          * lon;
      SpiceDouble          * z;

      rectan = (SpiceDouble*)(Argv[0]->value.arr->data) ;
      r      = A_DBL_ARGV(1);
      lon    = A_DBL_ARGV(2);
      z      = A_DBL_ARGV(3);

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         /*
         The 'rectan' vector has length 3 input to reccyl_c so increment
         the pointer to the data by factors of 3.
         */
         reccyl_c( (rectan + i*3),
                   (r      + i),
                   (lon    + i ),
                   (z      + i) );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              recgeo_c ( ConstSpiceDouble    rectan[3],
                                SpiceDouble         re,
                                SpiceDouble         f,
                                SpiceDouble       * lon,
                                SpiceDouble       * lat,
                                SpiceDouble       * alt )
*/
PROCEDURE CSPICE_RECGEO(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceDouble          * rectan;
   SpiceDouble            re;
   SpiceDouble            f;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "rectan", (void*)IDL_TYP_DOUBLE,  1, { 3 },    1},
      { OREAD, "re",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "f",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "lon",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "lat",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "alt",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_RECGEO, _rectan[3]_, re, f, _LON_, _LAT_, _ALT_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   re      = S_DBL_ARGV( 1 );
   f       = S_DBL_ARGV( 2 );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
    */
   if (extra->ndims == 0)
      {

      /* Scalar input. */

      SpiceDouble            lon;
      SpiceDouble            lat;
      SpiceDouble            alt;

      rectan  = A_DBL_ARGV( 0 );

      recgeo_c( rectan,
                re,
                f,
                &lon,
                &lat,
                &alt);

      /*
      Test for a SPICE error signal. If found, display an error message to the
      user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      Argv[3]->value.d = lon;
      Argv[4]->value.d = lat;
      Argv[5]->value.d = alt;

     }
   else
      {

      /* Vector input. */

      SpiceDouble          * lon;
      SpiceDouble          * lat;
      SpiceDouble          * alt;

      rectan  =  (SpiceDouble*)(Argv[0]->value.arr->data) ;
      lon     = A_DBL_ARGV(3);
      lat     = A_DBL_ARGV(4);
      alt     = A_DBL_ARGV(5);

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         /*
         The 'rectan' vector has length 3 input to recgeo_c so increment
         the pointer to the data by factors of 3.
         */
         recgeo_c( (rectan + i*3),
                   re,
                   f,
                   (lon+i),
                   (lat+i),
                   (alt+i));

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*

 void               recpgr_c ( ConstSpiceChar   * body,
                               SpiceDouble        rectan[3],
                               SpiceDouble        re,
                               SpiceDouble        f,
                               SpiceDouble      * lon,
                               SpiceDouble      * lat,
                               SpiceDouble      * alt       )

 */
PROCEDURE CSPICE_RECPGR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
{

   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceChar            * body;
   SpiceDouble          * rectan;
   SpiceDouble            re;
   SpiceDouble            f;


   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "body",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "rectan", (void*)IDL_TYP_DOUBLE,  1, { 3 },    1},
      { OREAD, "re",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "f",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "lon",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "lat",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "alt",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_RECPGR, body, _rectan[3]_, re, f, "
                    "_LON_, _LAT_, _ALT_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   body = S_STR_ARGV( 0 );
   re   = S_DBL_ARGV( 2 );
   f    = S_DBL_ARGV( 3 );

   /*
      Called with `vectorized' input arguments? Test the value of the 'extra'
    struct 'ndims' field.
    */
   if (extra->ndims == 0)
      {

      /* Scalar input. */

      SpiceDouble            lon;
      SpiceDouble            lat;
      SpiceDouble            alt;

      rectan  = A_DBL_ARGV( 1 );

      recpgr_c( body,
                rectan,
                re,
                f,
                &lon,
                &lat,
                &alt);

      /*
      Test for a SPICE error signal. If found, display an error message to the
      user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      Argv[4]->value.d = lon;
      Argv[5]->value.d = lat;
      Argv[6]->value.d = alt;

      }
   else
      {

      /* Vector input. */

      SpiceDouble          * lon;
      SpiceDouble          * lat;
      SpiceDouble          * alt;

      rectan  =  (SpiceDouble*)(Argv[1]->value.arr->data) ;
      lon     = A_DBL_ARGV(4);
      lat     = A_DBL_ARGV(5);
      alt     = A_DBL_ARGV(6);

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {

         /*
         The 'rectan' vector has length 3 input to recgeo_c so increment
         the pointer to the data by factors of 3.
         */
         recpgr_c( body,
                  (rectan + i*3),
                  re,
                  f,
                  (lon+i),
                  (lat+i),
                  (alt+i));

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              reclat_c ( ConstSpiceDouble    rectan[3],
                                SpiceDouble       * radius,
                                SpiceDouble       * longitude,
                                SpiceDouble       * latitude  )
*/
PROCEDURE CSPICE_RECLAT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * rectan;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "rectan",    (void*)IDL_TYP_DOUBLE,  1, { 3 },    1},
      { OWRIT, "radius",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "longitude", (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "latitude",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_RECLAT, _rectan[3]_, _RADIUS_, "
                    "_LONGITUDE_, _LATITUDE_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
    */
   if (extra->ndims == 0)
      {

      /* Scalar input. */

      SpiceDouble           radius;
      SpiceDouble           longitude;
      SpiceDouble           latitude;

      rectan = A_DBL_ARGV( 0 );

      reclat_c( rectan,
                &radius,
                &longitude,
                &latitude);

      /*
      Test for a SPICE error signal. If found, display an error message to the
      user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      Argv[1]->value.d = radius;
      Argv[2]->value.d = longitude;
      Argv[3]->value.d = latitude;

      }
   else
      {

      /* Vector input. */

      SpiceDouble         * radius;
      SpiceDouble         * longitude;
      SpiceDouble         * latitude;

      rectan     =  (SpiceDouble*)(Argv[0]->value.arr->data) ;
      radius     = A_DBL_ARGV(1);
      longitude  = A_DBL_ARGV(2);
      latitude   = A_DBL_ARGV(3);

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         /*
         The 'rectan' vector has length 3 input to reclat_c so increment
         the pointer to the data by factors of 3.
         */
         reclat_c( (rectan    + i*3),
                   (radius    + i  ),
                   (longitude + i  ),
                   (latitude  + i  ) );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              recrad_c ( ConstSpiceDouble    rectan[3],
                                SpiceDouble       * radius,
                                SpiceDouble       * ra,
                                SpiceDouble       * dec  )
*/
PROCEDURE CSPICE_RECRAD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceDouble          * rectan;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "rectan", (void*)IDL_TYP_DOUBLE,  1, { 3 },    1},
      { OWRIT, "radius", (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "ra",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "dec",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_RECRAD, _rectan[3]_, _RADIUS_, _RA_, _DEC_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
    */
   if (extra->ndims == 0)
      {

      /* Scalar input. */

      SpiceDouble            radius;
      SpiceDouble            ra;
      SpiceDouble            dec;

      rectan  = A_DBL_ARGV( 0 );

      recrad_c( rectan,
                &radius,
                &ra,
                &dec);

      /*
      Test for a SPICE error signal. If found, display an error message to the
      user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      Argv[1]->value.d = radius;
      Argv[2]->value.d = ra;
      Argv[3]->value.d = dec;

      }
   else
      {

      /* Vector input. */

      SpiceDouble          * radius;
      SpiceDouble          * ra;
      SpiceDouble          * dec;

      rectan =  (SpiceDouble*)(Argv[0]->value.arr->data) ;
      radius = A_DBL_ARGV(1);
      ra     = A_DBL_ARGV(2);
      dec    = A_DBL_ARGV(3);

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         /*
         The 'rectan' vector has length 3 input to reclat_c so increment
         the pointer to the data by factors of 3.
         */
         recrad_c( (rectan + i*3), (radius+i), (ra+i), (dec+i));

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              recsph_c ( ConstSpiceDouble    rectan[3],
                                SpiceDouble       * r,
                                SpiceDouble       * colat,
                                SpiceDouble       * lon )
*/
PROCEDURE CSPICE_RECSPH(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceDouble          * rectan;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "rectan", (void*)IDL_TYP_DOUBLE,  1, { 3 },    1},
      { OWRIT, "r",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "colat",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "lon",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
     };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_RECSPH, _rectan[3]_, _R_, _COLAT_, _LON_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
    */
   if (extra->ndims == 0)
      {

      /* Scalar input. */

      SpiceDouble            r;
      SpiceDouble            colat;
      SpiceDouble            lon;

      rectan  = A_DBL_ARGV( 0 );

      recsph_c( rectan,
                &r,
                &colat,
                &lon);

      /*
      Test for a SPICE error signal. If found, display an error message to the
      user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      Argv[1]->value.d = r;
      Argv[2]->value.d = colat;
      Argv[3]->value.d = lon;

      }
   else
      {

      /* Vector input. */

      SpiceDouble          * r;
      SpiceDouble          * colat;
      SpiceDouble          * lon;

      rectan = (SpiceDouble*)(Argv[0]->value.arr->data) ;
      r      = A_DBL_ARGV(1);
      colat  = A_DBL_ARGV(2);
      lon    = A_DBL_ARGV(3);

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         /*
         The 'rectan' vector has length 3 input to reclat_c so increment
         the pointer to the data by factors of 3.
         */
         recsph_c( (rectan + i*3),
                   (r      + i  ),
                   (colat  + i  ),
                   (lon    + i  ) );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*

 void              removd_c ( SpiceInt        item,
                              SpiceCell     * set  );

 */
PROCEDURE CSPICE_REMOVD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset;
   SpiceDouble           item;
   SpiceCell              set;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "item", (void*)IDL_TYP_DOUBLE, 0, { 0 }, 1},
      { RDWRT, "set",  (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_REMOVD, _item_, (SET)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[1].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[1]->value.s.arr->data);
   pack_cell( &set, 1, tag_offset, Argv );

   /* Did the user pass a vector for input? */
   if (extra->ndims == 0)
      {

      item = S_DBL_ARGV( 0 );

      removd_c ( item, &set );

      /*
       Test for a SPICE error signal. If found, display an error message to the
       user then return to the IDL application.
       */
      CHECK_CALL_FAILURE_MEM2( set, SCALAR );
      }
   else
      {
      /* Vector input.*/

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         item = ((SpiceDouble*)(Argv[0]->value.arr->data))[i];

         removd_c ( item, &set );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE_MEM2( set, i );
         }

      }

   /*
   Unpack the data from 'window' to 'Argv'.
   */
   unpack_cell( 1, tag_offset, &set, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*

 void              removi_c ( SpiceInt        item,
                              SpiceCell     * set  );

*/
PROCEDURE CSPICE_REMOVI(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset;
   SpiceInt               item;
   SpiceCell              set;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "item", (void*)IDL_TYP_LONG,   0, { 0 }, 1},
      { RDWRT, "set",  (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_REMOVI, _item_, (SET)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[1].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[1]->value.s.arr->data);
   pack_cell( &set, 1, tag_offset, Argv );

   /* Did the user pass a vector for input? */
   if (extra->ndims == 0)
      {

      item = S_INT_ARGV( 0 );

      removi_c ( item, &set );

      /*
      Test for a SPICE error signal. If found, display an error message to the
      user then return to the IDL application.
      */
      CHECK_CALL_FAILURE_MEM2( set, SCALAR );
      }
   else
      {
      /* Vector input.*/

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         item = ((SpiceInt*)(Argv[0]->value.arr->data))[i];

         removi_c ( item, &set );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE_MEM2( set, i );
         }

      }

   /*
   Unpack the data from 'window' to 'Argv'.
   */
   unpack_cell( 1, tag_offset, &set, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              rotate_c ( SpiceDouble         angle,
                                SpiceInt            iaxis,
                                SpiceDouble         mout[3][3] )
*/
PROCEDURE CSPICE_ROTATE(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          angle;
   SpiceInt             iaxis;
   SpiceDouble        * mout;

   struct argcheck argcheck[] =
      {
      { OREAD, "angle", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "iaxis", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "mout",  (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_ROTATE, angle, iaxis, MOUT[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   angle      = S_DBL_ARGV( 0 );
   iaxis      = S_INT_ARGV( 1 );
   mout       = A_DBL_ARGV( 2 );

   rotate_c(angle,iaxis,(SpiceDouble (*)[3])mout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              rotmat_c ( ConstSpiceDouble    m1[3][3],
                                SpiceDouble         angle,
                                SpiceInt            iaxis,
                                SpiceDouble         mout[3][3] )
*/
PROCEDURE CSPICE_ROTMAT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * m1;
   SpiceDouble          angle;
   SpiceInt             iaxis;
   SpiceDouble        * mout;

   struct argcheck argcheck[] =
      {
      { OREAD, "m1",    (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      { OREAD, "angle", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "iaxis", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "mout",  (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_ROTMAT, m1[3,3], angle, iaxis, MOUT[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   m1         = A_DBL_ARGV( 0 );
   angle      = S_DBL_ARGV( 1 );
   iaxis      = S_INT_ARGV( 2 );
   mout       = A_DBL_ARGV( 3 );

   rotmat_c((Nx3d)m1,angle,iaxis,(SpiceDouble (*)[3])mout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              rotvec_c ( ConstSpiceDouble    v1[3],
                                SpiceDouble         angle,
                                SpiceInt            iaxis,
                                SpiceDouble         vout[3] )
*/
PROCEDURE CSPICE_ROTVEC(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * v1;
   SpiceDouble          angle;
   SpiceInt             iaxis;
   SpiceDouble        * vout;

   struct argcheck argcheck[] =
      {
      { OREAD, "v1",    (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "angle", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "iaxis", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "vout",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_ROTVEC, v1[3], angle, iaxis, VOUT[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   v1         = A_DBL_ARGV( 0 );
   angle      = S_DBL_ARGV( 1 );
   iaxis      = S_INT_ARGV( 2 );
   vout       = A_DBL_ARGV( 3 );

   rotvec_c(v1,angle,iaxis,vout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceDouble       rpd_c    ( void )
*/
FUNCTION CSPICE_RPD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR     retval_idl;
   SpiceDouble  retval_c;

   /* Check the input contains the correct number of arguments. */
   if (Argc != 0)
      {
      USAGE("double  = CSPICE_RPD()");
      }

   retval_c = rpd_c();

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   return retval_idl;
   }




/*
   void              rquad_c  ( SpiceDouble         a,
                                SpiceDouble         b,
                                SpiceDouble         c,
                                SpiceDouble         root1[2],
                                SpiceDouble         root2[2] )
*/
PROCEDURE CSPICE_RQUAD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          a;
   SpiceDouble          b;
   SpiceDouble          c;
   SpiceDouble        * root1;
   SpiceDouble        * root2;

   struct argcheck argcheck[] =
      {
      { OREAD, "a",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "b",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "c",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "root1", (void*)IDL_TYP_DOUBLE,  1, { 2 },    0},
      { OWRIT, "root2", (void*)IDL_TYP_DOUBLE,  1, { 2 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 5)
      {
      USAGE("CSPICE_RQUAD, a, b, c, ROOT1[2], ROOT2[2]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   a          = S_DBL_ARGV( 0 );
   b          = S_DBL_ARGV( 1 );
   c          = S_DBL_ARGV( 2 );
   root1      = A_DBL_ARGV( 3 );
   root2      = A_DBL_ARGV( 4 );

   rquad_c(a,b,c,root1,root2);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              saelgv_c ( ConstSpiceDouble    vec1  [3],
                                ConstSpiceDouble    vec2  [3],
                                SpiceDouble         smajor[3],
                                SpiceDouble         sminor[3]  )
*/
PROCEDURE CSPICE_SAELGV(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * vec1;
   SpiceDouble        * vec2;
   SpiceDouble        * smajor;
   SpiceDouble        * sminor;

   struct argcheck argcheck[] =
      {
      { OREAD, "vec1",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "vec2",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "smajor", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "sminor", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_SAELGV, vec1[3], vec2[3], SMAJOR[3], SMINOR[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   vec1       = A_DBL_ARGV( 0 );
   vec2       = A_DBL_ARGV( 1 );
   smajor     = A_DBL_ARGV( 2 );
   sminor     = A_DBL_ARGV( 3 );

   saelgv_c(vec1,vec2,smajor,sminor);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*

 void              scard_c (  SpiceInt            card,
                              SpiceCell         * cell  )


 */
PROCEDURE CSPICE_SCARD (int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt               card;
   SpiceCell              cell;
   SpiceInt             * tag_offset;

   struct argcheck argcheck[] =
      {
      { OREAD, "card", (void*)IDL_TYP_LONG,   0, { 0 }, 0},
      { RDWRT, "cell", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_SCARD, card, (CELL)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[1].type = (void*)(IDL_MAX_TYPE + 1);

   /*
    Perform the input argument type checks, allocate any needed
    memory for output args, copy the argument vector to a work copy.
    */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   card = S_INT_ARGV( 0 );

   /*
   Pack the IDL cell structure to a cell.

   */
   tag_offset = (SpiceInt*) (Argv[1]->value.s.arr->data);
   pack_cell( &cell, 1, tag_offset, Argv );

   scard_c ( card, &cell );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( cell, SCALAR );

   /*
   Unpack the data from 'window' to 'Argv'.
   */
   unpack_cell( 1, tag_offset, &cell, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              scdecd_c ( SpiceInt            sc,
                                SpiceDouble         sclkdp,
                                SpiceInt            sclklen,
                                SpiceChar         * sclkch   )
*/
PROCEDURE CSPICE_SCDECD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              sc;
   SpiceDouble           sclkdp;
   SpiceChar             sclkch_buf[RET_ARRAY_LEN+1];

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "sc",     (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "sclkdp", (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "sclkch", (void*)IDL_TYP_STRING,  0, { 0 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_SCDECD, sc, _sclkdp_, _`SCLKCH`_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   sc         = S_INT_ARGV( 0 );

   /* Called with `vectorized' input arguments? */
   if (extra->ndims == 0)
      {
      /* Scalar */
      sclkdp = S_DBL_ARGV( 1 );

      scdecd_c( sc, sclkdp, RET_ARRAY_LEN, sclkch_buf);

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      /*
      Note, this is a copy operation.
      */
      S_STR_RET_ARGV( 2, sclkch_buf);
      }
   else
      {
      /* Vector input. */
      IDL_STRING * sclkch_sptr = (IDL_STRING*)Argv[2]->value.arr->data;

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         sclkdp = ((SpiceDouble*)(Argv[1]->value.arr->data))[i];

         scdecd_c( sc, sclkdp, RET_ARRAY_LEN, sclkch_buf);

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);

         IDL_StrStore(&sclkch_sptr[i], sclkch_buf);
         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              sce2c_c  ( SpiceInt            sc,
                                SpiceDouble         et,
                                SpiceDouble       * sclkdp   )
*/
PROCEDURE CSPICE_SCE2C(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              sc;
   SpiceDouble           et;

   SpiceInt              i;

   struct argcheck argcheck[] =
      {
      { OREAD, "sc",     (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "sclkdp", (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_SCE2C, sc, _et_, _SCLKDP_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   sc = S_INT_ARGV( 0 );

  /* Called with `vectorized' input arguments? */
   if (extra->ndims == 0)
      {

      SpiceDouble           sclkdp;

      et = S_DBL_ARGV( 1 );

      sce2c_c( sc, et, &sclkdp);

      /*
      Test for a SPICE error signal. If found, display an error message to the
      user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      Argv[2]->value.d = sclkdp;

      }
   else
      {

      /* Vector input. */

      SpiceDouble         * sclkdp;

      sclkdp = A_DBL_ARGV(2);

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         et = ((SpiceDouble*)(Argv[1]->value.arr->data))[i];

         sce2c_c( sc, et, (sclkdp+i) );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);

         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              sce2s_c  ( SpiceInt            sc,
                                SpiceDouble         et,
                                SpiceInt            sclklen,
                                SpiceChar         * sclkch   )
*/
PROCEDURE CSPICE_SCE2S(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              sc;
   SpiceDouble           et;
   SpiceChar             sclkch_buf[RET_ARRAY_LEN+1];

   struct argcheck argcheck[] =
      {
      { OREAD, "sc",     (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "sclkch", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_SCE2S, sc, et, `SCLKCH`");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   sc             = S_INT_ARGV( 0 );
   et             = S_DBL_ARGV( 1 );

   /* Scalar */
   sce2s_c ( sc, et, RET_ARRAY_LEN, sclkch_buf);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV( 2, sclkch_buf);

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              sce2t_c  ( SpiceInt            sc,
                                SpiceDouble         et,
                                SpiceDouble       * sclkdp   )
*/
PROCEDURE CSPICE_SCE2T(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              sc;
   SpiceDouble           et;
   SpiceDouble           sclkdp;

   struct argcheck argcheck[] =
      {
      { OREAD, "sc",     (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "sclkdp", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_SCE2T, sc, et, SCLKDP");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   sc         = S_INT_ARGV( 0 );
   et         = S_DBL_ARGV( 1 );

   sce2t_c( sc, et, &sclkdp);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[2]->value.d = sclkdp;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              scencd_c ( SpiceInt            sc,
                                ConstSpiceChar    * sclkch,
                                SpiceDouble       * sclkdp   )
*/
PROCEDURE CSPICE_SCENCD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              sc;
   SpiceChar           * sclkch;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "sc",     (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "sclkch", (void*)IDL_TYP_STRING,  0, { 0 },    1},
      { OWRIT, "sclkdp", (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_SCENCD, sc, _`sclkch`_, _SCLKDP_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   sc = S_INT_ARGV( 0 );

   /* Called with `vectorized' input arguments? */
   if (extra->ndims == 0)
      {

      /* Scalar */
      SpiceDouble           sclkdp;

      sclkch = S_STR_ARGV( 1 );

      scencd_c( sc, sclkch, &sclkdp);

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      Argv[2]->value.d = sclkdp;

      }
   else
      {

      /* Vector input. */

      SpiceDouble         * sclkdp;

      sclkdp = A_DBL_ARGV(2);

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         sclkch = IDL_STRING_STR(&((IDL_STRING*)(Argv[1]->value.arr->data))[i]);

         scencd_c( sc, sclkch, (sclkdp+i) );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);

         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              scfmt_c  ( SpiceInt            sc,
                                SpiceDouble         ticks,
                                SpiceInt            clkstrlen,
                                SpiceChar         * clkstr    )
*/
PROCEDURE CSPICE_SCFMT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              sc;
   SpiceDouble           ticks;
   SpiceChar             clkstr_buf[RET_ARRAY_LEN+1];

   struct argcheck argcheck[] =
      {
      { OREAD, "sc",     (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "ticks",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "clkstr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
    };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_SCFMT, sc, ticks, `CLKSTR`");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   sc             = S_INT_ARGV( 0 );
   ticks          = S_DBL_ARGV( 1 );

   scfmt_c ( sc, ticks, RET_ARRAY_LEN, clkstr_buf);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV( 2, clkstr_buf);

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              scpart_c ( SpiceInt            sc,
                                SpiceInt          * nparts,
                                SpiceDouble       * pstart,
                                SpiceDouble       * pstop   )
*/
PROCEDURE CSPICE_SCPART(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             sc;
   SpiceInt             pstart_dim;
   SpiceDouble          pstart[512];
   SpiceDouble          pstop[512];

   struct argcheck argcheck[] =
      {
      { OREAD, "sc",     (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "pstart", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OWRIT, "pstop",  (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_SCPART, sc, PSTART[], PSTOP[]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   sc         = S_INT_ARGV( 0 );
   pstart_dim = 0;

   scpart_c(sc,&pstart_dim,pstart,pstop);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   if (pstart_dim != 0)
      {
      char    *pstart_copy;
      int      tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

     tmp_ndims   = 1;
     tmp_dims[0] = pstart_dim;
     pstart_copy = IDL_MakeTempArray(IDL_TYP_DOUBLE, tmp_ndims, tmp_dims,
                                     IDL_ARR_INI_NOP, &Argv[1]);

     memmove(pstart_copy, pstart, pstart_dim * sizeof(SpiceDouble       ));
     }

   /* pstop array */
   if (pstart_dim != 0)
      {
      char    *pstop_copy;
      int      tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

     tmp_ndims   = 1;
     tmp_dims[0] = pstart_dim;
     pstop_copy  = IDL_MakeTempArray(IDL_TYP_DOUBLE, tmp_ndims, tmp_dims,
                                     IDL_ARR_INI_NOP, &Argv[2]);

     memmove(pstop_copy, pstop, pstart_dim * sizeof(SpiceDouble       ));
     }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              scs2e_c  ( SpiceInt            sc,
                                ConstSpiceChar    * sclkch,
                                SpiceDouble       * et      )
*/
PROCEDURE CSPICE_SCS2E(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              sc;
   SpiceChar           * sclkch;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "sc",     (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "sclkch", (void*)IDL_TYP_STRING,  0, { 0 },    1},
      { OWRIT, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_SCS2E, sc, _`sclkch`_, _ET_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   sc = S_INT_ARGV( 0 );

   /* Called with `vectorized' input arguments? */
   if (extra->ndims == 0)
      {

      /* Scalar */
      SpiceDouble           et;

      sclkch = S_STR_ARGV( 1 );

      scs2e_c( sc, sclkch, &et);

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      Argv[2]->value.d = et;

      }
   else
      {

      /* Vector input. */
      SpiceDouble         * et;

      et = A_DBL_ARGV(2);

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         sclkch = IDL_STRING_STR(&((IDL_STRING*)(Argv[1]->value.arr->data))[i]);

         scs2e_c( sc, sclkch, (et+i));

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);

         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              sct2e_c  ( SpiceInt            sc,
                                SpiceDouble         sclkdp,
                                SpiceDouble       * et      )
*/
PROCEDURE CSPICE_SCT2E(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              sc;
   SpiceDouble           sclkdp;
   SpiceDouble           et;

   struct argcheck argcheck[] =
      {
      { OREAD, "sc",     (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "sclkdp", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_SCT2E, sc, sclkdp, ET");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   sc     = S_INT_ARGV( 0 );
   sclkdp = S_DBL_ARGV( 1 );

   /* Scalar */
   sct2e_c( sc, sclkdp, &et);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[2]->value.d = et;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              sctiks_c ( SpiceInt            sc,
                                ConstSpiceChar    * clkstr,
                                SpiceDouble       * ticks   )
*/
PROCEDURE CSPICE_SCTIKS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              sc;
   SpiceChar           * clkstr;
   SpiceDouble           ticks;

   struct argcheck argcheck[] =
      {
      { OREAD, "sc",     (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "clkstr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "ticks",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_SCTIKS, sc, `clkstr`, TICKS");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   sc     = S_INT_ARGV( 0 );
   clkstr = S_STR_ARGV( 1 );

   sctiks_c( sc, clkstr, &ticks);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[2]->value.d = ticks;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*

 void              sdiff_c ( SpiceCell          * a,
                             SpiceCell          * b,
                             SpiceCell          * c );


 */
PROCEDURE CSPICE_SDIFF(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset1;
   SpiceInt             * tag_offset2;
   SpiceInt             * tag_offset3;
   SpiceCell              a;
   SpiceCell              b;
   SpiceCell              c;

   struct argcheck argcheck[] =
      {
      { OREAD, "a", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0},
      { OREAD, "b", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0},
      { RDWRT, "c", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_SDIFF, a, b, (C)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[0].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[1].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[2].type = (void*)(IDL_MAX_TYPE + 1);

   /*
    Perform the input argument type checks, allocate any needed
    memory for output args, copy the argument vector to a work copy.
    */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );


   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset1 = (SpiceInt*) (Argv[0]->value.s.arr->data);
   tag_offset2 = (SpiceInt*) (Argv[1]->value.s.arr->data);
   tag_offset3 = (SpiceInt*) (Argv[2]->value.s.arr->data);

   pack_cell( &a, 0, tag_offset1, Argv );
   pack_cell( &b, 1, tag_offset2, Argv );
   pack_cell( &c, 2, tag_offset3, Argv );

   (void) sdiff_c ( &a, &b, &c );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM4( a, b, c, SCALAR );

   /*
   Unpack the cells, return the data from 'c' to 'Argv'.
   */
   unpack_cell( 0, tag_offset3, &a, Argv );
   unpack_cell( 1, tag_offset3, &b, Argv );
   unpack_cell( 2, tag_offset3, &c, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*

   SpiceBoolean      set_c ( SpiceCell          * a,
                             ConstSpiceChar     * op,
                             SpiceCell          * b   );


*/
FUNCTION CSPICE_SET(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR             * Argv;
   struct extra_dims    * extra;

   SpiceBoolean           retval_c;
   IDL_VPTR               retval_idl = NULL;
   SpiceInt             * tag_offset1;
   SpiceInt             * tag_offset2;
   SpiceCell              a;
   SpiceCell              b;
   SpiceChar            * op;

   struct argcheck argcheck[] =
      {
      { OREAD, "a",  (void*)IDL_TYP_STRUCT, 0, { 0 }, 0},
      { OREAD, "op", (void*)IDL_TYP_STRING, 0, { 0 }, 0},
      { OREAD, "b",  (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("boolean = CSPICE_SET( a, `op`, b)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[0].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[2].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   op = S_STR_ARGV( 1 );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset1 = (SpiceInt*) (Argv[0]->value.s.arr->data);
   tag_offset2 = (SpiceInt*) (Argv[2]->value.s.arr->data);

   pack_cell( &a, 0, tag_offset1, Argv );
   pack_cell( &b, 2, tag_offset2, Argv );

   retval_c = set_c ( &a, op, &b );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM3( a, b, SCALAR );

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_BYTE;
   retval_idl->value.c  = (RETURN_BOOL) retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              sincpt_c ( ConstSpiceChar    * method,
                                ConstSpiceChar    * target,
                                SpiceDouble         et,
                                ConstSpiceChar    * fixref,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceChar    * obsrvr,
                                ConstSpiceChar    * dref,
                                ConstSpiceDouble    dvec   [3],
                                SpiceDouble         spoint [3],
                                SpiceDouble       * trgepc,
                                SpiceDouble         srfvec [3],
                                SpiceBoolean      * found         );
*/
PROCEDURE CSPICE_SINCPT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar          * method;
   SpiceChar          * target;
   SpiceDouble          et;
   SpiceChar          * fixref;
   SpiceChar          * abcorr;
   SpiceChar          * obsrvr;
   SpiceChar          * dref;
   SpiceDouble        * dvec;
   SpiceDouble        * spoint;
   SpiceDouble          trgepc;
   SpiceDouble        * srfvec;
   SpiceBoolean         found;


   struct argcheck argcheck[] =
      {
      { OREAD, "method", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "fixref", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "dref",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "dvec",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "spoint", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "trgepc", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "srfvec", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 12)
      {
      USAGE("CSPICE_SINCPT, `method`,`target`, et, `fixref`, "
                            "`abcorr`, `obsrvr`, `dref`, dvec[3], "
                            "SPOINT[3], TRGEPC, SRFVEC[3], FOUND" );
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   method  = S_STR_ARGV( 0 );
   target  = S_STR_ARGV( 1 );
   et      = S_DBL_ARGV( 2 );
   fixref  = S_STR_ARGV( 3 );
   abcorr  = S_STR_ARGV( 4 );
   obsrvr  = S_STR_ARGV( 5 );
   dref    = S_STR_ARGV( 6 );
   dvec    = A_DBL_ARGV( 7 );
   spoint  = A_DBL_ARGV( 8 );
   srfvec  = A_DBL_ARGV( 10 );

   (void) sincpt_c (  method,
               target,
               et,
               fixref,
               abcorr,
               obsrvr,
               dref,
               dvec,
               spoint,
               &trgepc,
               srfvec,
               &found );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[9]->value.d  = trgepc;
   Argv[11]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*

 SpiceInt          size_c   ( SpiceCell         * cell );

 */
FUNCTION CSPICE_SIZE(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;

   IDL_VPTR               retval_idl = NULL;
   SpiceInt               retval_c;
   SpiceInt             * tag_offset;
   SpiceCell              cell;


   struct argcheck argcheck[] =
      {
      { OREAD, "cell", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("integer = CSPICE_SIZE( (cell) )");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[0].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[0]->value.s.arr->data);
   pack_cell( &cell, 0, tag_offset, Argv );

   retval_c = size_c ( &cell );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( cell, SCALAR );

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_LONG;
   retval_idl->value.l  = retval_c;

   unpack_cell( 0, tag_offset, &cell, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   SpiceDouble       spd_c    ( void )
*/
FUNCTION CSPICE_SPD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR     retval_idl;
   SpiceDouble  retval_c;

   /* Check the input contains the correct number of arguments. */
   if (Argc != 0)
      {
      USAGE("double  = CSPICE_SPD()");
      }

   retval_c = spd_c();

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   return retval_idl;
   }




/*
   void              sphcyl_c ( SpiceDouble         radius,
                                SpiceDouble         colat,
                                SpiceDouble         slon,
                                SpiceDouble       * r,
                                SpiceDouble       * lon,
                                SpiceDouble       * z )
*/
PROCEDURE CSPICE_SPHCYL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble           radius;
   SpiceDouble           colat;
   SpiceDouble           slon;
   SpiceDouble           r;
   SpiceDouble           lon;
   SpiceDouble           z;

   struct argcheck argcheck[] =
      {
      { OREAD, "radius", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "colat",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "slon",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "r",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "lon",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "z",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_SPHCYL, radius, colat, slon, R, LON, Z");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   radius     = S_DBL_ARGV( 0 );
   colat      = S_DBL_ARGV( 1 );
   slon       = S_DBL_ARGV( 2 );

   (void) sphcyl_c ( radius, colat, slon, &r, &lon, &z);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[3]->value.d = r;
   Argv[4]->value.d = lon;
   Argv[5]->value.d = z;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              sphlat_c ( SpiceDouble         r,
                                SpiceDouble         colat,
                                SpiceDouble         lons,
                                SpiceDouble       * radius,
                                SpiceDouble       * lon,
                                SpiceDouble       * lat   )
*/
PROCEDURE CSPICE_SPHLAT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble           r;
   SpiceDouble           colat;
   SpiceDouble           lons;
   SpiceDouble           radius;
   SpiceDouble           lon;
   SpiceDouble           lat;

   struct argcheck argcheck[] =
      {
      { OREAD, "r",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "colat",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "lons",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "radius", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "lon",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "lat",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_SPHLAT, r, colat, lons, RADIUS, LON, LAT");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   r          = S_DBL_ARGV( 0 );
   colat      = S_DBL_ARGV( 1 );
   lons       = S_DBL_ARGV( 2 );

   (void) sphlat_c ( r, colat, lons, &radius, &lon, &lat);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[3]->value.d = radius;
   Argv[4]->value.d = lon;
   Argv[5]->value.d = lat;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              sphrec_c ( SpiceDouble         r,
                                SpiceDouble         colat,
                                SpiceDouble         lon,
                                SpiceDouble         rectan[3] )
*/
PROCEDURE CSPICE_SPHREC(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceDouble            r;
   SpiceDouble            colat;
   SpiceDouble            lon;
   SpiceDouble          * rectan;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "r",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "colat",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "lon",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "rectan", (void*)IDL_TYP_DOUBLE,  1, { 3 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_SPHREC, _r_, _colat_, _lon_, _RECTAN[3]_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   rectan     = A_DBL_ARGV( 3 );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
   */
   if (extra->ndims == 0)
      {
      /* Scalar input. */
      r     = S_DBL_ARGV( 0 );
      colat = S_DBL_ARGV( 1 );
      lon   = S_DBL_ARGV( 2 );

      (void) sphrec_c (r,colat,lon,rectan);

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );
      }
   else
      {
      /* Vector input. */

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         r     = ((SpiceDouble*)(Argv[0]->value.arr->data))[i];
         colat = ((SpiceDouble*)(Argv[1]->value.arr->data))[i];
         lon   = ((SpiceDouble*)(Argv[2]->value.arr->data))[i];

         (void) sphrec_c (r,colat,lon, (rectan+i*3) );

         /*
          Test for a SPICE error signal. If found, display an error message
          to the user then return to the IDL application.
          */
         CHECK_CALL_FAILURE(i);
         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spk14a_c ( SpiceInt            handle,
                                SpiceInt            ncsets,
                                ConstSpiceDouble    coeffs [],
                                ConstSpiceDouble    epochs []  )
*/
PROCEDURE CSPICE_SPK14A(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceInt             ncsets;
   SpiceDouble        * coeffs;
   SpiceDouble        * epochs;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "ncsets", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "coeffs", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OREAD, "epochs", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_SPK14A, handle, ncsets, coeffs[], epochs[]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle  = S_INT_ARGV( 0 );
   ncsets  = S_INT_ARGV( 1 );
   coeffs  = A_DBL_ARGV( 2 );
   epochs  = A_DBL_ARGV( 3 );

   (void) spk14a_c (handle,ncsets,coeffs,epochs);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spk14b_c ( SpiceInt            handle,
                                ConstSpiceChar    * segid,
                                SpiceInt            body,
                                SpiceInt            center,
                                ConstSpiceChar    * frame,
                                SpiceDouble         first,
                                SpiceDouble         last,
                                SpiceInt            chbdeg  )
*/
PROCEDURE CSPICE_SPK14B(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceChar          * segid;
   SpiceInt             body;
   SpiceInt             center;
   SpiceChar          * frame;
   SpiceDouble          first;
   SpiceDouble          last;
   SpiceInt             chbdeg;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "segid",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "body",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "center", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "frame",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "first",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "last",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "chbdeg", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 8)
      {
      USAGE("CSPICE_SPK14B, handle, `segid`, body, center, `frame`, "
            "first, last, chbdeg");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle  = S_INT_ARGV( 0 );
   segid   = S_STR_ARGV( 1 );
   body    = S_INT_ARGV( 2 );
   center  = S_INT_ARGV( 3 );
   frame   = S_STR_ARGV( 4 );
   first   = S_DBL_ARGV( 5 );
   last    = S_DBL_ARGV( 6 );
   chbdeg  = S_INT_ARGV( 7 );

   (void) spk14b_c (handle,segid,body,center,frame,first,last,chbdeg);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spk14e_c ( SpiceInt            handle )
*/
PROCEDURE CSPICE_SPK14E(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_SPK14E, handle");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle = S_INT_ARGV( 0 );

   (void) spk14e_c (handle);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkapo_c ( SpiceInt            targ,
                                SpiceDouble         et,
                                ConstSpiceChar    * ref,
                                ConstSpiceDouble    sobs[6],
                                ConstSpiceChar    * abcorr,
                                SpiceDouble         ptarg[3],
                                SpiceDouble       * lt        )
*/
PROCEDURE CSPICE_SPKAPO(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            *Argv;
   struct extra_dims   *extra;
   SpiceInt            targ;
   SpiceDouble         et;
   SpiceChar    *      ref;
   SpiceDouble        * sobs;
   SpiceChar    *      abcorr;
   SpiceDouble       * ptarg;
   SpiceDouble         lt;

   struct argcheck argcheck[] =
      {
      { OREAD, "targ",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "ref",    (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "sobs",   (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "ptarg",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "lt",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_SPKAPO, targ, et, `ref`, sobs[6], `abcorr`, "
            "PTARG[3], LTIME");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   targ    = S_INT_ARGV( 0 );
   et      = S_DBL_ARGV( 1 );
   ref     = S_STR_ARGV( 2 );
   sobs    = A_DBL_ARGV( 3 );
   abcorr  = S_STR_ARGV( 4 );
   ptarg   = A_DBL_ARGV( 5 );

   (void) spkapo_c (targ,et,ref,sobs,abcorr,ptarg, &lt);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[6]->value.d = lt;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkapp_c ( SpiceInt            targ,
                                SpiceDouble         et,
                                ConstSpiceChar    * ref,
                                ConstSpiceDouble    sobs   [6],
                                ConstSpiceChar    * abcorr,
                                SpiceDouble         starg  [6],
                                SpiceDouble       * lt         )
*/
PROCEDURE CSPICE_SPKAPP(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              targ;
   SpiceDouble           et;
   SpiceChar           * ref;
   SpiceDouble         * sobs;
   SpiceChar           * abcorr;
   SpiceDouble         * starg;
   SpiceDouble           lt;

   struct argcheck argcheck[] =
      {
      { OREAD, "targ",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "ref",    (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "sobs",   (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "starg",  (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      { OWRIT, "lt",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_SPKAPP, targ, et, `ref`, sobs[6], `abcorr`, "
            "STARG[6], LTIME");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   targ       = S_INT_ARGV( 0 );
   et         = S_DBL_ARGV( 1 );
   ref        = S_STR_ARGV( 2 );
   sobs       = A_DBL_ARGV( 3 );
   abcorr     = S_STR_ARGV( 4 );
   starg      = A_DBL_ARGV( 5 );

   (void) spkapp_c (targ,et,ref,sobs,abcorr,starg, &lt);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[6]->value.d = lt;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkcls_c ( SpiceInt            handle )
*/
PROCEDURE CSPICE_SPKCLS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_SPKCLS, handle");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle = S_INT_ARGV( 0 );

   (void) spkcls_c (handle);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }





/*
 void              spkcov_c ( ConstSpiceChar  * spk,
                              SpiceInt          idcode,
                              SpiceCell       * cover   )

 */
PROCEDURE CSPICE_SPKCOV(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset;
   SpiceChar            * spk;
   SpiceInt               idcode;
   SpiceCell              cover;

   struct argcheck argcheck[] =
      {
      { OREAD, "spk",    (void*)IDL_TYP_STRING, 0, { 0 }, 0},
      { OREAD, "idcode", (void*)IDL_TYP_LONG,   0, { 0 }, 0},
      { RDWRT, "cover",  (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_SPKCOV, `spk`, idcode, (COVER)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[2].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   spk    = S_STR_ARGV( 0 );
   idcode = S_INT_ARGV( 1 );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[2]->value.s.arr->data);
   pack_cell( &cover, 2, tag_offset, Argv );

   (void) spkcov_c ( spk, idcode, &cover );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( cover, SCALAR );

   /*
   Unpack the data from 'cover' to 'Argv'.
   */
   unpack_cell( 2, tag_offset, &cover, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkcpo_c ( ConstSpiceChar    * target,
                                SpiceDouble         et,
                                ConstSpiceChar    * outref,
                                ConstSpiceChar    * refloc,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceDouble    obspos [3],
                                ConstSpiceChar    * obsctr,
                                ConstSpiceChar    * obsref,
                                SpiceDouble         state  [6],
                                SpiceDouble       * lt          );
*/
PROCEDURE CSPICE_SPKCPO(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;

   SpiceChar           * target;
   SpiceDouble           et;
   SpiceChar           * outref;
   SpiceChar           * refloc;
   SpiceChar           * abcorr;
   SpiceDouble         * obspos;
   SpiceChar           * obsctr;
   SpiceChar           * obsref;
   SpiceDouble         * state;
   SpiceDouble           lt;

   struct argcheck argcheck[] =
      {
      { OREAD, "target",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",       (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "outref",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "refloc",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "abcorr",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obspos",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "obsctr",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obsref",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "state",    (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      { OWRIT, "lt",       (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 10)
      {
      USAGE("CSPICE_SPKCPO, `target`, et, `outref`, `refloc`, `abcorr,` "
                            "obspos[3], `obsctr`, `obsref`, "
                            "STARG[6], LTIME" );
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   target   = S_STR_ARGV( 0 );
   et       = S_DBL_ARGV( 1 );
   outref   = S_STR_ARGV( 2 );
   refloc   = S_STR_ARGV( 3 );
   abcorr   = S_STR_ARGV( 4 );
   obspos   = A_DBL_ARGV( 5 );
   obsctr   = S_STR_ARGV( 6 );
   obsref   = S_STR_ARGV( 7 );
   state    = A_DBL_ARGV( 8 );

   (void) spkcpo_c ( target,
                     et,
                     outref,
                     refloc,
                     abcorr,
                     obspos,
                     obsctr,
                     obsref,
                     state,
                     &lt );


   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[9]->value.d = lt;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkcpt_c ( ConstSpiceDouble       trgpos [3],
                                ConstSpiceChar       * trgctr,
                                ConstSpiceChar       * trgref,
                                SpiceDouble            et,
                                ConstSpiceChar       * outref,
                                ConstSpiceChar       * evlref,
                                ConstSpiceChar       * abcorr,
                                ConstSpiceChar       * obsrvr,
                                SpiceDouble          * state,
                                SpiceDouble          * lt        )
*/
PROCEDURE CSPICE_SPKCPT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;

   SpiceDouble         * trgpos;
   SpiceChar           * trgctr;
   SpiceChar           * trgref;
   SpiceDouble           et;
   SpiceChar           * outref;
   SpiceChar           * evlref;
   SpiceChar           * abcorr;
   SpiceChar           * obsrvr;
   SpiceDouble         * state;
   SpiceDouble           lt;

   struct argcheck argcheck[] =
      {
      { OREAD, "trgpos",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "trgctr",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "trgref",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",       (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "outref",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "evlref",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "abcorr",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obsrvr",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "state",    (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      { OWRIT, "lt",       (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 10)
      {
      USAGE("CSPICE_SPKCPT, trgpos[3], `trgctr`, `trgref`, et, "
            "`outref`, `evlref`, `abcorr`, `obsrv`, STARG[6], LTIME");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   trgpos   = A_DBL_ARGV( 0 );
   trgctr   = S_STR_ARGV( 1 );
   trgref   = S_STR_ARGV( 2 );
   et       = S_DBL_ARGV( 3 );
   outref   = S_STR_ARGV( 4 );
   evlref   = S_STR_ARGV( 5 );
   abcorr   = S_STR_ARGV( 6 );
   obsrvr   = S_STR_ARGV( 7 );
   state    = A_DBL_ARGV( 8 );

   (void) spkcpt_c ( trgpos,
                     trgctr,
                     trgref,
                     et,
                     outref,
                     evlref,
                     abcorr,
                     obsrvr,
                     state,
                     &lt);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[9]->value.d = lt;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkcvo_c ( ConstSpiceChar    * target,
                                SpiceDouble         et,
                                ConstSpiceChar    * outref,
                                ConstSpiceChar    * evlref,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceDouble    obssta [6],
                                SpiceDouble         obsepc,
                                ConstSpiceChar    * obsctr,
                                ConstSpiceChar    * obsref,
                                SpiceDouble         state  [6],
                                SpiceDouble       * lt         );
*/
PROCEDURE CSPICE_SPKCVO(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;

   SpiceChar           * target;
   SpiceDouble           et;
   SpiceChar           * outref;
   SpiceChar           * evlref;
   SpiceChar           * abcorr;
   SpiceDouble         * obssta;
   SpiceDouble           obsepc;
   SpiceChar           * obsctr;
   SpiceChar           * obsref;
   SpiceDouble         * state;
   SpiceDouble           lt;

   struct argcheck argcheck[] =
      {
      { OREAD, "target",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",       (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "outref",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "evlref",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "abcorr",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obssta",   (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      { OREAD, "obsepc",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "obsctr",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obsref",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "state",    (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      { OWRIT, "lt",       (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 11)
      {
      USAGE("CSPICE_SPKCVO, `target`, et, `outref`, `evlref`, `abcorr,` "
                            "obssta[6], obsepc, `obsctr`, `obsref`, "
                            "STARG[6], LTIME" );
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   target   = S_STR_ARGV( 0 );
   et       = S_DBL_ARGV( 1 );
   outref   = S_STR_ARGV( 2 );
   evlref   = S_STR_ARGV( 3 );
   abcorr   = S_STR_ARGV( 4 );
   obssta   = A_DBL_ARGV( 5 );
   obsepc   = S_DBL_ARGV( 6 );
   obsctr   = S_STR_ARGV( 7 );
   obsref   = S_STR_ARGV( 8 );
   state    = A_DBL_ARGV( 9 );

   (void) spkcvo_c ( target,
                     et,
                     outref,
                     evlref,
                     abcorr,
                     obssta,
                     obsepc,
                     obsctr,
                     obsref,
                     state,
                     &lt);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[10]->value.d = lt;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkcvt_c ( ConstSpiceDouble       trgsta [6],
                                SpiceDouble            trgepc,
                                ConstSpiceChar       * trgctr,
                                ConstSpiceChar       * trgref,
                                SpiceDouble            et,
                                ConstSpiceChar       * outref,
                                ConstSpiceChar       * evlref,
                                ConstSpiceChar       * abcorr,
                                ConstSpiceChar       * obsrvr,
                                SpiceDouble          * state,
                                SpiceDouble          * lt        )
*/
PROCEDURE CSPICE_SPKCVT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;

   SpiceDouble         * trgsta;
   SpiceDouble           trgepc;
   SpiceChar           * trgctr;
   SpiceChar           * trgref;
   SpiceDouble           et;
   SpiceChar           * outref;
   SpiceChar           * evlref;
   SpiceChar           * abcorr;
   SpiceChar           * obsrvr;
   SpiceDouble         * state;
   SpiceDouble           lt;

   struct argcheck argcheck[] =
      {
      { OREAD, "trgsta",   (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      { OREAD, "trgepc",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "trgctr",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "trgref",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",       (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "outref",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "evlref",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "abcorr",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obsrvr",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "state",    (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      { OWRIT, "lt",       (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 11)
      {
      USAGE("CSPICE_SPKCVT, trgsta[6], trgepc, `trgctr`, `trgref`, et, "
            "`outref`, `evlref`, `abcorr`, `obsrv`, STARG[6], LTIME");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   trgsta   = A_DBL_ARGV( 0 );
   trgepc   = S_DBL_ARGV( 1 );
   trgctr   = S_STR_ARGV( 2 );
   trgref   = S_STR_ARGV( 3 );
   et       = S_DBL_ARGV( 4 );
   outref   = S_STR_ARGV( 5 );
   evlref   = S_STR_ARGV( 6 );
   abcorr   = S_STR_ARGV( 7 );
   obsrvr   = S_STR_ARGV( 8 );
   state    = A_DBL_ARGV( 9 );

   (void) spkcvt_c ( trgsta,
                     trgepc,
                     trgctr,
                     trgref,
                     et,
                     outref,
                     evlref,
                     abcorr,
                     obsrvr,
                     state,
                     &lt  );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[10]->value.d = lt;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkez_c  ( SpiceInt            target,
                                SpiceDouble         epoch,
                                ConstSpiceChar    * frame,
                                ConstSpiceChar    * abcorr,
                                SpiceInt            observer,
                                SpiceDouble         state[6],
                                SpiceDouble       * lt       )
*/
PROCEDURE CSPICE_SPKEZ(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              target;
   SpiceDouble           epoch;
   SpiceChar           * frame;
   SpiceChar           * abcorr;
   SpiceInt              observer;
   SpiceDouble         * state;
   SpiceDouble           lt;

   struct argcheck argcheck[] =
      {
      { OREAD, "target",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "epoch",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "frame",    (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "abcorr",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "observer", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "state",    (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      { OWRIT, "lt",       (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_SPKEZ, targ, et, `ref`, `abcorr`, obs, "
                    "STATE[6], LTIME");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   target     = S_INT_ARGV( 0 );
   epoch      = S_DBL_ARGV( 1 );
   frame      = S_STR_ARGV( 2 );
   abcorr     = S_STR_ARGV( 3 );
   observer   = S_INT_ARGV( 4 );
   state      = A_DBL_ARGV( 5 );

   (void) spkez_c (target,epoch,frame,abcorr,observer,state, &lt);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[6]->value.d = lt;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkezp_c ( SpiceInt            targ,
                                SpiceDouble         et,
                                ConstSpiceChar    * ref,
                                ConstSpiceChar    * abcorr,
                                SpiceInt            obs,
                                SpiceDouble         ptarg[3],
                                SpiceDouble       * lt        )
*/
PROCEDURE CSPICE_SPKEZP(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              targ;
   SpiceDouble           et;
   SpiceChar           * ref;
   SpiceChar           * abcorr;
   SpiceInt              obs;
   SpiceDouble         * ptarg;
   SpiceDouble           lt;

   struct argcheck argcheck[] =
      {
      { OREAD, "targ",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "ref",    (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obs",    (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "ptarg",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "lt",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_SPKEZP, targ, et, `ref`, `abcorr`, obs, PTARG[3], LTIME");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   targ       = S_INT_ARGV( 0 );
   et         = S_DBL_ARGV( 1 );
   ref        = S_STR_ARGV( 2 );
   abcorr     = S_STR_ARGV( 3 );
   obs        = S_INT_ARGV( 4 );
   ptarg      = A_DBL_ARGV( 5 );

   (void) spkezp_c (targ,et,ref,abcorr,obs,ptarg, &lt);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[6]->value.d = lt;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkezr_c ( ConstSpiceChar    * target,
                                SpiceDouble         epoch,
                                ConstSpiceChar    * frame,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceChar    * observer,
                                SpiceDouble         state[6],
                                SpiceDouble       * lt       )
*/
PROCEDURE CSPICE_SPKEZR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;

   SpiceChar            * target;
   SpiceDouble            epoch;
   SpiceChar            * frame;
   SpiceChar            * abcorr;
   SpiceChar            * observer;
   SpiceDouble          * state;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "target",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "epoch",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "frame",    (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "abcorr",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "observer", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "state",    (void*)IDL_TYP_DOUBLE,  1, { 6 },    1},
      { OWRIT, "lt",       (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_SPKEZR, `targ`, _et_, `ref`, `abcorr`, `obs`, "
            "_STARG[6]_, _LTIME_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   target     = S_STR_ARGV( 0 );
   frame      = S_STR_ARGV( 2 );
   abcorr     = S_STR_ARGV( 3 );
   observer   = S_STR_ARGV( 4 );
   state      = A_DBL_ARGV( 5 );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
   */
   if (extra->ndims == 0)
      {
      /* Scalar input. */
      SpiceDouble            lt;

      epoch = S_DBL_ARGV( 1 );

      (void) spkezr_c(target,epoch,frame,abcorr,observer,state, &lt);

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      Argv[6]->value.d = lt;
      }
   else
      {
      /* Vector input. */
      SpiceDouble          * lt;

      lt = A_DBL_ARGV(6);

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         epoch = ((SpiceDouble*)(Argv[1]->value.arr->data))[i];

         (void) spkezr_c( target, epoch, frame, abcorr, observer,
                          (state +i*6), (lt+i) );

         /*
          Test for a SPICE error signal. If found, display an error message
          to the user then return to the IDL application.
          */
         CHECK_CALL_FAILURE(i);
         }

      }


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkgeo_c ( SpiceInt            targ,
                                SpiceDouble         et,
                                ConstSpiceChar    * ref,
                                SpiceInt            obs,
                                SpiceDouble         state[6],
                                SpiceDouble       * lt       )
*/
PROCEDURE CSPICE_SPKGEO(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              targ;
   SpiceDouble           et;
   SpiceChar           * ref;
   SpiceInt              obs;
   SpiceDouble         * state;
   SpiceDouble           lt;

   struct argcheck argcheck[] =
      {
      { OREAD, "targ",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "et",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "ref",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obs",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "state", (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      { OWRIT, "lt",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_SPKGEO, targ, et, `ref`, obs, STATE[6], LTIME");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   targ       = S_INT_ARGV( 0 );
   et         = S_DBL_ARGV( 1 );
   ref        = S_STR_ARGV( 2 );
   obs        = S_INT_ARGV( 3 );
   state      = A_DBL_ARGV( 4 );

   (void) spkgeo_c (targ,et,ref,obs,state, &lt);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /* Copy the output values to the return array. */
   Argv[5]->value.d = lt;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkgps_c ( SpiceInt            targ,
                                SpiceDouble         et,
                                ConstSpiceChar    * ref,
                                SpiceInt            obs,
                                SpiceDouble         pos[3],
                                SpiceDouble       * lt     )
*/
PROCEDURE CSPICE_SPKGPS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              targ;
   SpiceDouble           et;
   SpiceChar           * ref;
   SpiceInt              obs;
   SpiceDouble         * pos;
   SpiceDouble           lt;

   struct argcheck argcheck[] =
      {
      { OREAD, "targ", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "et",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "ref",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obs",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "pos",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "lt",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_SPKGPS, targ, et, `ref`, obs, POS[3], LTIME");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   targ  = S_INT_ARGV( 0 );
   et    = S_DBL_ARGV( 1 );
   ref   = S_STR_ARGV( 2 );
   obs   = S_INT_ARGV( 3 );
   pos   = A_DBL_ARGV( 4 );

   (void) spkgps_c (targ,et,ref,obs,pos, &lt);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[5]->value.d = lt;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spklef_c ( ConstSpiceChar    * filename,
                                SpiceInt          * handle   )
*/
PROCEDURE CSPICE_SPKLEF(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * filename;
   SpiceInt              handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "filename", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "handle",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_SPKLEF, `filename`, HANDLE");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   filename   = S_STR_ARGV( 0 );

   (void) spklef_c ( filename, &handle);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.l = handle;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
 void              spkobj_c ( ConstSpiceChar  * spk,
                              SpiceCell       * ids )

*/
PROCEDURE CSPICE_SPKOBJ(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset;
   SpiceChar            * spk;
   SpiceCell              ids;

   struct argcheck argcheck[] =
      {
      { OREAD, "spk", (void*)IDL_TYP_STRING, 0, { 0 }, 0},
      { RDWRT, "ids", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_SPKOBJ, spk, (IDS)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[1].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   spk = S_STR_ARGV( 0 );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[1]->value.s.arr->data);
   pack_cell( &ids, 1, tag_offset, Argv );

   spkobj_c ( spk, &ids );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( ids, SCALAR );

   /*
   Unpack the data from 'ids' to 'Argv'.
   */
   unpack_cell( 1, tag_offset, &ids, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkopa_c ( ConstSpiceChar    * file,
                                SpiceInt          * handle )
*/
PROCEDURE CSPICE_SPKOPA(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * file;
   SpiceInt              handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "file",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_SPKOPA, `file`, HANDLE");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   file    = S_STR_ARGV( 0 );

   spkopa_c( file, &handle);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.l = handle;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkopn_c ( ConstSpiceChar    * name,
                                ConstSpiceChar    * ifname,
                                SpiceInt            ncomch,
                                SpiceInt          * handle  )
*/
PROCEDURE CSPICE_SPKOPN(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * name;
   SpiceChar           * ifname;
   SpiceInt              ncomch;
   SpiceInt              handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "name",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "ifname", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "ncomch", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_SPKOPN, `name`, `ifname`, ncomch, HANDLE");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   name   = S_STR_ARGV( 0 );
   ifname = S_STR_ARGV( 1 );
   ncomch = S_INT_ARGV( 2 );

   spkopn_c( name, ifname, ncomch, &handle);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[3]->value.l = handle;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkpos_c ( ConstSpiceChar    * targ,
                                SpiceDouble         et,
                                ConstSpiceChar    * ref,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceChar    * obs,
                                SpiceDouble         ptarg[3],
                                SpiceDouble       * lt        )
*/
PROCEDURE CSPICE_SPKPOS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceChar            * targ;
   SpiceDouble            et;
   SpiceChar            * ref;
   SpiceChar            * abcorr;
   SpiceChar            * obs;
   SpiceDouble          * ptarg;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "targ",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "ref",    (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obs",    (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "ptarg",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    1},
      { OWRIT, "lt",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_SPKPOS, `targ`, _et_, `ref`, `abcorr`, `obs`, "
            "_PTARG[3]_, _LTIME_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   targ   = S_STR_ARGV( 0 );
   ref    = S_STR_ARGV( 2 );
   abcorr = S_STR_ARGV( 3 );
   obs    = S_STR_ARGV( 4 );
   ptarg  = A_DBL_ARGV( 5 );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
   */
   if (extra->ndims == 0)
      {
      /* Scalar input. */
      SpiceDouble            lt;

      et = S_DBL_ARGV( 1 );

      spkpos_c(targ,et,ref,abcorr,obs,ptarg,&lt);

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      Argv[6]->value.d = lt;
      }
   else
      {

      /* Vector input. */
      SpiceDouble          * lt;

      lt = A_DBL_ARGV(6);

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         et = ((SpiceDouble*)(Argv[1]->value.arr->data))[i];

         spkpos_c( targ, et, ref, abcorr, obs, (ptarg +i*3), (lt+i) );

         /*
          Test for a SPICE error signal. If found, display an error message
          to the user then return to the IDL application.
          */
         CHECK_CALL_FAILURE(i);
         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkpvn_c ( SpiceInt            handle,
                                ConstSpiceDouble    descr [5],
                                SpiceDouble         et,
                                SpiceInt          * ref,
                                SpiceDouble         state [6],
                                SpiceInt          * center    );
*/
PROCEDURE CSPICE_SPKPVN(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;

   SpiceInt               handle;
   SpiceDouble          * descr;
   SpiceDouble            et;
   SpiceInt               ref;
   SpiceDouble          * state;
   SpiceInt               center;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "descr",  (void*)IDL_TYP_DOUBLE,  1, { 5 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "ref",    (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "state",  (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      { OWRIT, "center", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_SPKPVN, handle, descr[5], et, REF, STATE[6], CENTER");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle  = S_INT_ARGV( 0 );
   descr   = A_DBL_ARGV( 1 );
   et      = S_DBL_ARGV( 2 );
   state   = A_DBL_ARGV( 4 );

   (void) spkpvn_c ( handle,
                     descr,
                     et,
                     &ref,
                     state,
                     &center );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[3]->value.l = ref;
   Argv[5]->value.l = center;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spksfs_c ( SpiceInt            body,
                                SpiceDouble         et,
                                SpiceInt            idlen,
                                SpiceInt          * handle,
                                SpiceDouble         descr [5],
                                SpiceChar         * ident,
                                SpiceBoolean      * found  );
*/
PROCEDURE CSPICE_SPKSFS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;

   SpiceInt               body;
   SpiceDouble            et;
   SpiceInt               idlen;
   SpiceInt               handle;
   SpiceDouble          * descr;
   SpiceChar              ident [SIDLEN+1];
   SpiceBoolean           found;

   struct argcheck argcheck[] =
      {
      { OREAD, "body",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "descr",  (void*)IDL_TYP_DOUBLE,  1, { 5 },    0},
      { OWRIT, "ident",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_SPKSFS, body, et, HANDLE, DESCR[5], IDENT, FOUND");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   body   = S_INT_ARGV( 0 );
   et     = S_DBL_ARGV( 1 );
   descr  = A_DBL_ARGV( 3 );

   idlen  = SIDLEN;

   (void) spksfs_c ( body,
                     et,
                     idlen,
                     &handle,
                     descr,
                     ident,
                     &found  );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[2]->value.l = handle;

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV( 4, ident);

   Argv[5]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkssb_c ( SpiceInt            targ,
                                SpiceDouble         et,
                                ConstSpiceChar    * ref,
                                SpiceDouble         starg[6] )
*/
PROCEDURE CSPICE_SPKSSB(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             targ;
   SpiceDouble          et;
   SpiceChar          * ref;
   SpiceDouble        * starg;

   struct argcheck argcheck[] =
      {
      { OREAD, "targ",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "et",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "ref",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "starg", (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_SPKSSB, targ, et, `ref`, STARG[6]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   targ       = S_INT_ARGV( 0 );
   et         = S_DBL_ARGV( 1 );
   ref        = S_STR_ARGV( 2 );
   starg      = A_DBL_ARGV( 3 );

   spkssb_c(targ,et,ref,starg);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spksub_c ( SpiceInt            handle,
                                SpiceDouble         descr[5],
                                ConstSpiceChar    * ident,
                                SpiceDouble         begin,
                                SpiceDouble         end,
                                SpiceInt            newh    )
*/
PROCEDURE CSPICE_SPKSUB(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceDouble        * descr;
   SpiceChar          * ident;
   SpiceDouble          begin;
   SpiceDouble          end;
   SpiceInt             newh;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "descr",  (void*)IDL_TYP_DOUBLE,  1, { 5 },    0},
      { OREAD, "ident",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "begin",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "end",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "newh",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_SPKSUB, handle, descr[5], `ident`, "
                    "begin, end, newh");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle  = S_INT_ARGV( 0 );
   descr   = A_DBL_ARGV( 1 );
   ident   = S_STR_ARGV( 2 );
   begin   = S_DBL_ARGV( 3 );
   end     = S_DBL_ARGV( 4 );
   newh    = S_INT_ARGV( 5 );

   spksub_c(handle,descr,ident,begin,end,newh);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   Modified 2/8/2002
          void       spkuds_c ( ConstSpiceDouble    descr [5],
                                SpiceInt          * body,
                                SpiceInt          * center,
                                SpiceInt          * frame,
                                SpiceInt          * type,
                                SpiceDouble       * first,
                                SpiceDouble       * last,
                                SpiceInt          * begin,
                                SpiceInt          * end     )
*/
PROCEDURE CSPICE_SPKUDS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   #define ND 2
   #define NI 6

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble           sum[125];
   SpiceDouble           dc[ND];
   SpiceInt              ic[NI];

   struct argcheck argcheck[] =
      {
      { OWRIT, "body",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "center", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "frame",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "type",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "first",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "last",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "begin",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "end",    (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 8)
      {
      USAGE("CSPICE_SPKUDS, BODY, CENTER, FRAME, TYPE, "
            "FIRST, LAST, BEGIN, END");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   dafgs_c( sum );
   dafus_c( sum, ND, NI, dc, ic );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[0]->value.l = ic[0];
   Argv[1]->value.l = ic[1];
   Argv[2]->value.l = ic[2];
   Argv[3]->value.l = ic[3];
   Argv[4]->value.d = dc[0];
   Argv[5]->value.d = dc[1];
   Argv[6]->value.l = ic[4];
   Argv[7]->value.l = ic[5];

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkuef_c ( SpiceInt             handle )
*/
PROCEDURE CSPICE_SPKUEF(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_SPKUEF, handle");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle = S_INT_ARGV( 0 );

   spkuef_c(handle);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkw02_c ( SpiceInt             handle,
                                SpiceInt             body,
                                SpiceInt             center,
                                ConstSpiceChar     * frame,
                                SpiceDouble          first,
                                SpiceDouble          last,
                                ConstSpiceChar     * segid,
                                SpiceDouble          intlen,
                                SpiceInt             n,
                                SpiceInt             polydg,
                                ConstSpiceDouble     cdata [],
                                SpiceDouble          btime     )
*/
PROCEDURE CSPICE_SPKW02(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceInt             body;
   SpiceInt             center;
   SpiceChar          * frame;
   SpiceDouble          first;
   SpiceDouble          last;
   SpiceChar          * segid;
   SpiceDouble          intlen;
   SpiceInt             n;
   SpiceInt             polydg;
   SpiceDouble        * cdata;
   SpiceDouble          btime;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "body",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "center", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "frame",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "first",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "last",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "segid",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "intlen", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "n",      (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "polydg", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "cdata",  (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OREAD, "btime",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 12)
      {
      USAGE("CSPICE_SPKW02, handle, body, center, `frame`, "
            "first, last, `segid`, intlen, n, polydg, cdata[], btime");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle  = S_INT_ARGV( 0 );
   body    = S_INT_ARGV( 1 );
   center  = S_INT_ARGV( 2 );
   frame   = S_STR_ARGV( 3 );
   first   = S_DBL_ARGV( 4 );
   last    = S_DBL_ARGV( 5 );
   segid   = S_STR_ARGV( 6 );
   intlen  = S_DBL_ARGV( 7 );
   n       = S_INT_ARGV( 8 );
   polydg  = S_INT_ARGV( 9 );
   cdata   = A_DBL_ARGV( 10);
   btime   = S_DBL_ARGV( 11);

   spkw02_c(handle,
            body,
            center,
            frame,
            first,
            last,
            segid,
            intlen,
            n,
            polydg,
            cdata,
            btime);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkw03_c ( SpiceInt             handle,
                                SpiceInt             body,
                                SpiceInt             center,
                                ConstSpiceChar     * frame,
                                SpiceDouble          first,
                                SpiceDouble          last,
                                ConstSpiceChar     * segid,
                                SpiceDouble          intlen,
                                SpiceInt             n,
                                SpiceInt             polydg,
                                ConstSpiceDouble     cdata [],
                                SpiceDouble          btime     )
*/
PROCEDURE CSPICE_SPKW03(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceInt             body;
   SpiceInt             center;
   SpiceChar          * frame;
   SpiceDouble          first;
   SpiceDouble          last;
   SpiceChar          * segid;
   SpiceDouble          intlen;
   SpiceInt             n;
   SpiceInt             polydg;
   SpiceDouble        * cdata;
   SpiceDouble          btime;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "body",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "center", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "frame",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "first",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "last",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "segid",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "intlen", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "n",      (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "polydg", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "cdata",  (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OREAD, "btime",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 12)
      {
      USAGE("CSPICE_SPKW03, handle, body, center, `frame`, "
            "first, last, `segid`, intlen, n, polydg, cdata[], btime");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   body       = S_INT_ARGV( 1 );
   center     = S_INT_ARGV( 2 );
   frame      = S_STR_ARGV( 3 );
   first      = S_DBL_ARGV( 4 );
   last       = S_DBL_ARGV( 5 );
   segid      = S_STR_ARGV( 6 );
   intlen     = S_DBL_ARGV( 7 );
   n          = S_INT_ARGV( 8 );
   polydg     = S_INT_ARGV( 9 );
   cdata      = A_DBL_ARGV( 10);
   btime      = S_DBL_ARGV( 11);

   spkw03_c(handle,
            body,
            center,
            frame,
            first,
            last,
            segid,
            intlen,
            n,
            polydg,
            cdata,
            btime);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkw05_c ( SpiceInt             handle,
                                SpiceInt             body,
                                SpiceInt             center,
                                ConstSpiceChar     * frame,
                                SpiceDouble          first,
                                SpiceDouble          last,
                                ConstSpiceChar     * segid,
                                SpiceDouble          gm,
                                SpiceInt             n,
                                ConstSpiceDouble     states [][6],
                                ConstSpiceDouble     epochs []     )
*/
PROCEDURE CSPICE_SPKW05(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceInt             body;
   SpiceInt             center;
   SpiceChar          * frame;
   SpiceDouble          first;
   SpiceDouble          last;
   SpiceChar          * segid;
   SpiceDouble          gm;
   SpiceInt             n;
   SpiceDouble        * states;
   SpiceDouble        * epochs;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "body",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "center", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "frame",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "first",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "last",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "segid",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "gm",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "n",      (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "states", (void*)IDL_TYP_DOUBLE,  2, { 6, 0 }, 0},
      { OREAD, "epochs", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 11)
      {
      USAGE("CSPICE_SPKW05, handle, body, center, `frame`, "
            "first, last, `segid`, gm, n, states[6,N], epochs[N]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   body       = S_INT_ARGV( 1 );
   center     = S_INT_ARGV( 2 );
   frame      = S_STR_ARGV( 3 );
   first      = S_DBL_ARGV( 4 );
   last       = S_DBL_ARGV( 5 );
   segid      = S_STR_ARGV( 6 );
   gm         = S_DBL_ARGV( 7 );
   n          = S_INT_ARGV( 8 );
   states     = A_DBL_ARGV( 9 );
   epochs     = A_DBL_ARGV( 10);

   spkw05_c(handle,
            body,
            center,
            frame,
            first,
            last,
            segid,
            gm,
            n,
            (ConstSpiceDouble (*)[6])states,
            epochs);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkw08_c ( SpiceInt             handle,
                                SpiceInt             body,
                                SpiceInt             center,
                                ConstSpiceChar     * frame,
                                SpiceDouble          first,
                                SpiceDouble          last,
                                ConstSpiceChar     * segid,
                                SpiceInt             degree,
                                SpiceInt             n,
                                ConstSpiceDouble     states[][6],
                                SpiceDouble          epoch1,
                                SpiceDouble          step         )
*/
PROCEDURE CSPICE_SPKW08(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceInt             body;
   SpiceInt             center;
   SpiceChar          * frame;
   SpiceDouble          first;
   SpiceDouble          last;
   SpiceChar          * segid;
   SpiceInt             degree;
   SpiceInt             n;
   SpiceDouble        * states;
   SpiceDouble          epoch1;
   SpiceDouble          step;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "body",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "center", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "frame",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "first",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "last",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "segid",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "degree", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "n",      (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "states", (void*)IDL_TYP_DOUBLE,  2, { 6, 0 }, 0},
      { OREAD, "epoch1", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "step",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 12)
      {
      USAGE("CSPICE_SPKW08, handle, body, center, `frame`, "
            "first, last, `segid`, degree, n, states[6,N], epoch1, step");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   body       = S_INT_ARGV( 1 );
   center     = S_INT_ARGV( 2 );
   frame      = S_STR_ARGV( 3 );
   first      = S_DBL_ARGV( 4 );
   last       = S_DBL_ARGV( 5 );
   segid      = S_STR_ARGV( 6 );
   degree     = S_INT_ARGV( 7 );
   n          = S_INT_ARGV( 8 );
   states     = A_DBL_ARGV( 9 );
   epoch1     = S_DBL_ARGV( 10);
   step       = S_DBL_ARGV( 11);

   spkw08_c( handle,
             body,
             center,
             frame,
             first,
             last,
             segid,
             degree,
             n,
             (ConstSpiceDouble (*)[6])states,
             epoch1,
             step);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkw09_c ( SpiceInt             handle,
                                SpiceInt             body,
                                SpiceInt             center,
                                ConstSpiceChar     * frame,
                                SpiceDouble          first,
                                SpiceDouble          last,
                                ConstSpiceChar     * segid,
                                SpiceInt             degree,
                                SpiceInt             n,
                                ConstSpiceDouble     states[][6],
                                ConstSpiceDouble     epochs[]     )
*/
PROCEDURE CSPICE_SPKW09(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceInt             body;
   SpiceInt             center;
   SpiceChar          * frame;
   SpiceDouble          first;
   SpiceDouble          last;
   SpiceChar          * segid;
   SpiceInt             degree;
   SpiceInt             n;
   SpiceDouble        * states;
   SpiceDouble        * epochs;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "body",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "center", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "frame",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "first",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "last",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "segid",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "degree", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "n",      (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "states", (void*)IDL_TYP_DOUBLE,  2, { 6, 0 }, 0},
      { OREAD, "epochs", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 11)
      {
      USAGE("CSPICE_SPKW09, handle, body, center, `frame`, "
            "first, last, `segid`, degree, n, states[6,N], epochs[N]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle  = S_INT_ARGV( 0 );
   body    = S_INT_ARGV( 1 );
   center  = S_INT_ARGV( 2 );
   frame   = S_STR_ARGV( 3 );
   first   = S_DBL_ARGV( 4 );
   last    = S_DBL_ARGV( 5 );
   segid   = S_STR_ARGV( 6 );
   degree  = S_INT_ARGV( 7 );
   n       = S_INT_ARGV( 8 );
   states  = A_DBL_ARGV( 9 );
   epochs  = A_DBL_ARGV( 10);

   spkw09_c( handle,
             body,
             center,
             frame,
             first,
             last,
             segid,
             degree,
             n,
             (ConstSpiceDouble (*)[6])states,
             epochs);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkw10_c ( SpiceInt             handle,
                                SpiceInt             body,
                                SpiceInt             center,
                                ConstSpiceChar     * frame,
                                SpiceDouble          first,
                                SpiceDouble          last,
                                ConstSpiceChar     * segid,
                                ConstSpiceDouble     consts [8],
                                SpiceInt             n,
                                ConstSpiceDouble     elems  [],
                                ConstSpiceDouble     epochs []  )
*/
PROCEDURE CSPICE_SPKW10(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceInt             body;
   SpiceInt             center;
   SpiceChar          * frame;
   SpiceDouble          first;
   SpiceDouble          last;
   SpiceChar          * segid;
   SpiceDouble        * consts;
   SpiceInt             n;
   SpiceDouble        * elems;
   SpiceDouble        * epochs;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "body",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "center", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "frame",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "first",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "last",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "segid",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "consts", (void*)IDL_TYP_DOUBLE,  1, { 8 },    0},
      { OREAD, "n",      (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "elems",  (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OREAD, "epochs", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 11)
      {
      USAGE("CSPICE_SPKW10, handle, body, center, `frame`, "
            "first, last, `segid`, consts[8], n, elems[10*n], epochs[n]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle  = S_INT_ARGV( 0 );
   body    = S_INT_ARGV( 1 );
   center  = S_INT_ARGV( 2 );
   frame   = S_STR_ARGV( 3 );
   first   = S_DBL_ARGV( 4 );
   last    = S_DBL_ARGV( 5 );
   segid   = S_STR_ARGV( 6 );
   consts  = A_DBL_ARGV( 7 );
   n       = S_INT_ARGV( 8 );
   elems   = A_DBL_ARGV( 9 );
   epochs  = A_DBL_ARGV( 10);


   /* Check dimensions of input arrays */
   if ( A_LEN_ARGV(9) != 10*n)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(9, "elems", IDL_VarName(Argv_orig[9]),
                     "The number of elements in array `elems` must have value "
                     "ten times the number TLE records `n`.");
      }

   if ( A_LEN_ARGV(10) != n)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(10, "epochs", IDL_VarName(Argv_orig[10]),
                     "The number of elements in array `epochs` must the same "
                     "value as the number of TLE records 'n`.");
      }

   spkw10_c(handle,
            body,
            center,
            frame,
            first,
            last,
            segid,
            consts,
            n,
            elems,
            epochs);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkw12_c ( SpiceInt             handle,
                                SpiceInt             body,
                                SpiceInt             center,
                                ConstSpiceChar     * frame,
                                SpiceDouble          first,
                                SpiceDouble          last,
                                ConstSpiceChar     * segid,
                                SpiceInt             degree,
                                SpiceInt             n,
                                ConstSpiceDouble     states[][6],
                                SpiceDouble          epoch0,
                                SpiceDouble          step        )
*/
PROCEDURE CSPICE_SPKW12(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceInt             body;
   SpiceInt             center;
   SpiceChar          * frame;
   SpiceDouble          first;
   SpiceDouble          last;
   SpiceChar          * segid;
   SpiceInt             degree;
   SpiceInt             n;
   SpiceDouble        * states;
   SpiceDouble          epoch0;
   SpiceDouble          step;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "body",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "center", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "frame",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "first",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "last",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "segid",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "degree", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "n",      (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "states", (void*)IDL_TYP_DOUBLE,  2, { 6, 0 }, 0},
      { OREAD, "epoch0", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "step",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 12)
      {
      USAGE("CSPICE_SPKW12, handle, body, center, `frame`, "
            "first, last, `segid`, degree, n, states[6,N], epoch0, step");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle  = S_INT_ARGV( 0 );
   body    = S_INT_ARGV( 1 );
   center  = S_INT_ARGV( 2 );
   frame   = S_STR_ARGV( 3 );
   first   = S_DBL_ARGV( 4 );
   last    = S_DBL_ARGV( 5 );
   segid   = S_STR_ARGV( 6 );
   degree  = S_INT_ARGV( 7 );
   n       = S_INT_ARGV( 8 );
   states  = A_DBL_ARGV( 9 );
   epoch0  = S_DBL_ARGV( 10);
   step    = S_DBL_ARGV( 11);

   spkw12_c(handle,
            body,
            center,
            frame,
            first,
            last,
            segid,
            degree,
            n,
            (ConstSpiceDouble (*)[6])states,
            epoch0,
            step);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkw13_c ( SpiceInt             handle,
                                SpiceInt             body,
                                SpiceInt             center,
                                ConstSpiceChar     * frame,
                                SpiceDouble          first,
                                SpiceDouble          last,
                                ConstSpiceChar     * segid,
                                SpiceInt             degree,
                                SpiceInt             n,
                                ConstSpiceDouble     states[][6],
                                ConstSpiceDouble     epochs[]     )
*/
PROCEDURE CSPICE_SPKW13(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceInt             body;
   SpiceInt             center;
   SpiceChar          * frame;
   SpiceDouble          first;
   SpiceDouble          last;
   SpiceChar          * segid;
   SpiceInt             degree;
   SpiceInt             n;
   SpiceDouble        * states;
   SpiceDouble        * epochs;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "body",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "center", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "frame",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "first",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "last",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "segid",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "degree", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "n",      (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "states", (void*)IDL_TYP_DOUBLE,  2, { 6, 0 }, 0},
      { OREAD, "epochs", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 11)
      {
      USAGE("CSPICE_SPKW13, handle, body, center, `frame`, "
            "first, last, `segid`, degree, n, states[6,N], epochs[N]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle  = S_INT_ARGV( 0 );
   body    = S_INT_ARGV( 1 );
   center  = S_INT_ARGV( 2 );
   frame   = S_STR_ARGV( 3 );
   first   = S_DBL_ARGV( 4 );
   last    = S_DBL_ARGV( 5 );
   segid   = S_STR_ARGV( 6 );
   degree  = S_INT_ARGV( 7 );
   n       = S_INT_ARGV( 8 );
   states  = A_DBL_ARGV( 9 );
   epochs  = A_DBL_ARGV( 10);

   spkw13_c(handle,
            body,
            center,
            frame,
            first,
            last,
            segid,
            degree,
            n,
            (ConstSpiceDouble (*)[6])states,
            epochs);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              spkw17_c ( SpiceInt             handle,
                                SpiceInt             body,
                                SpiceInt             center,
                                ConstSpiceChar     * frame,
                                SpiceDouble          first,
                                SpiceDouble          last,
                                ConstSpiceChar     * segid,
                                SpiceDouble          epoch,
                                ConstSpiceDouble     eqel   [9],
                                SpiceDouble          rapol,
                                SpiceDouble          decpol      )
*/
PROCEDURE CSPICE_SPKW17(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             handle;
   SpiceInt             body;
   SpiceInt             center;
   SpiceChar          * frame;
   SpiceDouble          first;
   SpiceDouble          last;
   SpiceChar          * segid;
   SpiceDouble          epoch;
   SpiceDouble        * eqel;
   SpiceDouble          rapol;
   SpiceDouble          decpol;

   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "body",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "center", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "frame",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "first",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "last",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "segid",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "epoch",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "eqel",   (void*)IDL_TYP_DOUBLE,  1, { 9 },    0},
      { OREAD, "rapol",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "decpol", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 11)
      {
      USAGE("CSPICE_SPKW17, handle, body, center, `frame`, "
            "first, last, `segid`, epoch, eqel[9], rapol, decpol");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   body       = S_INT_ARGV( 1 );
   center     = S_INT_ARGV( 2 );
   frame      = S_STR_ARGV( 3 );
   first      = S_DBL_ARGV( 4 );
   last       = S_DBL_ARGV( 5 );
   segid      = S_STR_ARGV( 6 );
   epoch      = S_DBL_ARGV( 7 );
   eqel       = A_DBL_ARGV( 8 );
   rapol      = S_DBL_ARGV( 9 );
   decpol     = S_DBL_ARGV( 10);

   spkw17_c(handle,
            body,
            center,
            frame,
            first,
            last,
            segid,
            epoch,
            eqel,
            rapol,
            decpol);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              srfc2s_c ( SpiceInt        code,
                                SpiceInt        bodyid,
                                SpiceInt        srflen,
                                SpiceChar     * srfstr,
                                SpiceBoolean  * isname )
*/
PROCEDURE CSPICE_SRFC2S(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             code;
   SpiceInt             bodyid;
   SpiceChar            srfstr_buf[RET_ARRAY_LEN+1];
   SpiceBoolean         isname;

   struct argcheck argcheck[] =
      {
      { OREAD, "code",   (void*)IDL_TYP_LONG,   0, { 0 },    0},
      { OREAD, "bodyid", (void*)IDL_TYP_LONG,   0, { 0 },    0},
      { OWRIT, "srfstr", (void*)IDL_TYP_STRING, 0, { 0 },    0},
      { OWRIT, "isname", (void*)IDL_TYP_BYTE,   0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_SRFC2S, code, bodyid, `SRFSTR`, ISNAME");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   code     = S_INT_ARGV( 0 );
   bodyid   = S_INT_ARGV( 1 );

   /* Scalar */
   srfc2s_c ( code, bodyid, RET_ARRAY_LEN, srfstr_buf, &isname );

   /*
   Test for a SPICE error signal. If found, display an error message
   to the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV( 2, srfstr_buf);

   Argv[3]->value.c = isname;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              srfcss_c ( SpiceInt             code,
                                ConstSpiceChar     * bodstr,
                                SpiceInt             srflen,
                                SpiceChar          * srfstr,
                                SpiceBoolean       * isname  );
*/
PROCEDURE CSPICE_SRFCSS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             code;
   SpiceChar          * bodstr;
   SpiceChar            srfstr_buf[RET_ARRAY_LEN+1];
   SpiceBoolean         isname;

   struct argcheck argcheck[] =
      {
      { OREAD, "code",   (void*)IDL_TYP_LONG,   0, { 0 },    0},
      { OREAD, "bodstr", (void*)IDL_TYP_STRING, 0, { 0 },    0},
      { OWRIT, "srfstr", (void*)IDL_TYP_STRING, 0, { 0 },    0},
      { OWRIT, "isname", (void*)IDL_TYP_BYTE,   0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_SRFCSS, code, `bodstr`, `SRFSTR`, ISNAME");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   code     = S_INT_ARGV( 0 );
   bodstr   = S_STR_ARGV( 1 );

   /* Scalar */
   srfcss_c ( code, bodstr, RET_ARRAY_LEN, srfstr_buf, &isname );

   /*
   Test for a SPICE error signal. If found, display an error message
   to the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV( 2, srfstr_buf);

   Argv[3]->value.c = isname;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              srfnrm_c ( ConstSpiceChar     * method,
                                ConstSpiceChar     * target,
                                SpiceDouble          et,
                                ConstSpiceChar     * fixref,
                                SpiceInt             npts,
                                ConstSpiceDouble     srfpts[][3],
                                SpiceDouble          normls[][3]  );
*/
PROCEDURE CSPICE_SRFNRM(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   ConstSpiceChar      * method;
   ConstSpiceChar      * target;
   SpiceDouble           et;
   ConstSpiceChar      * fixref;
   SpiceInt              npts;
   ConstSpiceDouble    * srfpts;
   SpiceDouble         * normls;

   struct argcheck argcheck[] =
      {
      { OREAD, "method", (void*)IDL_TYP_STRING, 0, { 0 },    0},
      { OREAD, "target", (void*)IDL_TYP_STRING, 0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE, 0, { 0 },    0},
      { OREAD, "fixref", (void*)IDL_TYP_STRING, 0, { 0 },    0},
      { OREAD, "srfpts", (void*)IDL_TYP_DOUBLE, 2, { 3, 0 }, 0},
      { OWRIT, "normls", (void*)IDL_TYP_DOUBLE, 2, { 3, 0 }, 0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_SRFNRM, `method`, `target`, et, `fixref`, "
            "srfpts[3,N], NORMLS[3,N]" );
      }

   if ( Argv_orig[4]->value.arr->n_dim == 1)
      {
      zzicy_argerr(4, "srfpts", IDL_VarName(Argv_orig[4]),
                  "ICY(INVALIDDIM): Matrix `srfpts` must have dimension "
                  "3xN, 2 dimensions. The input argument has 1 dimension. "
                  "Use `reform( argname, 3,1)` to create an Array[3,1] "
                  "argument from an Array[3] argument.");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   method     =  S_STR_ARGV( 0 );
   target     =  S_STR_ARGV( 1 );
   et         =  S_DBL_ARGV( 2 );
   fixref     =  S_STR_ARGV( 3 );
   srfpts     =  A_DBL_ARGV( 4 );

   npts       =  Argv[4]->value.arr->dim[1];

   /*
   Allocate the necessary memory for 'normls'. Check for an error signal.
   */
   normls = alloc_SpiceDouble_C_array ( (int) npts, 3 );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   srfnrm_c ( method,
                 target,
                 et,
                 fixref,
                 npts,
                 (Nx3d)srfpts,
                 (SpiceDouble(*)[3])normls );

   /* Check for SPICE call failure, clean up if failed. */
   if ( failed_c())
      {
      free_SpiceMemory( normls );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   if ( npts > 0 )
      {
      char      *normls_copy;
      int        tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 2;
      tmp_dims[0] = 3;
      tmp_dims[1] = npts;
      normls_copy = IDL_MakeTempArray( IDL_TYP_DOUBLE,
                                       tmp_ndims,
                                       tmp_dims,
                                       IDL_ARR_INI_NOP,
                                       &Argv[5]);

      memmove(normls_copy, normls, 3 * npts * sizeof(SpiceDouble) );
      }

   /*
   Clean up temporary variables
   */
   free_SpiceMemory( normls );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              srfs2c_c ( ConstSpiceChar     * srfstr,
                                ConstSpiceChar     * bodstr,
                                SpiceInt           * code,
                                SpiceBoolean       * found  );
 */
PROCEDURE CSPICE_SRFS2C(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * srfstr;
   SpiceChar          * bodstr;
   SpiceInt             code;
   SpiceBoolean         found;

   struct argcheck argcheck[] =
      {
      { OREAD, "srfstr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "bodstr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "code",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_SRFS2C, `srfstr`, `bodstr`, CODE, FOUND");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   srfstr  = S_STR_ARGV( 0 );
   bodstr  = S_STR_ARGV( 1 );

   /* Scalar */
   (void) srfs2c_c ( srfstr, bodstr, &code, &found );

   /*
   Test for a SPICE error signal. If found, display an error message
   to the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[2]->value.l = code;
   Argv[3]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              srfrec_c ( SpiceInt      body,
                                SpiceDouble   longitude,
                                SpiceDouble   latitude,
                                SpiceDouble   rectan[3] )
*/
PROCEDURE CSPICE_SRFREC(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR             * Argv;
   struct extra_dims    * extra;

   SpiceInt               body;
   SpiceDouble            longitude;
   SpiceDouble            latitude;
   SpiceDouble          * rectan;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "body",      (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "longitude", (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "latitude",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "rectan",    (void*)IDL_TYP_DOUBLE,  1, { 3 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_SRFREC, body, _longitude_, _latitude_, "
            "_RECTAN[3]_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   body   = S_INT_ARGV( 0 );
   rectan = A_DBL_ARGV( 3 );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
   */
   if (extra->ndims == 0)
      {
      /* Scalar input. */
      longitude = S_DBL_ARGV( 1 );
      latitude  = S_DBL_ARGV( 2 );

      srfrec_c( body, longitude, latitude, rectan );

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );
      }
   else
      {
      /* Vector input. */

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         longitude = ((SpiceDouble*)(Argv[1]->value.arr->data))[i];
         latitude  = ((SpiceDouble*)(Argv[2]->value.arr->data))[i];

         srfrec_c( body, longitude, latitude, (rectan+i*3) );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              srfscc_c ( ConstSpiceChar     * surfce,
                                SpiceInt             bodyid,
                                SpiceInt           * surfid,
                                SpiceBoolean       * found  );
 */
PROCEDURE CSPICE_SRFSCC(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * surfce;
   SpiceInt             bodyid;
   SpiceInt             surfid;
   SpiceBoolean         found;

   struct argcheck argcheck[] =
      {
      { OREAD, "surfce", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "bodyid", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "surfid", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_SRFSCC, `surfce`, bodyid, SURFID, FOUND");
      }


   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   surfce  = S_STR_ARGV( 0 );
   bodyid  = S_INT_ARGV( 1 );

   /* Scalar */
   (void) srfscc_c ( surfce, bodyid, &surfid, &found );

   /*
   Test for a SPICE error signal. If found, display an error message
   to the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[2]->value.l = surfid;
   Argv[3]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*

   void srfxpt_c ( ConstSpiceChar      * method,
                   ConstSpiceChar      * target,
                   SpiceDouble           et,
                   ConstSpiceChar      * abcorr,
                   ConstSpiceChar      * obsrvr,
                   ConstSpiceChar      * dref,
                   ConstSpiceDouble      dvec   [3],
                   SpiceDouble           spoint [3],
                   SpiceDouble         * dist,
                   SpiceDouble         * trgepc,
                   SpiceDouble           obspos [3],
                   SpiceBoolean        * found      )

*/
PROCEDURE CSPICE_SRFXPT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * method;
   SpiceChar           * target;
   SpiceChar           * abcorr;
   SpiceChar           * dref;
   SpiceDouble           et;
   SpiceChar           * obsrvr;
   SpiceDouble         * dvec;
   SpiceDouble         * spoint;
   SpiceDouble         * obspos;
   SpiceBoolean          found;

   SpiceInt              i;

   struct argcheck argcheck[] =
      {
      { OREAD, "method", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "dref",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "dvec",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "spoint", (void*)IDL_TYP_DOUBLE,  1, { 3 },    1},
      { OWRIT, "dist",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "trgepc", (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "obspos", (void*)IDL_TYP_DOUBLE,  1, { 3 },    1},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE,    0, { 0 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 12)
      {
      USAGE("CSPICE_SRFXPT, `method`, `target`, _et_, `abcorr`, `obsrvr`, "
      "`dref`, dvec[3], _SPOINT[3]_, _DIST_, _TRGEPC_, _OBSPOS[3]_, _FOUND_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   method  = S_STR_ARGV( 0 );
   target  = S_STR_ARGV( 1 );
   abcorr  = S_STR_ARGV( 3 );
   obsrvr  = S_STR_ARGV( 4 );
   dref    = S_STR_ARGV( 5 );
   dvec    = A_DBL_ARGV( 6 );
   spoint  = A_DBL_ARGV( 7 );
   obspos  = A_DBL_ARGV( 10 );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
   */
   if (extra->ndims == 0)
      {
      /* Scalar input. */
      SpiceDouble            dist;
      SpiceDouble            trgepc;

      et = S_DBL_ARGV( 2 );

      srfxpt_c( method,
                target,
                et,
                abcorr,
                obsrvr,
                dref,
                dvec,
                spoint,
                &dist,
                &trgepc,
                obspos,
                &found);

      /*
      Test for a SPICE error signal. If found, display an error message to the
      user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      Argv[8]->value.d  = dist;
      Argv[9]->value.d  = trgepc;
      Argv[11]->value.c = found;
      }
   else
      {
      /* Vector input. */
      SpiceDouble          * dist;
      SpiceDouble          * trgepc;

      /*
      Somewhat import to properly declare found_ret (not that the original
      designer made such a mistake).
      */
      char                 * found_ret;

      dist      = A_DBL_ARGV(8);
      trgepc    = A_DBL_ARGV(9);
      found_ret = (char*)Argv[11]->value.arr->data;

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {

         et = ((SpiceDouble*)(Argv[2]->value.arr->data))[i];

         srfxpt_c( method,
                   target,
                   et,
                   abcorr,
                   obsrvr,
                   dref,
                   dvec,
                   (spoint + i*3),
                   (dist+i),
                   (trgepc+i),
                   (obspos + i*3),
                   &found );

         found_ret[i] = (char)found;

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);

         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*

 void              ssize_c  ( SpiceInt             size,
                              SpiceCell          * cell  );

 */
PROCEDURE CSPICE_SSIZE (int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt               size;
   SpiceCell              cell;
   SpiceInt             * tag_offset;

   struct argcheck argcheck[] =
      {
      { OREAD, "size", (void*)IDL_TYP_LONG,   0, { 0 }, 0},
      { RDWRT, "cell", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_SSIZE, size, (CELL)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[1].type = (void*)(IDL_MAX_TYPE + 1);

   /*
    Perform the input argument type checks, allocate any needed
    memory for output args, copy the argument vector to a work copy.
    */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   size = S_INT_ARGV( 0 );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[1]->value.s.arr->data);
   pack_cell( &cell, 1, tag_offset, Argv );

   ssize_c ( size, &cell );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( cell, SCALAR );

   /*
   Unpack the data from 'window' to 'Argv'.
   */
   unpack_cell( 1, tag_offset, &cell, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              stelab_c ( ConstSpiceDouble    pobj[3],
                                ConstSpiceDouble    vobs[3],
                                SpiceDouble         appobj[3] )
*/
PROCEDURE CSPICE_STELAB(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * pobj;
   SpiceDouble        * vobs;
   SpiceDouble        * appobj;

   struct argcheck argcheck[] =
      {
      { OREAD, "pobj",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "vobs",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "appobj", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_STELAB, pobj[3], vobs[3], APPOBJ[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   pobj       = A_DBL_ARGV( 0 );
   vobs       = A_DBL_ARGV( 1 );
   appobj     = A_DBL_ARGV( 2 );

   stelab_c(pobj,vobs,appobj);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              stpool_c ( ConstSpiceChar    * item,
                                SpiceInt            nth,
                                ConstSpiceChar    * contin,
                                SpiceInt            lenout,
                                SpiceChar         * string,
                                SpiceInt          * size,
                                SpiceBoolean      * found  )
*/
PROCEDURE CSPICE_STPOOL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * item;
   SpiceInt              nth;
   SpiceChar           * contin;
   SpiceChar             string_buf[RET_ARRAY_LEN+1];
   SpiceInt              size;
   SpiceBoolean          found;

   struct argcheck argcheck[] =
      {
      { OREAD, "item",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "nth",    (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "contin", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "string", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "size",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_STPOOL, `item`, nth, `contin`, "
                    "`STRING`, SIZE, FOUND");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   item        = S_STR_ARGV( 0 );
   nth         = S_INT_ARGV( 1 );
   contin      = S_STR_ARGV( 2 );

   (void) stpool_c( item,
             nth,
             contin,
             RET_ARRAY_LEN,
             string_buf,
             &size,
             &found);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV( 3, string_buf);

   Argv[4]->value.l = size;
   Argv[5]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              str2et_c ( ConstSpiceChar    * date,
                                SpiceDouble       * et   )
*/
PROCEDURE CSPICE_STR2ET(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceChar            * date;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "date", (void*)IDL_TYP_STRING,  0, { 0 },    1},
      { OWRIT, "et",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_STR2ET, _`str`_, _ET_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory    for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /*  Initialize local variables, to pass to CSPICE  */

   /* Did the user pass a vector for input? */
   if (extra->ndims == 0)
      {

      SpiceDouble           et;

      /* Scalar input. */
      date = S_STR_ARGV( 0 );

      str2et_c( date, &et);

      /*
      Test for a SPICE error signal. If found, display an error message to the
      user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      Argv[1]->value.d = et;

      }
   else
      {
      /* Vector input.*/

      SpiceDouble           * et;

      /* Define the output vector. */
      et = A_DBL_ARGV(1);

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         date = IDL_STRING_STR(&((IDL_STRING*)(Argv[0]->value.arr->data))[i]);

         str2et_c(date, (et+i));

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);

         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void subpnt_c ( ConstSpiceChar       * method,
                   ConstSpiceChar       * target,
                   SpiceDouble            et,
                   ConstSpiceChar       * fixref,
                   ConstSpiceChar       * abcorr,
                   ConstSpiceChar       * obsrvr,
                   SpiceDouble            spoint [3],
                   SpiceDouble          * trgepc,
                   SpiceDouble            srfvec [3] )
*/
PROCEDURE CSPICE_SUBPNT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * method;
   SpiceChar          * target;
   SpiceDouble          et;
   SpiceChar          * fixref;
   SpiceChar          * abcorr;
   SpiceChar          * obsrvr;
   SpiceDouble        * spoint;
   SpiceDouble          trgepc;
   SpiceDouble        * srfvec;

   struct argcheck argcheck[] =
      {
      { OREAD, "method", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "fixref", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "spoint", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "trgepc", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "srfvec", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 9)
      {
      USAGE("CSPICE_SUBPNT, `method`, `target`, et,"
            " `fixref`, `abcorr`, `obsrvr`, "
            "SPOINT[3], TRGEPC, SRFVEC[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   method     = S_STR_ARGV( 0 );
   target     = S_STR_ARGV( 1 );
   et         = S_DBL_ARGV( 2 );
   fixref     = S_STR_ARGV( 3 );
   abcorr     = S_STR_ARGV( 4 );
   obsrvr     = S_STR_ARGV( 5 );
   spoint     = A_DBL_ARGV( 6 );
   srfvec     = A_DBL_ARGV( 8 );

   subpnt_c ( method,
              target,
              et,
              fixref,
              abcorr,
              obsrvr,
              spoint,
              &trgepc,
              srfvec );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[7]->value.d  = trgepc;

  /* Clean up temporary variables */
  zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
  }




/*
   void              subpt_c  ( ConstSpiceChar    * method,
                                ConstSpiceChar    * target,
                                SpiceDouble         et,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceChar    * obsrvr,
                                SpiceDouble         spoint [3],
                                SpiceDouble       * alt         )
*/
PROCEDURE CSPICE_SUBPT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * method;
   SpiceChar           * target;
   SpiceDouble           et;
   SpiceChar           * abcorr;
   SpiceChar           * obsrvr;
   SpiceDouble         * spoint;

   SpiceInt              i;

   struct argcheck argcheck[] =
      {
      { OREAD, "method", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "spoint", (void*)IDL_TYP_DOUBLE,  1, { 3 },    1},
      { OWRIT, "alt",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_SUBPT, `method`, `target`, _et_, `abcorr`, "
            "`obsrvr`, _SPOINT[3]_, _ALT_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   method     = S_STR_ARGV( 0 );
   target     = S_STR_ARGV( 1 );
   abcorr     = S_STR_ARGV( 3 );
   obsrvr     = S_STR_ARGV( 4 );
   spoint     = A_DBL_ARGV( 5 );


   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
   */
   if (extra->ndims == 0)
      {
      /* Scalar input. */
      SpiceDouble            alt;

      et = S_DBL_ARGV( 2 );

      subpt_c(method,target,et,abcorr,obsrvr,spoint,&alt);

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      Argv[6]->value.d = alt;
      }
   else
      {
      /* Vector input. */
      SpiceDouble          * alt;

      alt = A_DBL_ARGV(6);

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         et = ((SpiceDouble*)(Argv[2]->value.arr->data))[i];

         subpt_c( method, target, et, abcorr, obsrvr, (spoint +i*3), (alt+i) );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void             subpt_pl02 ( SpiceInt            handle,
                                 ConstSpiceInt     * dladsc,
                                 ConstSpiceChar    * method,
                                 ConstSpiceChar    * target,
                                 SpiceDouble         et,
                                 ConstSpiceChar    * abcorr,
                                 ConstSpiceChar    * obsrvr,
                                 SpiceDouble         spoint[3],
                                 SpiceDouble       * alt,
                                 SpiceInt          * pltid   )
*/
PROCEDURE CSPICE_SUBPT_PL02(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt            * dladsc;
   SpiceChar           * method;
   SpiceChar           * target;
   SpiceDouble           et;
   SpiceChar           * abcorr;
   SpiceChar           * obsrvr;
   SpiceDouble         * spoint;
   SpiceDouble           alt;
   SpiceInt              plid;


   SpiceDLADescr         descr;


   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "dladsc", (void*)IDL_TYP_LONG,    1, {SPICE_DLA_DSCSIZ}, 0},
      { OREAD, "method", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "spoint", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "alt",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "plid",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 10)
      {
      USAGE("CSPICE_SUBPT_PL02, handle, dladsc[SPICE_DLA_DSCSIZ], "
            "`method`, `target`, et, "
            "`abcorr`, `obsrvr`, SPOINT[3], ALT, PLID" );
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   dladsc     = A_INT_ARGV( 1 );
   method     = S_STR_ARGV( 2 );
   target     = S_STR_ARGV( 3 );
   et         = S_DBL_ARGV( 4 );
   abcorr     = S_STR_ARGV( 5 );
   obsrvr     = S_STR_ARGV( 6 );
   spoint     = A_DBL_ARGV( 7 );


   /*
   Fill in the members of the local DLA descriptor.
   */
   descr.bwdptr = dladsc[0];
   descr.fwdptr = dladsc[1];
   descr.ibase  = dladsc[2];
   descr.isize  = dladsc[3];
   descr.dbase  = dladsc[4];
   descr.dsize  = dladsc[5];
   descr.cbase  = dladsc[6];
   descr.csize  = dladsc[7];


   subpt_pl02 ( handle, &descr, method, target, et,
                abcorr, obsrvr, spoint, &alt,   &plid );


   /* Check for SPICE call failure, clean up if failed. */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[8]->value.d = alt;
   Argv[9]->value.l = plid;

   /*
   Clean up temporary variables
   */
   ICY_ALLOC_CHECK;

   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              subsol_c ( ConstSpiceChar    * method,
                                ConstSpiceChar    * target,
                                SpiceDouble         et,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceChar    * obsrvr,
                                SpiceDouble         spoint[3] )
*/
PROCEDURE CSPICE_SUBSOL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * method;
   SpiceChar          * target;
   SpiceDouble          et;
   SpiceChar          * abcorr;
   SpiceChar          * obsrvr;
   SpiceDouble        * spoint;

   struct argcheck argcheck[] =
      {
      { OREAD, "method", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "spoint", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_SUBSOL, `method`, `target`, et, `abcorr`, "
                    "`obsrvr`, SPOINT[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   method     = S_STR_ARGV( 0 );
   target     = S_STR_ARGV( 1 );
   et         = S_DBL_ARGV( 2 );
   abcorr     = S_STR_ARGV( 3 );
   obsrvr     = S_STR_ARGV( 4 );
   spoint     = A_DBL_ARGV( 5 );

   subsol_c(method,target,et,abcorr,obsrvr,spoint);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


  /* Clean up temporary variables */
  zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
  }




/*
   void            subsol_pl02 ( SpiceInt            handle,
                                 ConstSpiceInt     * dladsc,
                                 ConstSpiceChar    * method,
                                 ConstSpiceChar    * target,
                                 SpiceDouble         et,
                                 ConstSpiceChar    * abcorr,
                                 ConstSpiceChar    * obsrvr,
                                 SpiceDouble         spoint[3],
                                 SpiceDouble       * dist,
                                 SpiceInt          * pltid   )
*/
PROCEDURE CSPICE_SUBSOL_PL02(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt            * dladsc;
   SpiceChar           * method;
   SpiceChar           * target;
   SpiceDouble           et;
   SpiceChar           * abcorr;
   SpiceChar           * obsrvr;
   SpiceDouble         * spoint;
   SpiceDouble           dist;
   SpiceInt              plid;


   SpiceDLADescr         descr;


   struct argcheck argcheck[] =
      {
      { OREAD, "handle", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "dladsc", (void*)IDL_TYP_LONG,    1, {SPICE_DLA_DSCSIZ}, 0},
      { OREAD, "method", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "spoint", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "dist",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "plid",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 10)
      {
      USAGE("CSPICE_SUBSOL_PL02, handle, dladsc[SPICE_DLA_DSCSIZ], "
            "`method`, `target`, et, "
            "`abcorr`, `obsrvr`, SPOINT[3], DIST, PLID" );
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   dladsc     = A_INT_ARGV( 1 );
   method     = S_STR_ARGV( 2 );
   target     = S_STR_ARGV( 3 );
   et         = S_DBL_ARGV( 4 );
   abcorr     = S_STR_ARGV( 5 );
   obsrvr     = S_STR_ARGV( 6 );
   spoint     = A_DBL_ARGV( 7 );


   /*
   Fill in the members of the local DLA descriptor.
   */
   descr.bwdptr = dladsc[0];
   descr.fwdptr = dladsc[1];
   descr.ibase  = dladsc[2];
   descr.isize  = dladsc[3];
   descr.dbase  = dladsc[4];
   descr.dsize  = dladsc[5];
   descr.cbase  = dladsc[6];
   descr.csize  = dladsc[7];


   subsol_pl02 ( handle, &descr, method, target, et,
                 abcorr, obsrvr, spoint, &dist,  &plid );


   /* Check for SPICE call failure, clean up if failed. */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[8]->value.d = dist;
   Argv[9]->value.l = plid;

   /*
   Clean up temporary variables
   */
   ICY_ALLOC_CHECK;

   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void subslr_c ( ConstSpiceChar       * method,
                   ConstSpiceChar       * target,
                   SpiceDouble            et,
                   ConstSpiceChar       * fixref,
                   ConstSpiceChar       * abcorr,
                   ConstSpiceChar       * obsrvr,
                   SpiceDouble            spoint [3],
                   SpiceDouble          * trgepc,
                   SpiceDouble            srfvec [3] )
*/
PROCEDURE CSPICE_SUBSLR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * method;
   SpiceChar          * target;
   SpiceDouble          et;
   SpiceChar          * fixref;
   SpiceChar          * abcorr;
   SpiceChar          * obsrvr;
   SpiceDouble        * spoint;
   SpiceDouble          trgepc;
   SpiceDouble        * srfvec;

   struct argcheck argcheck[] =
      {
      { OREAD, "method", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "fixref", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "spoint", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "trgepc", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "srfvec", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 9)
      {
      USAGE("CSPICE_SUBSLR, `method`, `target`, et,"
            " `fixref`, `abcorr`, `obsrvr`, "
            "SPOINT[3], TRGEPC, SRFVEC[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   method     = S_STR_ARGV( 0 );
   target     = S_STR_ARGV( 1 );
   et         = S_DBL_ARGV( 2 );
   fixref     = S_STR_ARGV( 3 );
   abcorr     = S_STR_ARGV( 4 );
   obsrvr     = S_STR_ARGV( 5 );
   spoint     = A_DBL_ARGV( 6 );
   srfvec     = A_DBL_ARGV( 8 );

   subslr_c ( method,
              target,
              et,
              fixref,
              abcorr,
              obsrvr,
              spoint,
              &trgepc,
              srfvec );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[7]->value.d  = trgepc;


  /* Clean up temporary variables */
  zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
  }



/*
   SpiceDouble       sumad_c  ( ConstSpiceDouble    array[],
                                SpiceInt            n        )
*/
FUNCTION CSPICE_SUMAD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceDouble          retval_c;
   SpiceDouble        * array;
   SpiceInt             n;

   struct argcheck argcheck[] =
      {
      { OREAD, "array", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OREAD, "n",     (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("double  = CSPICE_SUMAD( array[], n )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   array  = A_DBL_ARGV( 0 );
   n      = S_INT_ARGV( 1 );

   retval_c = sumad_c(array,n);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   SpiceInt          sumai_c  ( ConstSpiceInt       array[],
                                SpiceInt            n        )
*/
FUNCTION CSPICE_SUMAI(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceInt             retval_c;
   SpiceInt           * array;
   SpiceInt             n;

   struct argcheck argcheck[] =
      {
      { OREAD, "array", (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { OREAD, "n",     (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("integer = CSPICE_SUMAI( array[], n )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   array  = A_INT_ARGV(0);
   n      = S_INT_ARGV(1);

   retval_c = sumai_c(array,n);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_LONG;
   retval_idl->value.l  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              surfnm_c ( SpiceDouble         a,
                                SpiceDouble         b,
                                SpiceDouble         c,
                                ConstSpiceDouble    point[3],
                                SpiceDouble         normal[3] )
*/
PROCEDURE CSPICE_SURFNM(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          a;
   SpiceDouble          b;
   SpiceDouble          c;
   SpiceDouble        * point;
   SpiceDouble        * normal;

   struct argcheck argcheck[] =
      {
      { OREAD, "a",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "b",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "c",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "point",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "normal", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 5)
      {
      USAGE("CSPICE_SURFNM, a, b, c, point[3], NORMAL[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   a          = S_DBL_ARGV( 0 );
   b          = S_DBL_ARGV( 1 );
   c          = S_DBL_ARGV( 2 );
   point      = A_DBL_ARGV( 3 );
   normal     = A_DBL_ARGV( 4 );

   surfnm_c(a,b,c,point,normal);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              surfpt_c ( ConstSpiceDouble    positn[3],
                                ConstSpiceDouble    u[3],
                                SpiceDouble         a,
                                SpiceDouble         b,
                                SpiceDouble         c,
                                SpiceDouble         point[3],
                                SpiceBoolean      * found     )
*/
PROCEDURE CSPICE_SURFPT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * positn;
   SpiceDouble         * u;
   SpiceDouble           a;
   SpiceDouble           b;
   SpiceDouble           c;
   SpiceDouble         * point;
   SpiceBoolean          found;

   struct argcheck argcheck[] =
      {
      { OREAD, "positn", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "u",      (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "a",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "b",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "c",      (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "point",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_SURFPT, positn[3], u[3], a, b, c, POINT[3], FOUND");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   positn = A_DBL_ARGV( 0 );
   u      = A_DBL_ARGV( 1 );
   a      = S_DBL_ARGV( 2 );
   b      = S_DBL_ARGV( 3 );
   c      = S_DBL_ARGV( 4 );
   point  = A_DBL_ARGV( 5 );

   surfpt_c( positn, u, a, b, c, point, &found);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[6]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              sxform_c ( ConstSpiceChar    * from,
                                ConstSpiceChar    * to,
                                SpiceDouble         et,
                                SpiceDouble         xform[6][6] )
*/
PROCEDURE CSPICE_SXFORM(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * from;
   SpiceChar          * to;
   SpiceDouble          et;
   SpiceDouble        * xform;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "from",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "to",    (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OWRIT, "xform", (void*)IDL_TYP_DOUBLE,  2, { 6, 6 }, 1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_SXFORM, `from`, `to`, _et_, _XFORM[6,6]_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   from  = S_STR_ARGV( 0 );
   to    = S_STR_ARGV( 1 );
   xform = A_DBL_ARGV( 3 );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
   */
   if (extra->ndims == 0)
      {
      /* Scalar input. */
      et = S_DBL_ARGV( 2 );

      sxform_c(from,to,et,(SpiceDouble (*)[6])xform);

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );
      }
   else
      {
      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         et = ((SpiceDouble*)(Argv[2]->value.arr->data))[i];

         sxform_c(from,to,et,(SpiceDouble (*)[6])(xform + i*36) );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              szpool_c ( ConstSpiceChar    * name,
                                SpiceInt          * n,
                                SpiceBoolean      * found )
*/
PROCEDURE CSPICE_SZPOOL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * name;
   SpiceInt              n;
   SpiceBoolean          found;

   struct argcheck argcheck[] =
      {
      { OREAD, "name",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "n",     (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "found", (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_SZPOOL, `name`, N, FOUND");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   name       = S_STR_ARGV( 0 );

   szpool_c (name, &n, &found);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.l = n;
   Argv[2]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              termpt_c ( ConstSpiceChar    * method,
                                ConstSpiceChar    * ilusrc,
                                ConstSpiceChar    * target,
                                SpiceDouble         et,
                                ConstSpiceChar    * fixref,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceChar    * corloc,
                                ConstSpiceChar    * obsrvr,
                                ConstSpiceDouble    refvec[3],
                                SpiceDouble         rolstp,
                                SpiceInt            ncuts,
                                SpiceDouble         schstp,
                                SpiceDouble         soltol,
                                SpiceInt            maxn,
                                SpiceInt          * npts,
                                SpiceDouble         points[][3],
                                SpiceDouble         epochs[],
                                SpiceDouble         tangts[][3]  );
*/
PROCEDURE CSPICE_TERMPT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar          * method;
   SpiceChar          * ilusrc;
   SpiceChar          * target;
   SpiceDouble          et;
   SpiceChar          * fixref;
   SpiceChar          * abcorr;
   SpiceChar          * corloc;
   SpiceChar          * obsrvr;
   SpiceDouble        * refvec;
   SpiceDouble          rolstp;
   SpiceInt             ncuts;
   SpiceDouble          schstp;
   SpiceDouble          soltol;
   SpiceInt             maxn;
   SpiceInt           * npts;
   SpiceDouble        * points;
   SpiceDouble        * epochs;
   SpiceDouble        * tangts;


   struct argcheck argcheck[] =
      {
      { OREAD, "method", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "ilusrc", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "target", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "fixref", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "abcorr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "corloc", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obsrvr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "refvec", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "rolstp", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "ncuts",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "schstp", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "soltol", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "maxn",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "npts",   (void*)IDL_TYP_LONG,    1, { 0 },    0},
      { OWRIT, "points", (void*)IDL_TYP_DOUBLE,  2, { 3, 0 }, 0},
      { OWRIT, "epochs", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OWRIT, "tangts", (void*)IDL_TYP_DOUBLE,  2, { 3, 0 }, 0},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 18)
      {
      USAGE("CSPICE_TERMPT, `method`, `ilusrc`, `target`, et, `fixref`, "
                           "`abcorr`, corloc, `obsrvr`, refvec, rolstp, "
                           "ncuts, schstp, soltol, maxn, NPTS[maxn], "
                           "POINTS[3,maxn], EPOCHS[maxn], TANGTS[3,maxn]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   method     = S_STR_ARGV( 0 );
   ilusrc     = S_STR_ARGV( 1 );
   target     = S_STR_ARGV( 2 );
   et         = S_DBL_ARGV( 3 );
   fixref     = S_STR_ARGV( 4 );
   abcorr     = S_STR_ARGV( 5 );
   corloc     = S_STR_ARGV( 6 );
   obsrvr     = S_STR_ARGV( 7 );
   refvec     = A_DBL_ARGV( 8 );
   rolstp     = S_DBL_ARGV( 9 );
   ncuts      = S_INT_ARGV( 10 );
   schstp     = S_DBL_ARGV( 11 );
   soltol     = S_DBL_ARGV( 12 );
   maxn       = S_INT_ARGV( 13 );

   /*
   Allocate the necessary memory for 'npts', 'points', 'epochs',
   and 'tangts'. Check for an error signal.
   */
   npts = alloc_SpiceInt_C_array( 1, (int)maxn);
   if ( failed_c())
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   points = alloc_SpiceDouble_C_array( (int)maxn, 3);
   if ( failed_c())
      {
      free_SpiceMemory( npts );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   tangts = alloc_SpiceDouble_C_array( (int)maxn, 3);
   if ( failed_c())
      {
      free_SpiceMemory( npts );
      free_SpiceMemory( points );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   epochs = alloc_SpiceDouble_C_array( 1, (int)maxn );
   if ( failed_c())
      {
      free_SpiceMemory( npts );
      free_SpiceMemory( points );
      free_SpiceMemory( tangts );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

      termpt_c ( method,
                 ilusrc,
                 target,
                 et,
                 fixref,
                 abcorr,
                 corloc,
                 obsrvr,
                 refvec,
                 rolstp,
                 ncuts,
                 schstp,
                 soltol,
                 maxn,
                 npts,
                 (SpiceDouble(*)[3])points,
                 epochs,
                 (SpiceDouble(*)[3])tangts );

   if ( failed_c())
      {
      free_SpiceMemory( npts );
      free_SpiceMemory( points );
      free_SpiceMemory( tangts );
      free_SpiceMemory( epochs );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   if ( maxn > 0)
      {
      char      *npts_copy;
      char      *points_copy;
      char      *epochs_copy;
      char      *tangts_copy;
      int        tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = maxn;
      tmp_dims[1] = 0;
      npts_copy   = IDL_MakeTempArray( IDL_TYP_LONG,
                                       tmp_ndims,
                                       tmp_dims,
                                       IDL_ARR_INI_NOP,
                                       &Argv[14]);

      tmp_ndims   = 2;
      tmp_dims[0] = 3;
      tmp_dims[1] = maxn;
      points_copy = IDL_MakeTempArray( IDL_TYP_DOUBLE,
                                       tmp_ndims,
                                       tmp_dims,
                                       IDL_ARR_INI_NOP,
                                       &Argv[15]);

      tmp_ndims   = 1;
      tmp_dims[0] = maxn;
      tmp_dims[1] = 0;
      epochs_copy = IDL_MakeTempArray( IDL_TYP_DOUBLE,
                                       tmp_ndims,
                                       tmp_dims,
                                       IDL_ARR_INI_NOP,
                                       &Argv[16]);

      tmp_ndims   = 2;
      tmp_dims[0] = 3;
      tmp_dims[1] = maxn;
      tangts_copy = IDL_MakeTempArray( IDL_TYP_DOUBLE,
                                       tmp_ndims,
                                       tmp_dims,
                                       IDL_ARR_INI_NOP,
                                       &Argv[17]);

      memmove(npts_copy,   npts,       maxn * sizeof(SpiceInt)    );
      memmove(points_copy, points, 3 * maxn * sizeof(SpiceDouble) );
      memmove(epochs_copy, epochs,     maxn * sizeof(SpiceDouble) );
      memmove(tangts_copy, tangts, 3 * maxn * sizeof(SpiceDouble) );
      }

   /*
   Clean up temporary variables
   */
   free_SpiceMemory( npts );
   free_SpiceMemory( points );
   free_SpiceMemory( epochs );
   free_SpiceMemory( tangts );
   ICY_ALLOC_CHECK;

   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              term_pl02 ( SpiceInt              handle,
                                 ConstSpiceDLADescr  * dladsc,
                                 ConstSpiceChar      * trmtyp,
                                 ConstSpiceChar      * source,
                                 ConstSpiceChar      * target,
                                 SpiceDouble           et,
                                 ConstSpiceChar      * fixfrm,
                                 ConstSpiceChar      * abcorr,
                                 ConstSpiceChar      * obsrvr,
                                 SpiceInt              npoints,
                                 SpiceDouble         * trgepc,
                                 SpiceDouble           obspos   [3],
                                 SpiceDouble           termpts  [][3],
                                 SpiceInt              plateIDs []     )
*/
PROCEDURE CSPICE_TERM_PL02(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceInt              handle;
   SpiceInt            * dladsc;
   SpiceChar           * trmtyp;
   SpiceChar           * source;
   SpiceChar           * target;
   SpiceDouble           et;
   SpiceChar           * fixfrm;
   SpiceChar           * abcorr;
   SpiceChar           * obsrvr;
   SpiceInt              npoints;
   SpiceDouble           trgepc;
   SpiceDouble         * obspos;
   SpiceDouble         * termpts   = NULL;
   SpiceInt            * plateIDs  = NULL;


   SpiceDLADescr         descr;


   struct argcheck argcheck[] =
      {
      { OREAD, "handle",   (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "dladsc",   (void*)IDL_TYP_LONG,    1, {SPICE_DLA_DSCSIZ}, 0},
      { OREAD, "trmtyp",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "source",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "target",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "et",       (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "fixfrm",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "abcorr",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "obsrvr",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "npoints",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "trgepc",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "obspos",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "termpts",  (void*)IDL_TYP_DOUBLE,  2, { 3, 0 }, 0},
      { OWRIT, "plateIDs", (void*)IDL_TYP_LONG,    1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */

   if (Argc != 14)
      {
      USAGE("CSPICE_TERM_PL02, handle, dladsc[SPICE_DLA_DSCSIZ], "
            "`trmtyp`, `source', "
            "`target`, et, `fixfrm`, `abcorr`, `obsrvr`, npoints, "
            "TRGEPC, OBSPOS[3], TERMPTS[3, npoints], PLATEIDS[npoints]" );
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   handle     = S_INT_ARGV( 0 );
   dladsc     = A_INT_ARGV( 1 );
   trmtyp     = S_STR_ARGV( 2 );
   source     = S_STR_ARGV( 3 );
   target     = S_STR_ARGV( 4 );
   et         = S_DBL_ARGV( 5 );
   fixfrm     = S_STR_ARGV( 6 );
   abcorr     = S_STR_ARGV( 7 );
   obsrvr     = S_STR_ARGV( 8 );
   npoints    = S_INT_ARGV( 9 );

   /*
   Note: an assignment for trgepc (arg 10) is not needed here.
   */
   obspos     = A_DBL_ARGV( 11 );

   if ( npoints <= 0)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(9, "npoints", IDL_VarName(Argv_orig[9]),
                     "`npoints` must be greater-than zero.");
      }


   /*
   Fill in the members of the local DLA descriptor.
   */
   descr.bwdptr = dladsc[0];
   descr.fwdptr = dladsc[1];
   descr.ibase  = dladsc[2];
   descr.isize  = dladsc[3];
   descr.dbase  = dladsc[4];
   descr.dsize  = dladsc[5];
   descr.cbase  = dladsc[6];
   descr.csize  = dladsc[7];


   /*
   Allocate the necessary memory for the `termpts' and
   `plateIDs' output arrays. Check for an error signal.

   Allocate memory only if npoints > 0. It's an error if
   this condition is not met; term_pl02 will signal it.
   */
   if ( npoints > 0 )
   {

      termpts = alloc_SpiceDouble_C_array ( 1, (int)(3*npoints) );

      if ( failed_c() )
      {
         ICY_ALLOC_CHECK;
         zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

         icy_fail(SCALAR);
      }


      plateIDs = alloc_SpiceInt_C_array ( 1, (int)npoints );

      if ( failed_c() )
      {
         free_SpiceMemory( termpts );

         ICY_ALLOC_CHECK;
         zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

         icy_fail(SCALAR);
      }
   }


   term_pl02 ( handle,  &descr,   trmtyp,  source,  target,  et,
               fixfrm,  abcorr,  obsrvr,   npoints, &trgepc, obspos,
               (SpiceDouble(*)[3])termpts,          plateIDs        );


   /* Check for SPICE call failure, clean up if failed. */
   if ( failed_c() )
   {
      free_SpiceMemory( termpts  );
      free_SpiceMemory( plateIDs );

         ICY_ALLOC_CHECK;
         zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

         icy_fail(SCALAR);
   }

   /*
   Set our one scalar output argument.
   */
   Argv[10]->value.d = trgepc;


   /*
   Create termpts and plateIDs output arguments.

   Note that we don't handle the case npoints == 0 here since
   term_pl02 will already have signaled an error.
   */

   {
      char      *termpts_copy;
      int        tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims    = 2;
      tmp_dims[0]  = 3;
      tmp_dims[1]  = npoints;
      termpts_copy = IDL_MakeTempArray( IDL_TYP_DOUBLE,
                                        tmp_ndims,
                                        tmp_dims,
                                        IDL_ARR_INI_NOP,
                                        &Argv[12]);

      memmove( termpts_copy, termpts, npoints * 3 * sizeof(SpiceDouble) );
   }

   {
      char       * plateIDs_copy;
      int          tmp_ndims;
      IDL_MEMINT   tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims     = 1;
      tmp_dims[0]   = npoints;
      plateIDs_copy = IDL_MakeTempArray(IDL_TYP_LONG,    tmp_ndims, tmp_dims,
                                        IDL_ARR_INI_NOP, &Argv[13]);
      memmove( plateIDs_copy, plateIDs, npoints * sizeof(SpiceInt) );
   }


   /*
   Clean up temporary variables
   */
   free_SpiceMemory( termpts  );
   free_SpiceMemory( plateIDs );


   /*
   Clean up temporary variables
   */
   ICY_ALLOC_CHECK;
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              timdef_c ( ConstSpiceChar    * action,
                                ConstSpiceChar    * item,
                                SpiceInt            lenout,
                                SpiceChar         * value )
*/
PROCEDURE CSPICE_TIMDEF(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * item;
   SpiceChar           * value;
   SpiceChar           * action;
   SpiceChar             value_buf[RET_ARRAY_LEN+1];

   struct argcheck argcheck[] =
      {
      { OREAD, "action", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "item",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { RDWRT, "value",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_TIMDEF, `action`, `item`, `(VALUE)`");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   memset( value_buf, 0, RET_ARRAY_LEN * sizeof(SpiceChar) );

   /* Initialize local variables, to pass to CSPICE */
   action     = S_STR_ARGV( 0 );
   item       = S_STR_ARGV( 1 );

   if ( eqstr_c( action, "SET" ) )
      {
      value = S_STR_ARGV( 2 );
      strncpy( value_buf, (char*) value, RET_ARRAY_LEN );
      }

   timdef_c( action, item, RET_ARRAY_LEN, value_buf);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /*
   If the action defined a GET, return the string to IDL.
   */
   if ( eqstr_c( action, "GET" ) )
      {

      /*
      Note, this is a copy operation.
      */
      S_STR_RET_ARGV( 2, value_buf );
      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              timout_c ( SpiceDouble         et,
                                ConstSpiceChar    * pictur,
                                SpiceInt            lenout,
                                SpiceChar         * output )
*/
PROCEDURE CSPICE_TIMOUT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          et;
   SpiceChar          * pictur;
   SpiceInt             lenout;
   SpiceChar          * output;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "pictur", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "lenout", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "output", (void*)IDL_TYP_STRING,  0, { 0 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_TIMOUT, _et_, `pictur`, lenout, _`OUTPUT`_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   pictur       = S_STR_ARGV( 1 );
   lenout       = S_INT_ARGV( 2 ) + 1;
   output       = alloc_SpiceString ( (int) lenout);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /* Called with vectorized' input arguments? */
   if (extra->ndims == 0)
      {
      /* Scalar input. */
      et = S_DBL_ARGV( 0 );

      timout_c( et, pictur, lenout, output );

      /* Check for SPICE call failure, clean up if failed. */
      if ( failed_c())
         {
         free_SpiceMemory( output );

         zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
         icy_fail(SCALAR);
         }

      /*
      Note, this is a copy operation.
      */
      S_STR_RET_ARGV( 3, output );
      }
   else
      {
      /* Vector input. */

      IDL_STRING * output_sptr = (IDL_STRING*)Argv[3]->value.arr->data;

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         et = ((SpiceDouble*)(Argv[0]->value.arr->data))[i];

         timout_c( et, pictur, lenout, output );

         /* Check for SPICE call failure, clean up if failed. */
         if ( failed_c())
            {
            free_SpiceMemory( output );

            zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
            icy_fail(i);
            }

         IDL_StrStore(&output_sptr[i], output);
         }

      }

   /* Clean up temporary variables */
   free_SpiceMemory( output );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              tipbod_c ( ConstSpiceChar    * ref,
                                SpiceInt            body,
                                SpiceDouble         et,
                                SpiceDouble         tipm[3][3] )
*/
PROCEDURE CSPICE_TIPBOD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * ref;
   SpiceInt             body;
   SpiceDouble          et;
   SpiceDouble        * tipm;

   struct argcheck argcheck[] =
      {
      { OREAD, "ref",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "body", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "et",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "tipm", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_TIPBOD, `ref`, body, et, TIPM[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   ref        = S_STR_ARGV( 0 );
   body       = S_INT_ARGV( 1 );
   et         = S_DBL_ARGV( 2 );
   tipm       = A_DBL_ARGV( 3 );

   /* Scalar */
   tipbod_c(ref,body,et,(SpiceDouble (*)[3])tipm);

   /*
   Test for a SPICE error signal. If found, display an error message
   to the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              tisbod_c ( ConstSpiceChar    * ref,
                                SpiceInt            body,
                                SpiceDouble         et,
                                SpiceDouble         tsipm[6][6] )
*/
PROCEDURE CSPICE_TISBOD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * ref;
   SpiceInt              body;
   SpiceDouble           et;
   SpiceDouble         * tsipm;

   struct argcheck argcheck[] =
      {
      { OREAD, "ref",   (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "body",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "et",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "tsipm", (void*)IDL_TYP_DOUBLE,  2, { 6, 6 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_TISBOD, `ref`, body, et, TSIPM[6,6]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   ref        = S_STR_ARGV( 0 );
   body       = S_INT_ARGV( 1 );
   et         = S_DBL_ARGV( 2 );
   tsipm      = A_DBL_ARGV( 3 );

   /* Scalar */
   tisbod_c(ref,body,et,(SpiceDouble (*)[6])tsipm);

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceChar       * tkvrsn_c ( ConstSpiceChar    * item )
*/
FUNCTION CSPICE_TKVRSN(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * retval_c;
   ConstSpiceChar     * item;

   struct argcheck argcheck[] =
      {
      { OREAD, "item", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("string  = CSPICE_TKVRSN( `item` )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   item = S_STR_ARGV( 0 );


   /* tkvrsn returns a const, cast it to a non const. */

   retval_c = (SpiceChar *) tkvrsn_c(item);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return( IDL_StrToSTRING( retval_c) );
   }




/*
   void              tparse_c ( ConstSpiceChar    * string,
                                SpiceInt            lenout,
                                SpiceDouble       * sp2000,
                                SpiceChar         * errmsg  )
*/
PROCEDURE CSPICE_TPARSE(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * string;
   SpiceDouble           sp2000;
   SpiceChar             errmsg_buf[RET_ARRAY_LEN+1];

   struct argcheck argcheck[] =
      {
      { OREAD, "string", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "sp2000", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "errmsg", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_TPARSE, `string`, SP2000, `ERRMSG`");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   string     = S_STR_ARGV( 0 );

   tparse_c( string, RET_ARRAY_LEN, &sp2000, errmsg_buf);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.d = sp2000;

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV( 2, errmsg_buf);

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              tpictr_c ( ConstSpiceChar    * sample,
                                SpiceInt            lenpictur,
                                SpiceInt            lenerror,
                                SpiceChar         * pictur,
                                SpiceBoolean      * ok,
                                SpiceChar         * error     )
*/
PROCEDURE CSPICE_TPICTR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * sample;
   SpiceInt              lenout;
   SpiceChar           * pictur;
   SpiceBoolean          ok;
   SpiceChar             error [RET_ARRAY_LEN+1];

   struct argcheck argcheck[] =
      {
      { OREAD, "sample", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "lenout", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "pictur", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "ok",     (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      { OWRIT, "error",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 5)
      {
      USAGE("CSPICE_TPICTR, `sample`, lenout, `PICTUR`, OK, `ERROR`");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   sample         = S_STR_ARGV( 0 );
   lenout         = S_INT_ARGV( 1 ) + 1;
   pictur         = alloc_SpiceString ( (int) lenout );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   tpictr_c( sample, lenout, RET_ARRAY_LEN, pictur, &ok, error );

   /* Check for SPICE call failure, clean up if failed. */
   if ( failed_c())
      {
      free_SpiceMemory( pictur );

      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      icy_fail(SCALAR);
      }

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV( 2, pictur);

   Argv[3]->value.c = ok;

   /*
   Note, this is a copy operation.
   */
   S_STR_RET_ARGV( 4, error );

   /* Clean up temporary variables */
   free_SpiceMemory( pictur );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceDouble       trace_c  ( ConstSpiceDouble    matrix[3][3] )
*/
FUNCTION CSPICE_TRACE(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceDouble          retval_c;
   SpiceDouble        * matrix;

   struct argcheck argcheck[] =
      {
      { OREAD, "matrix", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("double  = CSPICE_TRACE( matrix[3,3] )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   matrix     = A_DBL_ARGV( 0 );

   retval_c = trace_c((Nx3d)matrix);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              tsetyr_c ( SpiceInt            year )
*/
PROCEDURE CSPICE_TSETYR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             year;

   struct argcheck argcheck[] =
      {
      { OREAD, "year", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_TSETYR, year");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   year  = S_INT_ARGV( 0 );

   tsetyr_c(year);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceDouble       twopi_c  ( void )
*/
FUNCTION CSPICE_TWOPI(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR     retval_idl;
   SpiceDouble  retval_c;

   /* Check the input contains the correct number of arguments. */
   if (Argc != 0)
      {
      USAGE("double  = CSPICE_TWOPI()");
      }

   retval_c = twopi_c();

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   return retval_idl;
   }




/*
   void              twovec_c ( ConstSpiceDouble    axdef  [3],
                                SpiceInt            indexa,
                                ConstSpiceDouble    plndef [3],
                                SpiceInt            indexp,
                                SpiceDouble         mout   [3][3] )
*/
PROCEDURE CSPICE_TWOVEC(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR    *Argv;
   struct extra_dims *extra;
   SpiceDouble* axdef;
   SpiceInt    indexa;
   SpiceDouble* plndef;
   SpiceInt    indexp;
   SpiceDouble* mout;

   struct argcheck argcheck[] =
      {
      { OREAD, "axdef",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "indexa", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "plndef", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "indexp", (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "mout",   (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 5)
      {
      USAGE("CSPICE_TWOVEC, axdef[3], indexa, plndef[3], "
                    "indexp, MOUT[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   axdef      = A_DBL_ARGV( 0 );
   indexa     = S_INT_ARGV( 1 );
   plndef     = A_DBL_ARGV( 2 );
   indexp     = S_INT_ARGV( 3 );
   mout       = A_DBL_ARGV( 4 );

   twovec_c(axdef,indexa,plndef,indexp,(SpiceDouble (*)[3])mout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceDouble       tyear_c  ( void )
*/
FUNCTION CSPICE_TYEAR(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR     retval_idl;
   SpiceDouble  retval_c;

   /* Check the input contains the correct number of arguments. */
   if (Argc != 0)
      {
      USAGE("double  = CSPICE_TYEAR()");
      }

   retval_c = tyear_c();

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   return retval_idl;
   }




/*
   void              ucase_c  ( SpiceChar         * in,
                                SpiceInt            lenout,
                                SpiceChar         * out    )
*/
PROCEDURE CSPICE_UCASE(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * in;
   SpiceChar           * out_buf;

   struct argcheck argcheck[] =
      {
      { OREAD, "in",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "out", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_UCASE, `in`, `OUT`");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   in         = S_STR_ARGV( 0 );

   /*
   Allow a null input string as a no-op.
   */
   if ( (int) strlen(in) > 0)
      {

      /*
      Allocate the needed memory for the output string. Assign the length
      as 1 plus the string length of the input string. We need the '+1'
      for the C string null terminator.
      */
      out_buf = (SpiceChar*)alloc_SpiceString ( (int) strlen(in) + 1 );

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );

      ucase_c( in, (SpiceInt) strlen(in) + (SpiceInt)1, out_buf);

      /* Check for SPICE call failure, clean up if failed. */
      if ( failed_c())
         {
         free_SpiceMemory( out_buf );

         zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
         icy_fail(SCALAR);
         }

      /*
      Note, this is a copy operation.
      */
      S_STR_RET_ARGV( 1, out_buf );

      /* Done, so free the allocated memory. */
      free_SpiceMemory( out_buf );
      }
   else
      {

      /*
      Return nothing for a empty input string.
      */
      out_buf = NULL;

      /*
      Note, this is a copy operation.
      */
      S_STR_RET_ARGV( 1, out_buf );
      }

   /* Clean up temporary variables */
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              ucrss_c  ( ConstSpiceDouble    v1[3],
                                ConstSpiceDouble    v2[3],
                                SpiceDouble         vout[3] )
*/
PROCEDURE CSPICE_UCRSS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * v1;
   SpiceDouble        * v2;
   SpiceDouble        * vout;

   struct argcheck argcheck[] =
      {
      { OREAD, "v1",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "v2",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "vout", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_UCRSS, v1[3], v2[3], VOUT[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   v1         = A_DBL_ARGV( 0 );
   v2         = A_DBL_ARGV( 1 );
   vout       = A_DBL_ARGV( 2 );

   ucrss_c(v1,v2,vout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*

   void              union_c ( SpiceCell          * a,
                               SpiceCell          * b,
                               SpiceCell          * c );


*/
PROCEDURE CSPICE_UNION(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset1;
   SpiceInt             * tag_offset2;
   SpiceInt             * tag_offset3;
   SpiceCell              a;
   SpiceCell              b;
   SpiceCell              c;

   struct argcheck argcheck[] =
      {
      { OREAD, "a", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0},
      { OREAD, "b", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0},
      { RDWRT, "c", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_UNION, a, b, (C)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[0].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[1].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[2].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );


   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset1 = (SpiceInt*) (Argv[0]->value.s.arr->data);
   tag_offset2 = (SpiceInt*) (Argv[1]->value.s.arr->data);
   tag_offset3 = (SpiceInt*) (Argv[2]->value.s.arr->data);

   pack_cell( &a, 0, tag_offset1, Argv );
   pack_cell( &b, 1, tag_offset2, Argv );
   pack_cell( &c, 2, tag_offset3, Argv );

   union_c ( &a, &b, &c );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM4(  a, b, c, SCALAR );

   /*
   Unpack the data from 'c' to 'Argv'. As the 'a' and 'b' cells
   contain only numeric data, no need to unpack either to ensure
   memory deallocation.
   */
   unpack_cell( 2, tag_offset3, &c, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceDouble       unitim_c ( SpiceDouble         epoch,
                                ConstSpiceChar    * insys,
                                ConstSpiceChar    * outsys )
*/
FUNCTION CSPICE_UNITIM(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceDouble          retval_c;
   SpiceDouble          epoch;
   SpiceChar          * insys;
   SpiceChar          * outsys;

   struct argcheck argcheck[] =
      {
      { OREAD, "epoch",  (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "insys",  (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "outsys", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("double  = CSPICE_UNITIM( epoch, `insys`, `outsys` )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   epoch      = S_DBL_ARGV( 0 );
   insys      = S_STR_ARGV( 1 );
   outsys     = S_STR_ARGV( 2 );

   retval_c = unitim_c(epoch,insys,outsys);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              unload_c ( ConstSpiceChar   * file )
*/
PROCEDURE CSPICE_UNLOAD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceChar          * file;
   SpiceInt             i;

   struct argcheck argcheck[] =
      {
      { OREAD, "file", (void*)IDL_TYP_STRING,  0, { 0 },    1},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("CSPICE_UNLOAD, `file`");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Did the user pass a vector for input? */
   if (extra->ndims == 0)
      {
      /* Scalar input. */
      file = S_STR_ARGV( 0 );

      unload_c( (ConstSpiceChar*) file);

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );
      }
   else
      {
      /* Vector input.*/

      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {

         file = IDL_STRING_STR(&((IDL_STRING*)(Argv[0]->value.arr->data))[i]);

         unload_c( (ConstSpiceChar*) file);

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              unorm_c  ( ConstSpiceDouble    v1[3],
                                SpiceDouble         vout[3],
                                SpiceDouble       * vmag    )
*/
PROCEDURE CSPICE_UNORM(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * v1;
   SpiceDouble         * vout;
   SpiceDouble           vmag;

   struct argcheck argcheck[] =
      {
      { OREAD, "v1",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "vout", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "vmag", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_UNORM, v1[3], VOUT[3], VMAG");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   v1   = A_DBL_ARGV( 0 );
   vout = A_DBL_ARGV( 1 );

   unorm_c( v1, vout, &vmag);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[2]->value.d = vmag;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              unormg_c ( ConstSpiceDouble  * v1,
                                SpiceInt            ndim,
                                SpiceDouble       * vout,
                                SpiceDouble       * vmag )
*/
PROCEDURE CSPICE_UNORMG(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * v1;
   SpiceInt              v1_size;
   SpiceDouble           vout[512];
   SpiceDouble           vmag;

   struct argcheck argcheck[] =
      {
      { OREAD, "v1",   (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OWRIT, "vout", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OWRIT, "vmag", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_UNORMG, v1[], VOUT[], VMAG");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Retrieve input array dimensions (to pass on to C) */
   v1_size  = A_LEN_ARGV(0);

   /* Initialize local variables, to pass to CSPICE */
   v1 = A_DBL_ARGV(0);

   unormg_c( v1, v1_size, vout, &vmag);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   if (v1_size != 0)
      {
      char    *vout_copy;
      int      tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = v1_size;
      vout_copy = IDL_MakeTempArray(IDL_TYP_DOUBLE, tmp_ndims, tmp_dims,
                                    IDL_ARR_INI_NOP, &Argv[1]);

      memmove(vout_copy, vout, v1_size * sizeof(SpiceDouble) );
      }

   Argv[2]->value.d = vmag;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              utc2et_c ( ConstSpiceChar    * utcstr,
                                SpiceDouble       * et   )
*/
PROCEDURE CSPICE_UTC2ET(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceChar           * utcstr;
   SpiceDouble           et;

   struct argcheck argcheck[] =
      {
      { OREAD, "utcstr", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OWRIT, "et",     (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_UTC2ET, `utcstr`, ET");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   utcstr  = S_STR_ARGV( 0 );

   utc2et_c( utcstr, &et);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.d = et;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              vadd_c   ( ConstSpiceDouble    v1[3],
                                ConstSpiceDouble    v2[3],
                                SpiceDouble         vout[3] )
*/
PROCEDURE CSPICE_VADD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * v1;
   SpiceDouble        * v2;
   SpiceDouble        * vout;

   struct argcheck argcheck[] =
      {
      { OREAD, "v1",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "v2",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "vout", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_VADD, v1[3], v2[3], VOUT[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   v1    = A_DBL_ARGV( 0 );
   v2    = A_DBL_ARGV( 1 );
   vout  = A_DBL_ARGV( 2 );

   vadd_c(v1,v2,vout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*

   void              valid_c  ( SpiceInt             size,
                                SpiceInt             n,
                                SpiceCell          * a    );
*/
PROCEDURE CSPICE_VALID(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset;
   SpiceInt               size;
   SpiceInt               n;
   SpiceCell              a;

   struct argcheck argcheck[] =
      {
      { OREAD, "size", (void*)IDL_TYP_LONG,   0, { 0 }, 0},
      { OREAD, "n",    (void*)IDL_TYP_LONG,   0, { 0 }, 0},
      { RDWRT, "a",    (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_VALID, size, n, (SET)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[2].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[2]->value.s.arr->data);

   pack_cell( &a, 2, tag_offset, Argv );

   /* Initialize local variables, to pass to CSPICE */
   size = S_INT_ARGV( 0 );
   n    = S_INT_ARGV( 1 );

   valid_c ( size, n, &a );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( a, SCALAR );

   /*
   Unpack the cells, return the data from 'a' to 'Argv'.
   */
   unpack_cell( 2, tag_offset, &a, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              vaddg_c  ( ConstSpiceDouble  * v1,
                                ConstSpiceDouble  * v2,
                                SpiceInt            ndim,
                                SpiceDouble       * vout )
*/
PROCEDURE CSPICE_VADDG(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * v1;
   SpiceDouble        * v2;
   SpiceInt             v1_size;
   SpiceDouble          vout[512];

   struct argcheck argcheck[] =
      {
      { OREAD, "v1",   (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OREAD, "v2",   (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OWRIT, "vout", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_VADDG, v1[], v2[], VOUT[]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Retrieve input array dimensions (to pass on to C) */
   v1_size    = A_LEN_ARGV(0);

   /* Check dimensions of input arrays */
   if (A_LEN_ARGV(1) != v1_size)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(1, "v2", IDL_VarName(Argv_orig[1]),
      "must have the same "
      "measure of vectorization as `v1`");
      }

   /* Initialize local variables, to pass to CSPICE */
   v1  = (SpiceDouble  *)Argv[0]->value.arr->data;
   v2  = (SpiceDouble  *)Argv[1]->value.arr->data;

   vaddg_c(v1,v2,v1_size,vout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   if (v1_size != 0)
      {
      char    *vout_copy;
      int      tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = v1_size;
      vout_copy   = IDL_MakeTempArray(IDL_TYP_DOUBLE,  tmp_ndims, tmp_dims,
                                      IDL_ARR_INI_NOP, &Argv[2]);

      memmove(vout_copy, vout, v1_size * sizeof(SpiceDouble));
      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              vcrss_c  ( ConstSpiceDouble    v1[3],
                                ConstSpiceDouble    v2[3],
                                SpiceDouble         vout[3] )
*/
PROCEDURE CSPICE_VCRSS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * v1;
   SpiceDouble        * v2;
   SpiceDouble        * vout;

   struct argcheck argcheck[] =
      {
      { OREAD, "v1",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "v2",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "vout", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_VCRSS, v1[3], v2[3], VOUT[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   v1    = A_DBL_ARGV( 0 );
   v2    = A_DBL_ARGV( 1 );
   vout  = A_DBL_ARGV( 2 );

   vcrss_c(v1,v2,vout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceDouble       vdist_c  ( ConstSpiceDouble    v1[3],
                                ConstSpiceDouble    v2[3] )
*/
FUNCTION CSPICE_VDIST(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceDouble          retval_c;
   SpiceDouble        * v1;
   SpiceDouble        * v2;

   struct argcheck argcheck[] =
      {
      { OREAD, "v1", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "v2", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("double  = CSPICE_VDIST( v1[3], v2[3] )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   v1  = A_DBL_ARGV( 0 );
   v2  = A_DBL_ARGV( 1 );

   retval_c = vdist_c(v1,v2);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   SpiceDouble       vdistg_c ( ConstSpiceDouble  * v1,
                                ConstSpiceDouble  * v2,
                                SpiceInt            ndim )
*/
FUNCTION CSPICE_VDISTG(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceDouble          retval_c;
   SpiceDouble        * v1;
   SpiceDouble        * v2;
   SpiceInt             v1_size;

   struct argcheck argcheck[] =
      {
      { OREAD, "v1", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OREAD, "v2", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("double  = CSPICE_VDISTG( v1[], v2[] )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Retrieve input array dimensions (to pass on to C) */
   v1_size    = A_LEN_ARGV(0);

   /* Check dimensions of input arrays */
   if (A_LEN_ARGV(1) != v1_size)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(1, "v2", IDL_VarName(Argv_orig[1]),
      "must have the same "
      "measure of vectorization as `v1`");
      }

   /* Initialize local variables, to pass to CSPICE */
   v1 = (SpiceDouble  *)Argv[0]->value.arr->data;
   v2 = (SpiceDouble  *)Argv[1]->value.arr->data;

   retval_c = vdistg_c(v1,v2,v1_size);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   SpiceDouble       vdot_c   ( ConstSpiceDouble    v1[3],
                                ConstSpiceDouble    v2[3] )
*/
FUNCTION CSPICE_VDOT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceDouble          retval_c;
   SpiceDouble        * v1;
   SpiceDouble        * v2;

   struct argcheck argcheck[] =
      {
      { OREAD, "v1", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "v2", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("double  = CSPICE_VDOT( v1[3], v2[3] )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   v1 = A_DBL_ARGV( 0 );
   v2 = A_DBL_ARGV( 1 );

   retval_c = vdot_c(v1,v2);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   SpiceDouble       vdotg_c  ( ConstSpiceDouble  * v1,
                                ConstSpiceDouble  * v2,
                                SpiceInt            ndim )
*/
FUNCTION CSPICE_VDOTG(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceDouble          retval_c;
   SpiceDouble        * v1;
   SpiceDouble        * v2;
   SpiceInt             v1_size;

   struct argcheck argcheck[] =
      {
      { OREAD, "v1", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OREAD, "v2", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("double  = CSPICE_VDOTG( v1[], v2[] )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Retrieve input array dimensions (to pass on to C) */
   v1_size    = A_LEN_ARGV(0);

   /* Check dimensions of input arrays */
   if (A_LEN_ARGV(1) != v1_size)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(1, "v2", IDL_VarName(Argv_orig[1]),
      "must have the same "
      "measure of vectorization as `v1`");
      }

   /* Initialize local variables, to pass to CSPICE */
   v1  = (SpiceDouble  *)Argv[0]->value.arr->data;
   v2  = (SpiceDouble  *)Argv[1]->value.arr->data;

   retval_c = vdotg_c(v1,v2,v1_size);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              vequ_c   ( ConstSpiceDouble    vin[3],
                                SpiceDouble         vout[3] )
*/
PROCEDURE CSPICE_VEQU(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * vin;
   SpiceDouble        * vout;

   struct argcheck argcheck[] =
      {
      { OREAD, "vin",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "vout", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_VEQU, vin[3], VOUT[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   vin   = A_DBL_ARGV( 0 );
   vout  = A_DBL_ARGV( 1 );

   vequ_c(vin,vout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              vequg_c  ( ConstSpiceDouble  * vin,
                                SpiceInt            ndim,
                                SpiceDouble       * vout )
*/
PROCEDURE CSPICE_VEQUG(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * vin;
   SpiceInt              vin_size;
   SpiceDouble           vout[512];

   struct argcheck argcheck[] =
      {
      { OREAD, "vin",  (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OWRIT, "vout", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_VEQUG, vin[], VOUT[]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Retrieve input array dimensions (to pass on to C) */
   vin_size   = A_LEN_ARGV(0);

   /* Initialize local variables, to pass to CSPICE */
   vin        = (SpiceDouble  *)Argv[0]->value.arr->data;

   vequg_c(vin,vin_size,vout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   if (vin_size != 0)
      {
      char    *vout_copy;
      int      tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = vin_size;
      vout_copy   = IDL_MakeTempArray(IDL_TYP_DOUBLE, tmp_ndims, tmp_dims,
                                      IDL_ARR_INI_NOP, &Argv[1]);

      memmove(vout_copy, vout, vin_size * sizeof(SpiceDouble       ));
      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              vhat_c   ( ConstSpiceDouble    v1  [3],
                                SpiceDouble         vout[3] )
*/
PROCEDURE CSPICE_VHAT(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * v1;
   SpiceDouble        * vout;

   struct argcheck argcheck[] =
      {
      { OREAD, "v1",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "vout", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_VHAT, v1[3], VOUT[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   v1         = A_DBL_ARGV( 0 );
   vout       = A_DBL_ARGV( 1 );

   vhat_c(v1,vout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              vhatg_c  ( ConstSpiceDouble    v1  [3],
                                SpiceInt            ndim,
                                SpiceDouble         vout[3] )
*/
PROCEDURE CSPICE_VHATG(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * v1;
   SpiceInt             v1_size;
   SpiceDouble          vout[512];

   struct argcheck argcheck[] =
      {
      { OREAD, "v1",   (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OWRIT, "vout", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_VHATG, v1[], VOUT[]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Retrieve input array dimensions (to pass on to C) */
   v1_size  = A_LEN_ARGV(0);

   /* Initialize local variables, to pass to CSPICE */
   v1       = A_DBL_ARGV( 0 );

   vhatg_c(v1,v1_size,vout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   if (v1_size != 0)
      {
      char    *vout_copy;
      int      tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = v1_size;
      vout_copy = IDL_MakeTempArray(IDL_TYP_DOUBLE, tmp_ndims, tmp_dims,
                                    IDL_ARR_INI_NOP, &Argv[1]);

      memmove(vout_copy, vout, v1_size * sizeof(SpiceDouble));
      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              vlcom_c  ( SpiceDouble         a,
                                ConstSpiceDouble    v1[3],
                                SpiceDouble         b,
                                ConstSpiceDouble    v2[3],
                                SpiceDouble         sum[3] )
*/
PROCEDURE CSPICE_VLCOM(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          a;
   SpiceDouble        * v1;
   SpiceDouble          b;
   SpiceDouble        * v2;
   SpiceDouble        * sum;

   struct argcheck argcheck[] =
      {
      { OREAD, "a",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "v1",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "b",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "v2",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "sum", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 5)
      {
      USAGE("CSPICE_VLCOM, a, v1[3], b, v2[3], SUM[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   a          = S_DBL_ARGV( 0 );
   v1         = A_DBL_ARGV( 1 );
   b          = S_DBL_ARGV( 2 );
   v2         = A_DBL_ARGV( 3 );
   sum        = A_DBL_ARGV( 4 );

   vlcom_c(a,v1,b,v2,sum);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              vlcom3_c ( SpiceDouble         a,
                                ConstSpiceDouble    v1[3],
                                SpiceDouble         b,
                                ConstSpiceDouble    v2[3],
                                SpiceDouble         c,
                                ConstSpiceDouble    v3[3],
                                SpiceDouble         sum[3] )
*/
PROCEDURE CSPICE_VLCOM3(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          a;
   SpiceDouble        * v1;
   SpiceDouble          b;
   SpiceDouble        * v2;
   SpiceDouble          c;
   SpiceDouble        * v3;
   SpiceDouble        * sum;

   struct argcheck argcheck[] =
      {
      { OREAD, "a",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "v1",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "b",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "v2",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "c",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "v3",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "sum", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 7)
      {
      USAGE("CSPICE_VLCOM3, a, v1[3], b, v2[3], c, v3[3], SUM[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   a          = S_DBL_ARGV( 0 );
   v1         = A_DBL_ARGV( 1 );
   b          = S_DBL_ARGV( 2 );
   v2         = A_DBL_ARGV( 3 );
   c          = S_DBL_ARGV( 4 );
   v3         = A_DBL_ARGV( 5 );
   sum        = A_DBL_ARGV( 6 );

   vlcom3_c(a,v1,b,v2,c,v3,sum);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              vlcomg_c ( SpiceInt            n,
                                SpiceDouble         a,
                                ConstSpiceDouble  * v1,
                                SpiceDouble         b,
                                ConstSpiceDouble  * v2,
                                SpiceDouble       * sum )
*/
PROCEDURE CSPICE_VLCOMG(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceInt             v1_size;

   SpiceDouble          a;
   SpiceDouble        * v1;
   SpiceDouble          b;
   SpiceDouble        * v2;
   SpiceDouble          sum[512];

   struct argcheck argcheck[] =
      {
      { OREAD, "a",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "v1",  (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OREAD, "b",   (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "v2",  (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OWRIT, "sum", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 5)
      {
      USAGE("CSPICE_VLCOMG, a, v1[], b, v2[], SUM[]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Retrieve input array dimensions (to pass on to C) */
   v1_size    = A_LEN_ARGV(1);

   /* Check dimensions of input arrays */
   if (Argv[3]->value.arr->dim[0] != v1_size)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(3, "v2", IDL_VarName(Argv_orig[3]),
      "must have the same "
      "measure of vectorization as `v1`");
      }

   /* Initialize local variables, to pass to CSPICE */
   a   = S_DBL_ARGV(0);
   v1  = A_DBL_ARGV(1);
   b   = S_DBL_ARGV(2);
   v2  = A_DBL_ARGV(3);

   vlcomg_c(v1_size,a,v1,b,v2,sum);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   if (v1_size != 0)
      {
      char    *sum_copy;
      int      tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = v1_size;
      sum_copy = IDL_MakeTempArray(IDL_TYP_DOUBLE, tmp_ndims, tmp_dims,
                                   IDL_ARR_INI_NOP, &Argv[4]);

      memmove(sum_copy, sum, v1_size * sizeof(SpiceDouble));
      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              vminug_c ( ConstSpiceDouble  * vin,
                                SpiceInt            ndim,
                                SpiceDouble       * vout )
*/
PROCEDURE CSPICE_VMINUG(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * vin;
   SpiceInt             vin_size;
   SpiceDouble          vout[512];

   struct argcheck argcheck[] =
      {
      { OREAD, "vin",  (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OWRIT, "vout", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_VMINUG, vin[], VOUT[]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Retrieve input array dimensions (to pass on to C) */
   vin_size  = A_LEN_ARGV(0);

   /* Initialize local variables, to pass to CSPICE */
   vin  = (SpiceDouble  *)Argv[0]->value.arr->data;

   vminug_c(vin,vin_size,vout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   if (vin_size != 0)
      {
      char    *vout_copy;
      int      tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = vin_size;
      vout_copy   = IDL_MakeTempArray(IDL_TYP_DOUBLE, tmp_ndims, tmp_dims,
                                      IDL_ARR_INI_NOP, &Argv[1]);

      memmove(vout_copy, vout, vin_size * sizeof(SpiceDouble));
      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              vminus_c ( ConstSpiceDouble    v1[3],
                                SpiceDouble         vout[3] )
*/
PROCEDURE CSPICE_VMINUS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * v1;
   SpiceDouble        * vout;

   struct argcheck argcheck[] =
      {
      { OREAD, "v1",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "vout", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_VMINUS, v1[3], VOUT[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   v1    = A_DBL_ARGV( 0 );
   vout  = A_DBL_ARGV( 1 );

   vminus_c(v1,vout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceDouble       vnorm_c  ( ConstSpiceDouble    v1[3] )
*/
FUNCTION CSPICE_VNORM(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceDouble          retval_c;
   SpiceDouble        * v1;

   struct argcheck argcheck[] =
      {
      { OREAD, "v1", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("double  = CSPICE_VNORM( v1[3] )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   v1  = A_DBL_ARGV( 0 );

   retval_c = vnorm_c(v1);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   SpiceDouble       vnormg_c ( ConstSpiceDouble  * v1,
                                SpiceInt            ndim )
*/
FUNCTION CSPICE_VNORMG(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceDouble          retval_c;
   SpiceDouble        * v1;
   SpiceInt             v1_size;

   struct argcheck argcheck[] =
      {
      { OREAD, "v1", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("double  = CSPICE_VNORMG( v1[] )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Retrieve input array dimensions (to pass on to C) */
   v1_size  = A_LEN_ARGV(0);

   /* Initialize local variables, to pass to CSPICE */
   v1  = (SpiceDouble  *)Argv[0]->value.arr->data;

   retval_c = vnormg_c(v1,v1_size);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              vpack_c  ( SpiceDouble         x,
                                SpiceDouble         y,
                                SpiceDouble         z,
                                SpiceDouble         v[3] )
*/
PROCEDURE CSPICE_VPACK(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          x;
   SpiceDouble          y;
   SpiceDouble          z;
   SpiceDouble        * v;

   struct argcheck argcheck[] =
      {
      { OREAD, "x", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "y", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "z", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "v", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_VPACK, x, y, z, V[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   x  = S_DBL_ARGV( 0 );
   y  = S_DBL_ARGV( 1 );
   z  = S_DBL_ARGV( 2 );
   v  = A_DBL_ARGV( 3 );

   vpack_c(x,y,z,v);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              vperp_c  ( ConstSpiceDouble    a[3],
                                ConstSpiceDouble    b[3],
                                SpiceDouble         p[3] )
*/
PROCEDURE CSPICE_VPERP(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * a;
   SpiceDouble        * b;
   SpiceDouble        * p;

  struct argcheck argcheck[] =
      {
      { OREAD, "a", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "b", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "p", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_VPERP, a[3], b[3], P[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   a = A_DBL_ARGV( 0 );
   b = A_DBL_ARGV( 1 );
   p = A_DBL_ARGV( 2 );

   vperp_c(a,b,p);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              vprjp_c  ( ConstSpiceDouble    vin   [3],
                                ConstSpicePlane   * plane,
                                SpiceDouble         vout  [3] )
*/
PROCEDURE CSPICE_VPRJP(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * vin;
   SpicePlane         * plane;
   SpiceDouble        * vout;

   struct argcheck argcheck[] =
      {
      { OREAD, "vin",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "plane", (void*)IDL_TYP_STRUCT,  0, { 0 },    0},
      { OWRIT, "vout",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_VPRJP, vin[3], plane, VOUT[3]");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[1].type = s_SpicePlane;

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   vin    = A_DBL_ARGV( 0 );
   plane  = S_PLN_ARGV( 1 );
   vout   = A_DBL_ARGV( 2 );

   vprjp_c(vin,plane,vout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              vprjpi_c ( ConstSpiceDouble    vin    [3],
                                ConstSpicePlane   * projpl,
                                ConstSpicePlane   * invpl,
                                SpiceDouble         vout   [3],
                                SpiceBoolean      * found       )
*/
PROCEDURE CSPICE_VPRJPI(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * vin;
   SpicePlane          * projpl;
   SpicePlane          * invpl;
   SpiceDouble         * vout;
   SpiceBoolean          found;

   struct argcheck argcheck[] =
      {
      { OREAD, "vin",    (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "projpl", (void*)IDL_TYP_STRUCT,  0, { 0 },    0},
      { OREAD, "invpl",  (void*)IDL_TYP_STRUCT,  0, { 0 },    0},
      { OWRIT, "vout",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "found",  (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 5)
      {
      USAGE("CSPICE_VPRJPI, vin[3], projpl, invpl, VOUT[3], FOUND");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[1].type = s_SpicePlane;
   argcheck[2].type = s_SpicePlane;

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   vin     = A_DBL_ARGV( 0 );
   projpl  = S_PLN_ARGV( 1 );
   invpl   = S_PLN_ARGV( 2 );
   vout    = A_DBL_ARGV( 3 );

   vprjpi_c( vin, projpl, invpl, vout, &found);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[4]->value.c = found;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              vproj_c  ( ConstSpiceDouble    a[3],
                                ConstSpiceDouble    b[3],
                                SpiceDouble         p[3] )
*/
PROCEDURE CSPICE_VPROJ(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * a;
   SpiceDouble        * b;
   SpiceDouble        * p;

   struct argcheck argcheck[] =
      {
      { OREAD, "a", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "b", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "p", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_VPROJ, a[3], b[3], P[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   a  = A_DBL_ARGV( 0 );
   b  = A_DBL_ARGV( 1 );
   p  = A_DBL_ARGV( 2 );

   vproj_c(a,b,p);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceDouble       vrel_c   ( ConstSpiceDouble    v1[3],
                                ConstSpiceDouble    v2[3]  )
*/
FUNCTION CSPICE_VREL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceDouble          retval_c;
   SpiceDouble        * v1;
   SpiceDouble        * v2;

   struct argcheck argcheck[] =
      {
      { OREAD, "v1", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "v2", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("double  = CSPICE_VREL( v1[3], v2[3] )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   v1  = A_DBL_ARGV( 0 );
   v2  = A_DBL_ARGV( 1 );

   retval_c = vrel_c(v1,v2);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   SpiceDouble       vrelg_c  ( ConstSpiceDouble  * v1,
                                ConstSpiceDouble  * v2,
                                SpiceInt            ndim  )
*/
FUNCTION CSPICE_VRELG(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceDouble          retval_c;
   SpiceDouble        * v1;
   SpiceDouble        * v2;
   SpiceInt             v1_size;

   struct argcheck argcheck[] =
      {
      { OREAD, "v1", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OREAD, "v2", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("double  = CSPICE_VRELG( v1[], v2[] )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Retrieve input array dimensions (to pass on to C) */
   v1_size  = A_LEN_ARGV(0);

   /* Check dimensions of input arrays */
   if (A_LEN_ARGV(1) != v1_size)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(1, "v2", IDL_VarName(Argv_orig[1]),
      "must have the same "
      "measure of vectorization as `v1`");
      }

   /* Initialize local variables, to pass to CSPICE */
   v1  = (SpiceDouble  *)Argv[0]->value.arr->data;
   v2  = (SpiceDouble  *)Argv[1]->value.arr->data;

   retval_c = vrelg_c(v1,v2,v1_size);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              vrotv_c  ( ConstSpiceDouble    v    [3],
                                ConstSpiceDouble    axis [3],
                                SpiceDouble         theta,
                                SpiceDouble         r    [3] )
*/
PROCEDURE CSPICE_VROTV(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * v;
   SpiceDouble        * axis;
   SpiceDouble          theta;
   SpiceDouble        * r;

   struct argcheck argcheck[] =
      {
      { OREAD, "v",     (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "axis",  (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "theta", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "r",     (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_VROTV, v[3], axis[3], theta, R[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   v      = A_DBL_ARGV( 0 );
   axis   = A_DBL_ARGV( 1 );
   theta  = S_DBL_ARGV( 2 );
   r      = A_DBL_ARGV( 3 );

   vrotv_c(v,axis,theta,r);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              vscl_c   ( SpiceDouble         s,
                                ConstSpiceDouble    v1[3],
                                SpiceDouble         vout[3] )
*/
PROCEDURE CSPICE_VSCL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          s;
   SpiceDouble        * v1;
   SpiceDouble        * vout;

   struct argcheck argcheck[] =
      {
      { OREAD, "s",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "v1",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "vout", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_VSCL, s, v1[3], VOUT[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   s     = S_DBL_ARGV( 0 );
   v1    = A_DBL_ARGV( 1 );
   vout  = A_DBL_ARGV( 2 );

   vscl_c(s,v1,vout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              vsclg_c  ( SpiceDouble         s,
                                ConstSpiceDouble  * v1,
                                SpiceInt            ndim,
                                SpiceDouble       * vout  )
*/
PROCEDURE CSPICE_VSCLG(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble          s;
   SpiceDouble        * v1;
   SpiceInt             v1_size;
   SpiceDouble          vout[512];

   struct argcheck argcheck[] =
      {
      { OREAD, "s",    (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "v1",   (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OWRIT, "vout", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_VSCLG, s, v1[], VOUT[]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Retrieve input array dimensions (to pass on to C) */
   v1_size = A_LEN_ARGV(1);

   /* Initialize local variables, to pass to CSPICE */
   s   = S_DBL_ARGV( 0 );
   v1  = (SpiceDouble  *)Argv[1]->value.arr->data;

   vsclg_c(s,v1,v1_size,vout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   if (v1_size != 0)
      {
      char    *vout_copy;
      int      tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = v1_size;
      vout_copy   = IDL_MakeTempArray(IDL_TYP_DOUBLE, tmp_ndims, tmp_dims,
                                      IDL_ARR_INI_NOP, &Argv[2]);

      memmove(vout_copy, vout, v1_size * sizeof(SpiceDouble       ));
      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceDouble       vsep_c   ( ConstSpiceDouble    v1[3],
                                ConstSpiceDouble    v2[3] )
*/
FUNCTION CSPICE_VSEP(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceDouble          retval_c;
   SpiceDouble        * v1;
   SpiceDouble        * v2;

   struct argcheck argcheck[] =
      {
      { OREAD, "v1", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "v2", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("double  = CSPICE_VSEP( v1[3], v2[3] )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   v1  = A_DBL_ARGV( 0 );
   v2  = A_DBL_ARGV( 1 );

   retval_c = vsep_c(v1,v2);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              vsub_c   ( ConstSpiceDouble    v1[3],
                                ConstSpiceDouble    v2[3],
                                SpiceDouble         vout[3] )
*/
PROCEDURE CSPICE_VSUB(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * v1;
   SpiceDouble        * v2;
   SpiceDouble        * vout;

   struct argcheck argcheck[] =
      {
      { OREAD, "v1",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "v2",   (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "vout", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_VSUB, v1[3], v2[3], VOUT[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   v1    = A_DBL_ARGV( 0 );
   v2    = A_DBL_ARGV( 1 );
   vout  = A_DBL_ARGV( 2 );

   vsub_c(v1,v2,vout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              vsubg_c  ( ConstSpiceDouble  * v1,
                                ConstSpiceDouble  * v2,
                                SpiceInt            ndim,
                                SpiceDouble       * vout  )
*/
PROCEDURE CSPICE_VSUBG(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * v1;
   SpiceDouble        * v2;
   SpiceInt             v1_size;
   SpiceDouble          vout[512];

   struct argcheck argcheck[] =
      {
      { OREAD, "v1",   (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OREAD, "v2",   (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OWRIT, "vout", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_VSUBG, v1[], v2[], VOUT[]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Retrieve input array dimensions (to pass on to C) */
   v1_size = A_LEN_ARGV(0);

   /* Check dimensions of input arrays */
   if (A_LEN_ARGV(1) != v1_size)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(1, "v2", IDL_VarName(Argv_orig[1]),
      "must have the same "
      "measure of vectorization as `v1`");
      }

   /* Initialize local variables, to pass to CSPICE */
   v1  = (SpiceDouble  *)Argv[0]->value.arr->data;
   v2  = (SpiceDouble  *)Argv[1]->value.arr->data;

   vsubg_c(v1,v2,v1_size,vout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   if (v1_size != 0)
      {
      char    *vout_copy;
      int      tmp_ndims;
      IDL_MEMINT tmp_dims[IDL_MAX_ARRAY_DIM];

      tmp_ndims   = 1;
      tmp_dims[0] = v1_size;
      vout_copy = IDL_MakeTempArray(IDL_TYP_DOUBLE, tmp_ndims, tmp_dims,
                                    IDL_ARR_INI_NOP, &Argv[2]);

      memmove(vout_copy, vout, v1_size * sizeof(SpiceDouble       ));
      }

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceDouble       vsepg_c  ( ConstSpiceDouble  * v1,
                                ConstSpiceDouble  * v2,
                                SpiceInt            ndim )
*/
FUNCTION CSPICE_VSEPG(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceDouble          retval_c;
   SpiceDouble        * v1;
   SpiceDouble        * v2;
   SpiceInt             v1_size;

   struct argcheck argcheck[] =
      {
      { OREAD, "v1", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OREAD, "v2", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("double  = CSPICE_VSEPG( v1[], v2[] )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Retrieve input array dimensions (to pass on to C) */
   v1_size = A_LEN_ARGV(0);

   /* Check dimensions of input arrays */
   if (A_LEN_ARGV(1) != v1_size)
      {
      zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
      zzicy_argerr(1, "v2", IDL_VarName(Argv_orig[1]),
      "must have the same "
      "measure of vectorization as `v1`");
      }

   /* Initialize local variables, to pass to CSPICE */
   v1         = (SpiceDouble  *)Argv[0]->value.arr->data;
   v2         = (SpiceDouble  *)Argv[1]->value.arr->data;

   retval_c = vsepg_c(v1,v2,v1_size);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   SpiceDouble       vtmv_c   ( ConstSpiceDouble    v1     [3],
                                ConstSpiceDouble    matrix [3][3],
                                ConstSpiceDouble    v2     [3]    )
*/
FUNCTION CSPICE_VTMV(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceDouble          retval_c;
   SpiceDouble        * v1;
   SpiceDouble        * matrix;
   SpiceDouble        * v2;

   struct argcheck argcheck[] =
      {
      { OREAD, "v1",     (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OREAD, "matrix", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      { OREAD, "v2",     (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("double = CSPICE_VTMV( v1[3], matrix[3,3], v2[3] )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   v1      = A_DBL_ARGV( 0 );
   matrix  = A_DBL_ARGV( 1 );
   v2      = A_DBL_ARGV( 2 );

   retval_c = vtmv_c(v1,(Nx3d)matrix,v2);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_DOUBLE;
   retval_idl->value.d  = retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              vupack_c ( ConstSpiceDouble    v[3],
                                SpiceDouble       * x,
                                SpiceDouble       * y,
                                SpiceDouble       * z     )
*/
PROCEDURE CSPICE_VUPACK(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * v;
   SpiceDouble          x;
   SpiceDouble          y;
   SpiceDouble          z;

   struct argcheck argcheck[] =
      {
      { OREAD, "v", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      { OWRIT, "x", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "y", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OWRIT, "z", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_VUPACK, v[3], X, Y, Z");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   v  = A_DBL_ARGV( 0 );

   vupack_c( v, &x, &y, &z);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[1]->value.d = x;
   Argv[2]->value.d = y;
   Argv[3]->value.d = z;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceBoolean      vzero_c  ( ConstSpiceDouble     v[3] )
*/
FUNCTION CSPICE_VZERO(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceBoolean         retval_c;
   SpiceDouble        * v;

   struct argcheck argcheck[] =
      {
      { OREAD, "v", (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("boolean = CSPICE_VZERO( v[3] )");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   v     = A_DBL_ARGV( 0 );

   retval_c = vzero_c(v);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_BYTE;
   retval_idl->value.c  = (RETURN_BOOL) retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   SpiceBoolean      vzerog_c ( ConstSpiceDouble  * v,
                                SpiceInt            ndim )
*/
FUNCTION CSPICE_VZEROG(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   IDL_VPTR             retval_idl;
   SpiceBoolean         retval_c;
   SpiceDouble        * v;
   SpiceInt             v_size;

   struct argcheck argcheck[] =
      {
      { OREAD, "v", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("boolean = CSPICE_VZEROG( v[] )");
      }

   extra  = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Retrieve input array dimensions (to pass on to C) */
   v_size = A_LEN_ARGV(0);

   /* Initialize local variables, to pass to CSPICE */
   v      = (SpiceDouble  *)Argv[0]->value.arr->data;

   retval_c = vzerog_c(v,v_size);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_BYTE;
   retval_idl->value.c  = (RETURN_BOOL) retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   SpiceInt          wncard_c   ( SpiceCell         * cell );
*/
FUNCTION CSPICE_WNCARD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;

   IDL_VPTR               retval_idl = NULL;

   SpiceInt               retval_c;
   SpiceInt             * tag_offset;
   SpiceCell              cell;


   struct argcheck argcheck[] =
      {
      { OREAD, "window", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 1)
      {
      USAGE("integer = CSPICE_WNCARD( (window) )");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[0].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[0]->value.s.arr->data);
   pack_cell( &cell, 0, tag_offset, Argv );

   retval_c = wncard_c ( &cell );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( cell, SCALAR );

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_LONG;
   retval_idl->value.l  = retval_c;

   unpack_cell( 0, tag_offset,  &cell, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              wncomd_c ( SpiceDouble    left,
                                SpiceDouble    right,
                                SpiceCell    * window,
                                SpiceCell    * result )
*/
PROCEDURE CSPICE_WNCOMD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset1;
   SpiceInt             * tag_offset2;
   SpiceDouble            left;
   SpiceDouble            right;
   SpiceCell              window;
   SpiceCell              result;

   struct argcheck argcheck[] =
      {
      { OREAD, "left",   (void*)IDL_TYP_DOUBLE, 0, { 0 }, 0},
      { OREAD, "right",  (void*)IDL_TYP_DOUBLE, 0, { 0 }, 0},
      { OREAD, "window", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0},
      { RDWRT, "result", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_WNCOMD, left, right, window, (RESULT)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[2].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[3].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   left  = S_DBL_ARGV(0);
   right = S_DBL_ARGV(1);

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset1 = (SpiceInt*) (Argv[2]->value.s.arr->data);
   tag_offset2 = (SpiceInt*) (Argv[3]->value.s.arr->data);

   pack_cell( &window, 2, tag_offset1, Argv );
   pack_cell( &result, 3, tag_offset2, Argv );

   wncomd_c ( left, right, &window, &result );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM3( window, result, SCALAR );

   /*
   Unpack the data from 'window' to 'Argv'.
   */
   unpack_cell( 3, tag_offset2, &result, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
 void              wncond_c ( SpiceDouble          left,
                              SpiceDouble          right,
                              SpiceCell          * window )
*/
PROCEDURE CSPICE_WNCOND(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset;
   SpiceDouble            left;
   SpiceDouble            right;
   SpiceCell              window;

   struct argcheck argcheck[] =
      {
      { OREAD, "left",   (void*)IDL_TYP_DOUBLE, 0, { 0 }, 0},
      { OREAD, "right",  (void*)IDL_TYP_DOUBLE, 0, { 0 }, 0},
      { RDWRT, "window", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_WNCOND, left, right, (WINDOW)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[2].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   left  = S_DBL_ARGV(0);
   right = S_DBL_ARGV(1);

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[2]->value.s.arr->data);
   pack_cell( &window, 2, tag_offset, Argv );

   wncond_c ( left, right, &window );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( window, SCALAR );

   /*
   Unpack the data from 'window' to 'Argv' using the same strategy
   used to pack.
   */
   unpack_cell( 2, tag_offset, &window, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              wndifd_c ( SpiceCell          * a,
                                SpiceCell          * b,
                                SpiceCell          * c )
*/
PROCEDURE CSPICE_WNDIFD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset1;
   SpiceInt             * tag_offset2;
   SpiceInt             * tag_offset3;
   SpiceCell              a;
   SpiceCell              b;
   SpiceCell              c;

   struct argcheck argcheck[] =
      {
      { OREAD, "a", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0},
      { OREAD, "b", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0},
      { RDWRT, "c", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_WNDIFD, a, b, (C)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[0].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[1].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[2].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );


   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset1 = (SpiceInt*) (Argv[0]->value.s.arr->data);
   tag_offset2 = (SpiceInt*) (Argv[1]->value.s.arr->data);
   tag_offset3 = (SpiceInt*) (Argv[2]->value.s.arr->data);

   pack_cell( &a, 0, tag_offset1, Argv );
   pack_cell( &b, 1, tag_offset2, Argv );
   pack_cell( &c, 2, tag_offset3, Argv );

   wndifd_c ( &a, &b, &c );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM4(  a, b, c, SCALAR );

   /*
   Unpack the data from 'c' to 'Argv'. As the 'a' and 'b' cells
   contain only numeric data, no need to unpack either to ensure
   memory deallocation.
   */
   unpack_cell( 2, tag_offset3, &c, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }





/*
   SpiceBoolean      wnelmd_c ( SpiceDouble          point,
                                SpiceCell          * window )
*/
FUNCTION CSPICE_WNELMD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceBoolean           retval_c;
   IDL_VPTR               retval_idl = NULL;
   SpiceInt             * tag_offset;
   SpiceDouble            point;
   SpiceCell              window;

   struct argcheck argcheck[] =
      {
      { OREAD, "point",  (void*)IDL_TYP_DOUBLE, 0, { 0 }, 0},
      { RDWRT, "window", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("boolean = CSPICE_WNELMD( point, window)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[1].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   point = S_DBL_ARGV(0);

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[1]->value.s.arr->data);
   pack_cell( &window, 1, tag_offset, Argv );

   retval_c = wnelmd_c ( point, &window );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( window, SCALAR );

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_BYTE;
   retval_idl->value.c  = (RETURN_BOOL) retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
 void              wnexpd_c ( SpiceDouble          left,
                              SpiceDouble          right,
                              SpiceCell          * window )
 */
PROCEDURE CSPICE_WNEXPD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset;
   SpiceDouble            left;
   SpiceDouble            right;
   SpiceCell              window;

   struct argcheck argcheck[] =
      {
      { OREAD, "left",   (void*)IDL_TYP_DOUBLE, 0, { 0 }, 0},
      { OREAD, "right",  (void*)IDL_TYP_DOUBLE, 0, { 0 }, 0},
      { RDWRT, "window", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_WNEXPD, left, right, (WINDOW)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[2].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   left  = S_DBL_ARGV(0);
   right = S_DBL_ARGV(1);

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[2]->value.s.arr->data);
   pack_cell( &window, 2, tag_offset, Argv );

   wnexpd_c ( left, right, &window );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( window, SCALAR );

   /*
   Unpack the data from 'window' to 'Argv'.
   */
   unpack_cell( 2, tag_offset, &window, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
 void              wnextd_c ( SpiceChar            side,
                              SpiceCell          * window )
 */
PROCEDURE CSPICE_WNEXTD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset;
   SpiceChar            * side;
   SpiceCell              window;

   struct argcheck argcheck[] =
      {
      { OREAD, "side",   (void*)IDL_TYP_STRING, 0, { 0 }, 0},
      { RDWRT, "window", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_WNEXTD, `side`, (WINDOW)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[1].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   side = S_STR_ARGV( 0 );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[1]->value.s.arr->data);
   pack_cell( &window, 1, tag_offset, Argv );

   wnextd_c ( *side, &window );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( window, SCALAR );

   /*
   Unpack the data from 'window' to 'Argv'.
   */
   unpack_cell( 1, tag_offset, &window, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }





/*
   void              wnfetd_c ( SpiceCell          * window,
                                SpiceInt             n,
                                SpiceDouble        * left,
                                SpiceDouble        * right   )
*/
PROCEDURE CSPICE_WNFETD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;

   SpiceInt             * tag_offset;
   SpiceCell              window;
   SpiceInt               n;
   SpiceDouble            left;
   SpiceDouble            right;

   struct argcheck argcheck[] =
      {
      { OREAD, "window", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0},
      { OREAD, "n",      (void*)IDL_TYP_LONG,   0, { 0 }, 0},
      { OWRIT, "left",   (void*)IDL_TYP_DOUBLE, 0, { 0 }, 0},
      { OWRIT, "right",  (void*)IDL_TYP_DOUBLE, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 4)
      {
      USAGE("CSPICE_WNFETD, window, n LEFT, RIGHT");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[0].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   tag_offset = (SpiceInt*) (Argv[0]->value.s.arr->data);
   pack_cell( &window, 0, tag_offset, Argv );

   n          = S_INT_ARGV(1);

   wnfetd_c ( &window, n, &left, &right);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( window, SCALAR );

   Argv[2]->value.d = left;
   Argv[3]->value.d = right;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              wnfild_c ( SpiceDouble          small,
                                SpiceCell          * window )
*/
PROCEDURE CSPICE_WNFILD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset;
   SpiceDouble            small;
   SpiceCell              window;

   struct argcheck argcheck[] =
      {
      { OREAD, "small",  (void*)IDL_TYP_DOUBLE, 0, { 0 }, 0},
      { RDWRT, "window", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_WNFILD, small, (WINDOW)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[1].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   small = S_DBL_ARGV(0);

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[1]->value.s.arr->data);
   pack_cell( &window, 1, tag_offset, Argv );

   wnfild_c ( small, &window );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( window, SCALAR );

   /*
   Unpack the data from 'window' to 'Argv'.
   */
   unpack_cell( 1, tag_offset, &window, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              wnfltd_c ( SpiceDouble          small,
                                SpiceCell          * window )
*/
PROCEDURE CSPICE_WNFLTD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset;
   SpiceDouble            small;
   SpiceCell              window;

   struct argcheck argcheck[] =
      {
      { OREAD, "small",  (void*)IDL_TYP_DOUBLE, 0, { 0 }, 0},
      { RDWRT, "window", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_WNFLTD, small, (WINDOW)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[1].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   small = S_DBL_ARGV(0);

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[1]->value.s.arr->data);
   pack_cell( &window, 1, tag_offset, Argv );

   wnfltd_c ( small, &window );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( window, SCALAR );

   /*
   Unpack the data from 'window' to 'Argv'.
   */
   unpack_cell( 1, tag_offset, &window, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceBoolean      wnincd_c ( SpiceDouble          left,
                                SpiceDouble          right,
                                SpiceCell          * window  )
*/
FUNCTION CSPICE_WNINCD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceBoolean           retval_c;
   IDL_VPTR               retval_idl = NULL;
   SpiceInt             * tag_offset;
   SpiceDouble            left;
   SpiceDouble            right;
   SpiceCell              window;

   struct argcheck argcheck[] =
      {
      { OREAD, "left",   (void*)IDL_TYP_DOUBLE, 0, { 0 }, 0},
      { OREAD, "right",  (void*)IDL_TYP_DOUBLE, 0, { 0 }, 0},
      { RDWRT, "window", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("boolean = CSPICE_WNINCD( left, right, window)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[2].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   left  = S_DBL_ARGV(0);
   right = S_DBL_ARGV(1);

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[2]->value.s.arr->data);
   pack_cell( &window, 2, tag_offset, Argv );

   retval_c = wnincd_c ( left, right, &window );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( window, SCALAR );

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_BYTE;
   retval_idl->value.c  = (RETURN_BOOL) retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }




/*
   void              wninsd_c ( SpiceDouble     left,
                                SpiceDouble     right,
                                SpiceCell     * window )
*/
PROCEDURE CSPICE_WNINSD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset;
   SpiceDouble            left;
   SpiceDouble            right;
   SpiceCell              window;

   struct argcheck argcheck[] =
      {
      { OREAD, "left",   (void*)IDL_TYP_DOUBLE, 0, { 0 }, 0},
      { OREAD, "right",  (void*)IDL_TYP_DOUBLE, 0, { 0 }, 0},
      { RDWRT, "window", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_WNINSD, left, right, (WINDOW)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[2].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   left  = S_DBL_ARGV(0);
   right = S_DBL_ARGV(1);

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[2]->value.s.arr->data);
   pack_cell( &window, 2, tag_offset, Argv );

   wninsd_c ( left, right, &window );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( window, SCALAR );

   /*
   Unpack the data from 'window' to 'Argv'.
   */
   unpack_cell( 2, tag_offset, &window, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              wnintd_c ( SpiceCell          * a,
                                SpiceCell          * b,
                                SpiceCell          * c )
*/
PROCEDURE CSPICE_WNINTD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset1;
   SpiceInt             * tag_offset2;
   SpiceInt             * tag_offset3;
   SpiceCell              a;
   SpiceCell              b;
   SpiceCell              c;

   struct argcheck argcheck[] =
      {
      { OREAD, "a", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0},
      { OREAD, "b", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0},
      { RDWRT, "c", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_WNINTD, a, b, (C)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[0].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[1].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[2].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );


   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset1 = (SpiceInt*) (Argv[0]->value.s.arr->data);
   tag_offset2 = (SpiceInt*) (Argv[1]->value.s.arr->data);
   tag_offset3 = (SpiceInt*) (Argv[2]->value.s.arr->data);
   pack_cell( &a, 0, tag_offset1, Argv );
   pack_cell( &b, 1, tag_offset2, Argv );
   pack_cell( &c, 2, tag_offset3, Argv );

   wnintd_c ( &a, &b, &c );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM4( a, b, c, SCALAR );

   /*
   Unpack the data from 'c' to 'Argv'. As the 'a' and 'b' cells
   contain only numeric data, no need to unpack either to ensure
   memory deallocation.
   */
   unpack_cell( 2, tag_offset3, &c, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   SpiceBoolean      wnreld_c ( SpiceCell          * a,
                                ConstSpiceChar     * op,
                                SpiceCell          * b   )
*/
FUNCTION CSPICE_WNRELD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceBoolean           retval_c;
   IDL_VPTR               retval_idl = NULL;
   SpiceInt             * tag_offset1;
   SpiceInt             * tag_offset2;
   SpiceCell              a;
   SpiceCell              b;
   SpiceChar            * op;

   struct argcheck argcheck[] =
      {
      { OREAD, "a",  (void*)IDL_TYP_STRUCT, 0, { 0 }, 0},
      { OREAD, "op", (void*)IDL_TYP_STRING, 0, { 0 }, 0},
      { OREAD, "b",  (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("boolean = CSPICE_WNRELD( a, `op`, b)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[0].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[2].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   op = S_STR_ARGV( 1 );


   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset1 = (SpiceInt*) (Argv[0]->value.s.arr->data);
   tag_offset2 = (SpiceInt*) (Argv[2]->value.s.arr->data);

   pack_cell( &a, 0, tag_offset1, Argv );
   pack_cell( &b, 2, tag_offset2, Argv );

   retval_c = wnreld_c ( &a, op, &b );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM3( a, b, SCALAR );

   retval_idl           = IDL_Gettmp();
   retval_idl->type     = IDL_TYP_BYTE;
   retval_idl->value.c  = (RETURN_BOOL) retval_c;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );

   return retval_idl;
   }






/*
   void              wnsumd_c ( SpiceCell      * window,
                                SpiceDouble    * meas,
                                SpiceDouble    * avg,
                                SpiceDouble    * stddev,
                                SpiceInt       * shortest,
                                SpiceInt       * longest   )
*/
PROCEDURE CSPICE_WNSUMD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceCell              window;
   SpiceInt             * tag_offset;
   SpiceDouble            meas;
   SpiceDouble            avg;
   SpiceDouble            stddev;
   SpiceInt               shortest;
   SpiceInt               longest;

   struct argcheck argcheck[] =
      {
      { OREAD, "window",  (void*)IDL_TYP_STRUCT, 0, { 0 }, 0},
      { OWRIT, "meas",    (void*)IDL_TYP_DOUBLE, 0, { 0 }, 0},
      { OWRIT, "avg",     (void*)IDL_TYP_DOUBLE, 0, { 0 }, 0},
      { OWRIT, "stddev",  (void*)IDL_TYP_DOUBLE, 0, { 0 }, 0},
      { OWRIT, "shortest",(void*)IDL_TYP_LONG,   0, { 0 }, 0},
      { OWRIT, "longest", (void*)IDL_TYP_LONG,   0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
       USAGE("CSPICE_WNSUMD, window, MEAS, AVG, "
                            "STDDEV, SHORTEST, LONGEST");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[0].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[0]->value.s.arr->data);
   pack_cell( &window, 0, tag_offset, Argv );

   wnsumd_c ( &window,
              &meas,
              &avg,
              &stddev,
              &shortest,
              &longest);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( window, SCALAR );

   Argv[1]->value.d = meas;
   Argv[2]->value.d = avg;
   Argv[3]->value.d = stddev;
   Argv[4]->value.l = shortest;
   Argv[5]->value.l = longest;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              wnunid_c ( SpiceCell          * a,
                                SpiceCell          * b,
                                SpiceCell          * c );
*/
PROCEDURE CSPICE_WNUNID(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt             * tag_offset1;
   SpiceInt             * tag_offset2;
   SpiceInt             * tag_offset3;
   SpiceCell              a;
   SpiceCell              b;
   SpiceCell              c;

   struct argcheck argcheck[] =
      {
      { OREAD, "a", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0},
      { OREAD, "b", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0},
      { RDWRT, "c", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_WNUNID, a, b, (C)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, "Item 6" for details.
   */
   argcheck[0].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[1].type = (void*)(IDL_MAX_TYPE + 1);
   argcheck[2].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );


   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset1 = (SpiceInt*) (Argv[0]->value.s.arr->data);
   tag_offset2 = (SpiceInt*) (Argv[1]->value.s.arr->data);
   tag_offset3 = (SpiceInt*) (Argv[2]->value.s.arr->data);
   pack_cell( &a, 0, tag_offset1, Argv );
   pack_cell( &b, 1, tag_offset2, Argv );
   pack_cell( &c, 2, tag_offset3, Argv );

   wnunid_c ( &a, &b, &c );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM4( a, b, c, SCALAR );

   /*
   Unpack the data from 'c' to 'Argv'.
   */
   unpack_cell( 2, tag_offset3, &c, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              wnvald_c ( SpiceInt             size,
                                SpiceInt             n,
                                SpiceCell          * window )
*/
PROCEDURE CSPICE_WNVALD(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {
   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceInt               size;
   SpiceInt               n;
   SpiceCell              window;
   SpiceInt             * tag_offset;

   struct argcheck argcheck[] =
      {
      { OREAD, "size",   (void*)IDL_TYP_LONG,   0, { 0 }, 0},
      { OREAD, "n",      (void*)IDL_TYP_LONG,   0, { 0 }, 0},
      { RDWRT, "window", (void*)IDL_TYP_STRUCT, 0, { 0 }, 0}
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_WNVALD, size, n, (WINDOW)");
      }

   /*
   Set the structure type according to use. Reference the
   Particulars section, item 6 for details.
   */
   argcheck[2].type = (void*)(IDL_MAX_TYPE + 1);

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   size = S_INT_ARGV( 0 );
   n    = S_INT_ARGV( 1 );

   /*
   Pack the IDL cell structure to a cell.
   */
   tag_offset = (SpiceInt*) (Argv[2]->value.s.arr->data);
   pack_cell( &window, 2, tag_offset, Argv );

   wnvald_c ( size, n, &window );

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE_MEM2( window, SCALAR );

   /*
   Unpack the data from 'window' to 'Argv'.
   */
   unpack_cell( 2, tag_offset, &window, Argv );
   ICY_ALLOC_CHECK;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              xf2eul_c ( ConstSpiceDouble     xform  [6][6],
                                SpiceInt             axisa,
                                SpiceInt             axisb,
                                SpiceInt             axisc,
                                SpiceDouble          eulang [6],
                                SpiceBoolean       * unique         )
*/
PROCEDURE CSPICE_XF2EUL(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR             * Argv;
   struct extra_dims    * extra;
   SpiceDouble          * xform;
   SpiceInt               axisa;
   SpiceInt               axisb;
   SpiceInt               axisc;
   SpiceDouble          * eulang;
   SpiceBoolean           unique;

   struct argcheck argcheck[] =
      {
      { OREAD, "xform",  (void*)IDL_TYP_DOUBLE,  2, { 6, 6 }, 0},
      { OREAD, "axisa",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "axisb",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OREAD, "axisc",  (void*)IDL_TYP_LONG,    0, { 0 },    0},
      { OWRIT, "eulang", (void*)IDL_TYP_DOUBLE,  1, { 6 },    0},
      { OWRIT, "unique", (void*)IDL_TYP_BYTE,    0, { 0 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 6)
      {
      USAGE("CSPICE_XF2EUL, xform[6,6], axisa, axisb, axisc, "
            "EULANG[6], UNIQUE");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   xform   = A_DBL_ARGV( 0 );
   axisa   = S_INT_ARGV( 1 );
   axisb   = S_INT_ARGV( 2 );
   axisc   = S_INT_ARGV( 3 );
   eulang  = A_DBL_ARGV( 4 );

   xf2eul_c( (ConstSpiceDouble (*)[6])xform,
             axisa,
             axisb,
             axisc,
             eulang,
             &unique);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   Argv[5]->value.c = unique;

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              xf2rav_c ( ConstSpiceDouble     xform [6][6],
                                SpiceDouble          rot   [3][3],
                                SpiceDouble          av    [3]     )
*/
PROCEDURE CSPICE_XF2RAV(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;
   SpiceDouble        * xform;
   SpiceDouble        * rot;
   SpiceDouble        * av;

   struct argcheck argcheck[] =
      {
      { OREAD, "xform", (void*)IDL_TYP_DOUBLE,  2, { 6, 6 }, 0},
      { OWRIT, "rot",   (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      { OWRIT, "av",    (void*)IDL_TYP_DOUBLE,  1, { 3 },    0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 3)
      {
      USAGE("CSPICE_XF2RAV, xform[6,6], ROT[3,3], AV[3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   xform  = A_DBL_ARGV( 0 );
   rot    = A_DBL_ARGV( 1 );
   av     = A_DBL_ARGV( 2 );

   xf2rav_c( (ConstSpiceDouble (*)[6])xform,
             (SpiceDouble (*)[3])rot,
             av);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void xfmsta_c ( ConstSpiceDouble     input_state[6],
                   ConstSpiceChar     * input_coord_sys,
                   ConstSpiceChar     * output_coord_sys,
                   ConstSpiceChar     * body,
                   SpiceDouble          output_state[6]  )
*/
PROCEDURE CSPICE_XFMSTA(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble    * input_state;
   SpiceChar      * input_coord_sys;
   SpiceChar      * output_coord_sys;
   SpiceChar      * body;
   SpiceDouble    * output_state;

   long                   i;

   struct argcheck argcheck[] =
      {
      { OREAD, "input_state",      (void*)IDL_TYP_DOUBLE,  1, { 6 }, 1},
      { OREAD, "input_coord_sys",  (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "output_coord_sys", (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OREAD, "body",             (void*)IDL_TYP_STRING,  0, { 0 }, 0},
      { OWRIT, "output_state",     (void*)IDL_TYP_DOUBLE,  1, { 6 }, 1},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 5)
      {
      USAGE("CSPICE_XFMSTA, _input_state[6]_, `input_coord_sys`, "
            "`output_coord_sys`, `body`, _OUTPUT_STATE[6]_");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   input_coord_sys  = S_STR_ARGV( 1 );
   output_coord_sys = S_STR_ARGV( 2 );
   body             = S_STR_ARGV( 3 );
   output_state     = A_DBL_ARGV( 4 );

   /*
   Called with `vectorized' input arguments? Test the value of the 'extra'
   struct 'ndims' field.
    */
   if (extra->ndims == 0)
      {
      /* Scalar input. */
      input_state = A_DBL_ARGV ( 0 );

      xfmsta_c( input_state,
                input_coord_sys,
                output_coord_sys,
                body,
                output_state);

      /*
      Test for a SPICE error signal. If found, display an error message to
      the user then return to the IDL application.
      */
      CHECK_CALL_FAILURE( SCALAR );
      }
   else
      {
      /* Loop over each element of the input vector. */
      for ( i=0; i < extra->n_elts; i++)
         {
         input_state = ((SpiceDouble*)(Argv[0]->value.arr->data));

         xfmsta_c( (input_state +i*6),
                    input_coord_sys,
                    output_coord_sys,
                    body,
                   (output_state +i*6) );

         /*
         Test for a SPICE error signal. If found, display an error message
         to the user then return to the IDL application.
         */
         CHECK_CALL_FAILURE(i);
         }

      }

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              xpose_c  ( ConstSpiceDouble    m1  [3][3],
                                SpiceDouble         mout[3][3] )
*/
PROCEDURE CSPICE_XPOSE(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * m1;
   SpiceDouble         * mout;

   struct argcheck argcheck[] =
      {
      { OREAD, "m1",   (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      { OWRIT, "mout", (void*)IDL_TYP_DOUBLE,  2, { 3, 3 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_XPOSE, m1[3,3], MOUT[3,3]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   m1    = A_DBL_ARGV( 0 );
   mout  = A_DBL_ARGV( 1 );

   xpose_c((Nx3d)m1,(SpiceDouble (*)[3])mout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
   void              xpose6_c ( ConstSpiceDouble    m1  [6][6],
                                SpiceDouble         mout[6][6] )
*/
PROCEDURE CSPICE_XPOSE6(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR            * Argv;
   struct extra_dims   * extra;
   SpiceDouble         * m1;
   SpiceDouble         * mout;

   struct argcheck argcheck[] =
      {
      { OREAD, "m1",   (void*)IDL_TYP_DOUBLE,  2, { 6, 6 }, 0},
      { OWRIT, "mout", (void*)IDL_TYP_DOUBLE,  2, { 6, 6 }, 0},
      };


   /* Check the input contains the correct number of arguments. */
   if (Argc != 2)
      {
      USAGE("CSPICE_XPOSE6, m1[6,6], MOUT[6,6]");
      }

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Initialize local variables, to pass to CSPICE */
   m1   = A_DBL_ARGV( 0 );
   mout = A_DBL_ARGV( 1 );

   xpose6_c( (ConstSpiceDouble (*)[6])m1,
             (SpiceDouble      (*)[6])mout);

   /*
   Test for a SPICE error signal. If found, display an error message to the
   user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );


   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*
    This interface exists only to check the behavior of the argument
    check functions in zzicy.c.
*/
PROCEDURE CSPICE_ZZARGS(int Argc, IDL_VPTR Argv_orig[], char *Argk)
   {

   IDL_VPTR           * Argv;
   struct extra_dims  * extra;

   struct argcheck argcheck[] =
      {
      { OREAD, "A", (void*)IDL_TYP_DOUBLE,  0, { 0 },    0},
      { OREAD, "B", (void*)IDL_TYP_DOUBLE,  0, { 0 },    1},
      { OREAD, "C", (void*)IDL_TYP_DOUBLE,  1, { 5 },    0},
      { OREAD, "D", (void*)IDL_TYP_DOUBLE,  1, { 5 },    1},
      { OREAD, "E", (void*)IDL_TYP_DOUBLE,  2, { 3, 7 }, 0},
      { OREAD, "F", (void*)IDL_TYP_DOUBLE,  2, { 3, 7 }, 1},
      { OREAD, "G", (void*)IDL_TYP_DOUBLE,  1, { 0 },    0},
      { OREAD, "H", (void*)IDL_TYP_STRING,  0, { 0 },    0},
      { OREAD, "I", (void*)IDL_TYP_STRING,  0, { 0 },    1},
      { OREAD, "J", (void*)IDL_TYP_STRUCT,  0, { 0 },    0},
      { OREAD, "K", (void*)IDL_TYP_DOUBLE,  2, { 1, 0 }, 0},
      { OREAD, "L", (void*)IDL_TYP_LONG,    0, { 0 },    1},
      };

   /* Check the input contains the correct number of arguments. */
   if (Argc != 12)
      {
      USAGE("CSPICE_ZZARGS, a, _b_, c[5], _d[5]_, "
                           "e[3,7], _f[3,7]_, g[M], "
                           "`h`, _`i`_, (j), k[1,N], _l_");
      }

   argcheck[9].type = (void*)(IDL_MAX_TYPE + 1);

   extra = zzicy_argcheck( Argc, Argv_orig, argcheck, &Argv );

   /* Clean up temporary variables */
   zzicy_argcleanup( Argc, Argv_orig, argcheck, Argv );
   }




/*

   &- END OF CODE ENTRY POINTS

   We now define two lists, one each for FUNCTIONS (returning values)
   and PROCEDURES (void).  These are used in IDL_Load(), below, to tell
   IDL where the entry points are for each DLM routine.

   Syntax of each line is:

    { <function entry point>, "<FUNCTION NAME>",  <min args>, <max args> }

   There must be a one-to-one correspondence between these lists and
   the definitions in the ".dlm" file.

*/

static IDL_SYSFUN_DEF2 main_FUNC_def[] =
  {
  { { (IDL_FUN_RET) CSPICE_B1900 },  "CSPICE_B1900",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_B1950 },  "CSPICE_B1950",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_BODFND }, "CSPICE_BODFND", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_BRCKTD }, "CSPICE_BRCKTD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_BRCKTI }, "CSPICE_BRCKTI", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CARD },   "CSPICE_CARD",   0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CELLD },  "CSPICE_CELLD",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CELLI },  "CSPICE_CELLI",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CLIGHT }, "CSPICE_CLIGHT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DET },    "CSPICE_DET",    0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DPMAX },  "CSPICE_DPMAX",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DPMIN },  "CSPICE_DPMIN",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DPR },    "CSPICE_DPR",    0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DVDOT },  "CSPICE_DVDOT",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DVNORM },  "CSPICE_DVNORM", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DVSEP },  "CSPICE_DVSEP",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKNELT }, "CSPICE_EKNELT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKNSEG }, "CSPICE_EKNSEG", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EQSTR },  "CSPICE_EQSTR",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EXISTS }, "CSPICE_EXISTS", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_HALFPI }, "CSPICE_HALFPI", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_ICY },    "CSPICE_ICY",    0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_INTMAX }, "CSPICE_INTMAX", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_INTMIN }, "CSPICE_INTMIN", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_ISROT },  "CSPICE_ISROT",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_ISWHSP }, "CSPICE_ISWHSP", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_J1900 },  "CSPICE_J1900",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_J1950 },  "CSPICE_J1950",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_J2000 },  "CSPICE_J2000",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_J2100 },  "CSPICE_J2100",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_JYEAR },  "CSPICE_JYEAR",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_LASTNB }, "CSPICE_LASTNB", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_LSPCN },  "CSPICE_LSPCN",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_MATCHI }, "CSPICE_MATCHI", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_MATCHW }, "CSPICE_MATCHW", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PHASEQ},  "CSPICE_PHASEQ", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PI },     "CSPICE_PI",     0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PLTAR},   "CSPICE_PLTAR",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PLTVOL},  "CSPICE_PLTVOL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_RPD },    "CSPICE_RPD",    0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SET },    "CSPICE_SET",    0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SIZE },   "CSPICE_SIZE",   0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPD },    "CSPICE_SPD",    0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SUMAD },  "CSPICE_SUMAD",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SUMAI },  "CSPICE_SUMAI",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_TKVRSN }, "CSPICE_TKVRSN", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_TRACE },  "CSPICE_TRACE",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_TWOPI },  "CSPICE_TWOPI",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_TYEAR },  "CSPICE_TYEAR",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_UNITIM }, "CSPICE_UNITIM", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VDIST },  "CSPICE_VDIST",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VDISTG }, "CSPICE_VDISTG", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VDOT },   "CSPICE_VDOT",   0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VDOTG },  "CSPICE_VDOTG",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VNORM },  "CSPICE_VNORM",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VNORMG }, "CSPICE_VNORMG", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VREL },   "CSPICE_VREL",   0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VRELG },  "CSPICE_VRELG",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VSEP },   "CSPICE_VSEP",   0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VSEPG },  "CSPICE_VSEPG",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VTMV },   "CSPICE_VTMV",   0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VZERO },  "CSPICE_VZERO",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VZEROG }, "CSPICE_VZEROG", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_WNCARD }, "CSPICE_WNCARD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_WNELMD }, "CSPICE_WNELMD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_WNINCD }, "CSPICE_WNINCD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_WNRELD }, "CSPICE_WNRELD", 0, 30,0,0},
  };


static IDL_SYSFUN_DEF2 main_PROC_def[] =
  {
  { { (IDL_FUN_RET) CSPICE_APPNDD }, "CSPICE_APPNDD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_APPNDI }, "CSPICE_APPNDI", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_AXISAR }, "CSPICE_AXISAR", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_BADKPV }, "CSPICE_BADKPV", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_BODC2N }, "CSPICE_BODC2N", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_BODC2S }, "CSPICE_BODC2S", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_BODDEF }, "CSPICE_BODDEF", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_BODN2C }, "CSPICE_BODN2C", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_BODS2C }, "CSPICE_BODS2C", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_BODVAR }, "CSPICE_BODVAR", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_BODVCD }, "CSPICE_BODVCD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_BODVRD }, "CSPICE_BODVRD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CCIFRM }, "CSPICE_CCIFRM", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CGV2EL }, "CSPICE_CGV2EL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CIDFRM }, "CSPICE_CIDFRM", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CKCLS },  "CSPICE_CKCLS",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CKCOV },  "CSPICE_CKCOV",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CKGP },   "CSPICE_CKGP",   0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CKGPAV }, "CSPICE_CKGPAV", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CKLPF },  "CSPICE_CKLPF",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CKOBJ },  "CSPICE_CKOBJ",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CKOPN },  "CSPICE_CKOPN",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CKUPF },  "CSPICE_CKUPF",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CKW01 },  "CSPICE_CKW01",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CKW02 },  "CSPICE_CKW02",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CKW03 },  "CSPICE_CKW03",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CLPOOL }, "CSPICE_CLPOOL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CMPRSS }, "CSPICE_CMPRSS", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CNMFRM }, "CSPICE_CNMFRM", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CONICS }, "CSPICE_CONICS", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CONVRT }, "CSPICE_CONVRT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CYLLAT }, "CSPICE_CYLLAT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CYLREC }, "CSPICE_CYLREC", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_CYLSPH }, "CSPICE_CYLSPH", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DAFAC },  "CSPICE_DAFAC",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DAFBBS }, "CSPICE_DAFBBS", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DAFBFS }, "CSPICE_DAFBFS", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DAFCLS }, "CSPICE_DAFCLS", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DAFCS },  "CSPICE_DAFCS",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DAFDC },  "CSPICE_DAFDC",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DAFEC },  "CSPICE_DAFEC",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DAFFNA }, "CSPICE_DAFFNA", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DAFFPA }, "CSPICE_DAFFPA", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DAFGDA }, "CSPICE_DAFGDA", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DAFGN },  "CSPICE_DAFGN",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DAFGS },  "CSPICE_DAFGS",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DAFOPR }, "CSPICE_DAFOPR", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DAFOPW }, "CSPICE_DAFOPW", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DAFRS },  "CSPICE_DAFRS",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DAFUS },  "CSPICE_DAFUS",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DASCLS }, "CSPICE_DASCLS", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DASEC  }, "CSPICE_DASEC",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DASOPR }, "CSPICE_DASOPR", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DCYLDR }, "CSPICE_DCYLDR", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DELTET }, "CSPICE_DELTET", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DGEODR }, "CSPICE_DGEODR", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DIAGS2 }, "CSPICE_DIAGS2", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DIFF },   "CSPICE_DIFF",   0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DLABFS }, "CSPICE_DLABFS", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DLAFNS }, "CSPICE_DLAFNS", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DLATDR }, "CSPICE_DLATDR", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DP2HX },  "CSPICE_DP2HX",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DPGRDR }, "CSPICE_DPGRDR", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DRDCYL }, "CSPICE_DRDCYL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DRDGEO }, "CSPICE_DRDGEO", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DRDLAT }, "CSPICE_DRDLAT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DRDPGR }, "CSPICE_DRDPGR", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DRDSPH }, "CSPICE_DRDSPH", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DSKB02 }, "CSPICE_DSKB02", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DSKCLS }, "CSPICE_DSKCLS", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DSKD02 }, "CSPICE_DSKD02", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DSKGD  }, "CSPICE_DSKGD",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DSKGTL }, "CSPICE_DSKGTL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DSKI02 }, "CSPICE_DSKI02", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DSKMI2 }, "CSPICE_DSKMI2", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DSKN02 }, "CSPICE_DSKN02", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DSKOBJ }, "CSPICE_DSKOBJ", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DSKOPN }, "CSPICE_DSKOPN", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DSKP02 }, "CSPICE_DSKP02", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DSKRB2 }, "CSPICE_DSKRB2", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DSKSRF }, "CSPICE_DSKSRF", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DSKSTL }, "CSPICE_DSKSTL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DSKV02 }, "CSPICE_DSKV02", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DSKW02 }, "CSPICE_DSKW02", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DSKX02 }, "CSPICE_DSKX02", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DSKXSI }, "CSPICE_DSKXSI", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DSKXV  }, "CSPICE_DSKXV",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DSKZ02 }, "CSPICE_DSKZ02", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DSPHDR }, "CSPICE_DSPHDR", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DTPOOL }, "CSPICE_DTPOOL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DUCRSS }, "CSPICE_DUCRSS", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DVCRSS }, "CSPICE_DVCRSS", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DVHAT },  "CSPICE_DVHAT",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_DVPOOL }, "CSPICE_DVPOOL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EDLIMB }, "CSPICE_EDLIMB", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EDTERM }, "CSPICE_EDTERM", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKACEC }, "CSPICE_EKACEC", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKACED }, "CSPICE_EKACED", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKACEI }, "CSPICE_EKACEI", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKACLC }, "CSPICE_EKACLC", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKACLD }, "CSPICE_EKACLD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKACLI }, "CSPICE_EKACLI", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKAPPR }, "CSPICE_EKAPPR", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKBSEG }, "CSPICE_EKBSEG", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKCCNT }, "CSPICE_EKCCNT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKCII },  "CSPICE_EKCII",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKCLS },  "CSPICE_EKCLS",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKDELR }, "CSPICE_EKDELR", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKFFLD }, "CSPICE_EKFFLD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKFIND }, "CSPICE_EKFIND", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKGC },   "CSPICE_EKGC",   0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKGD },   "CSPICE_EKGD",   0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKGI },   "CSPICE_EKGI",   0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKIFLD }, "CSPICE_EKIFLD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKINSR }, "CSPICE_EKINSR", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKLEF },  "CSPICE_EKLEF",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKNTAB }, "CSPICE_EKNTAB", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKOPN },  "CSPICE_EKOPN",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKOPR },  "CSPICE_EKOPR",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKOPS },  "CSPICE_EKOPS",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKOPW },  "CSPICE_EKOPW",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKPSEL }, "CSPICE_EKPSEL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKRCEC }, "CSPICE_EKRCEC", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKRCED }, "CSPICE_EKRCED", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKRCEI }, "CSPICE_EKRCEI", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKSSUM }, "CSPICE_EKSSUM", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKTNAM }, "CSPICE_EKTNAM", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKUCEC }, "CSPICE_EKUCEC", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKUCED }, "CSPICE_EKUCED", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKUCEI }, "CSPICE_EKUCEI", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EKUEF },  "CSPICE_EKUEF",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EL2CGV }, "CSPICE_EL2CGV", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EQNCPV }, "CSPICE_EQNCPV", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_ET2LST }, "CSPICE_ET2LST", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_ET2UTC }, "CSPICE_ET2UTC", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_ETCAL },  "CSPICE_ETCAL",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EUL2M },  "CSPICE_EUL2M",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EUL2XF }, "CSPICE_EUL2XF", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_EXPOOL }, "CSPICE_EXPOOL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_FOVRAY }, "CSPICE_FOVRAY", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_FOVTRG }, "CSPICE_FOVTRG", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_FRAME },  "CSPICE_FRAME",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_FRINFO }, "CSPICE_FRINFO", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_FRMNAM }, "CSPICE_FRMNAM", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_FURNSH }, "CSPICE_FURNSH", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_GCPOOL }, "CSPICE_GCPOOL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_GDPOOL }, "CSPICE_GDPOOL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_GEOREC }, "CSPICE_GEOREC", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_GETELM }, "CSPICE_GETELM", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_GETFAT }, "CSPICE_GETFAT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_GETFOV }, "CSPICE_GETFOV", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_GFDIST }, "CSPICE_GFDIST", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_GFILUM }, "CSPICE_GFILUM", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_GFOCLT }, "CSPICE_GFOCLT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_GFPA },   "CSPICE_GFPA",   0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_GFPOSC }, "CSPICE_GFPOSC", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_GFRFOV }, "CSPICE_GFRFOV", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_GFRR },   "CSPICE_GFRR",   0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_GFSEP  }, "CSPICE_GFSEP",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_GFSNTC }, "CSPICE_GFSNTC", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_GFSTOL }, "CSPICE_GFSTOL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_GFSUBC }, "CSPICE_GFSUBC", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_GFTFOV }, "CSPICE_GFTFOV", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_GIPOOL }, "CSPICE_GIPOOL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_GNPOOL }, "CSPICE_GNPOOL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_HX2DP },  "CSPICE_HX2DP",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_IDENT },  "CSPICE_IDENT",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_ILLUM },  "CSPICE_ILLUM",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_ILLUMF }, "CSPICE_ILLUMF", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_ILLUMG }, "CSPICE_ILLUMG", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_ILLUM_PL02 },
                                "CSPICE_ILLUM_PL02",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_ILLUM_PLID_PL02 },
                            "CSPICE_ILLUM_PLID_PL02", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_ILUMIN }, "CSPICE_ILUMIN", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_INEDPL }, "CSPICE_INEDPL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_INELPL }, "CSPICE_INELPL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_INRYPL }, "CSPICE_INRYPL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_INSRTD }, "CSPICE_INSRTD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_INSRTI }, "CSPICE_INSRTI", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_INTER },  "CSPICE_INTER",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_INVERT }, "CSPICE_INVERT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_INVORT }, "CSPICE_INVORT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_KCLEAR }, "CSPICE_KCLEAR", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_KDATA },  "CSPICE_KDATA",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_KINFO },  "CSPICE_KINFO",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_KTOTAL }, "CSPICE_KTOTAL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_LATCYL }, "CSPICE_LATCYL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_LATREC }, "CSPICE_LATREC", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_LATSPH }, "CSPICE_LATSPH", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_LATSRF }, "CSPICE_LATSRF", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_LCASE },  "CSPICE_LCASE",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_LDPOOL }, "CSPICE_LDPOOL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_LIMBPT }, "CSPICE_LIMBPT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_LIMB_PL02 },
                                     "CSPICE_LIMB_PL02",   0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_LLGRID_PL02 },
                                     "CSPICE_LLGRID_PL02", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_LMPOOL }, "CSPICE_LMPOOL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_LPARSE }, "CSPICE_LPARSE", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_LTIME },  "CSPICE_LTIME",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_M2EUL },  "CSPICE_M2EUL",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_M2Q },    "CSPICE_M2Q",    0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_MEQU },   "CSPICE_MEQU",   0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_MTXM },   "CSPICE_MTXM",   0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_MTXV },   "CSPICE_MTXV",   0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_MXM },    "CSPICE_MXM",    0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_MXMT },   "CSPICE_MXMT",   0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_MXV },    "CSPICE_MXV",    0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_NAMFRM }, "CSPICE_NAMFRM", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_NEARPT }, "CSPICE_NEARPT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_NPEDLN }, "CSPICE_NPEDLN", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_NPELPT }, "CSPICE_NPELPT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_NPLNPT }, "CSPICE_NPLNPT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_NVC2PL }, "CSPICE_NVC2PL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_NVP2PL }, "CSPICE_NVP2PL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_OCCULT }, "CSPICE_OCCULT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_OSCELT }, "CSPICE_OSCELT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PCKCOV }, "CSPICE_PCKCOV", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PCKFRM }, "CSPICE_PCKFRM", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PCKLOF }, "CSPICE_PCKLOF", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PCKUOF }, "CSPICE_PCKUOF", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PCPOOL }, "CSPICE_PCPOOL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PDPOOL }, "CSPICE_PDPOOL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PGRREC }, "CSPICE_PGRREC", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PIPOOL }, "CSPICE_PIPOOL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PJELPL }, "CSPICE_PJELPL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PL2NVC }, "CSPICE_PL2NVC", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PL2NVP }, "CSPICE_PL2NVP", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PL2PSV }, "CSPICE_PL2PSV", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PLTEXP }, "CSPICE_PLTEXP", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PLTNP },  "CSPICE_PLTNP",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PLTNRM }, "CSPICE_PLTNRM", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PROP2B }, "CSPICE_PROP2B", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PRSDP },  "CSPICE_PRSDP",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PRSINT }, "CSPICE_PRSINT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PSV2PL }, "CSPICE_PSV2PL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PXFORM }, "CSPICE_PXFORM", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_PXFRM2 }, "CSPICE_PXFRM2", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_Q2M },    "CSPICE_Q2M",    0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_QDQ2AV }, "CSPICE_QDQ2AV", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_QXQ },    "CSPICE_QXQ",    0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_RADREC }, "CSPICE_RADREC", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_RAV2XF }, "CSPICE_RAV2XF", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_RAXISA }, "CSPICE_RAXISA", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_RECCYL }, "CSPICE_RECCYL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_RECGEO }, "CSPICE_RECGEO", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_RECLAT }, "CSPICE_RECLAT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_RECPGR }, "CSPICE_RECPGR", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_RECRAD }, "CSPICE_RECRAD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_RECSPH }, "CSPICE_RECSPH", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_REMOVD }, "CSPICE_REMOVD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_REMOVI }, "CSPICE_REMOVI", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_ROTATE }, "CSPICE_ROTATE", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_ROTMAT }, "CSPICE_ROTMAT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_ROTVEC }, "CSPICE_ROTVEC", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_RQUAD },  "CSPICE_RQUAD",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SAELGV }, "CSPICE_SAELGV", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SCARD },  "CSPICE_SCARD",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SCDECD }, "CSPICE_SCDECD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SCE2C },  "CSPICE_SCE2C",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SCE2S },  "CSPICE_SCE2S",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SCE2T },  "CSPICE_SCE2T",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SCENCD }, "CSPICE_SCENCD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SCFMT },  "CSPICE_SCFMT",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SCPART }, "CSPICE_SCPART", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SCS2E },  "CSPICE_SCS2E",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SCT2E },  "CSPICE_SCT2E",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SCTIKS }, "CSPICE_SCTIKS", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SDIFF },  "CSPICE_SDIFF",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SINCPT},  "CSPICE_SINCPT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPHCYL }, "CSPICE_SPHCYL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPHLAT }, "CSPICE_SPHLAT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPHREC }, "CSPICE_SPHREC", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPK14A }, "CSPICE_SPK14A", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPK14B }, "CSPICE_SPK14B", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPK14E }, "CSPICE_SPK14E", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKAPO }, "CSPICE_SPKAPO", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKAPP }, "CSPICE_SPKAPP", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKCLS }, "CSPICE_SPKCLS", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKCOV }, "CSPICE_SPKCOV", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKCPO }, "CSPICE_SPKCPO", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKCPT }, "CSPICE_SPKCPT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKCVO }, "CSPICE_SPKCVO", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKCVT }, "CSPICE_SPKCVT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKEZ },  "CSPICE_SPKEZ",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKEZP }, "CSPICE_SPKEZP", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKEZR }, "CSPICE_SPKEZR", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKGEO }, "CSPICE_SPKGEO", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKGPS }, "CSPICE_SPKGPS", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKLEF }, "CSPICE_SPKLEF", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKOBJ }, "CSPICE_SPKOBJ", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKOPA }, "CSPICE_SPKOPA", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKOPN }, "CSPICE_SPKOPN", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKPOS }, "CSPICE_SPKPOS", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKPVN }, "CSPICE_SPKPVN", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKSFS }, "CSPICE_SPKSFS", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKSSB }, "CSPICE_SPKSSB", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKSUB }, "CSPICE_SPKSUB", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKUDS }, "CSPICE_SPKUDS", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKUEF }, "CSPICE_SPKUEF", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKW02 }, "CSPICE_SPKW02", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKW03 }, "CSPICE_SPKW03", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKW05 }, "CSPICE_SPKW05", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKW08 }, "CSPICE_SPKW08", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKW09 }, "CSPICE_SPKW09", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKW10 }, "CSPICE_SPKW10", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKW12 }, "CSPICE_SPKW12", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKW13 }, "CSPICE_SPKW13", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SPKW17 }, "CSPICE_SPKW17", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SRFC2S }, "CSPICE_SRFC2S", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SRFCSS }, "CSPICE_SRFCSS", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SRFNRM }, "CSPICE_SRFNRM", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SRFREC }, "CSPICE_SRFREC", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SRFS2C }, "CSPICE_SRFS2C", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SRFSCC }, "CSPICE_SRFSCC", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SRFXPT }, "CSPICE_SRFXPT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SSIZE },  "CSPICE_SSIZE",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_STELAB }, "CSPICE_STELAB", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_STPOOL }, "CSPICE_STPOOL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_STR2ET }, "CSPICE_STR2ET", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SUBPNT }, "CSPICE_SUBPNT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SUBPT  }, "CSPICE_SUBPT",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SUBPT_PL02 },
                                "CSPICE_SUBPT_PL02",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SUBSLR }, "CSPICE_SUBSLR", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SUBSOL }, "CSPICE_SUBSOL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SUBSOL_PL02 },
                                "CSPICE_SUBSOL_PL02", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SURFNM }, "CSPICE_SURFNM", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SURFPT }, "CSPICE_SURFPT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SXFORM }, "CSPICE_SXFORM", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_SZPOOL }, "CSPICE_SZPOOL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_TERMPT }, "CSPICE_TERMPT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_TERM_PL02 },
                                "CSPICE_TERM_PL02",   0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_TIMDEF }, "CSPICE_TIMDEF", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_TIMOUT }, "CSPICE_TIMOUT", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_TIPBOD }, "CSPICE_TIPBOD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_TISBOD }, "CSPICE_TISBOD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_TPARSE }, "CSPICE_TPARSE", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_TPICTR }, "CSPICE_TPICTR", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_TSETYR }, "CSPICE_TSETYR", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_TWOVEC }, "CSPICE_TWOVEC", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_UCASE },  "CSPICE_UCASE",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_UCRSS },  "CSPICE_UCRSS",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_UNION },  "CSPICE_UNION",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_UNLOAD }, "CSPICE_UNLOAD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_UNORM },  "CSPICE_UNORM",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_UNORMG }, "CSPICE_UNORMG", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_UTC2ET }, "CSPICE_UTC2ET", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VADD },   "CSPICE_VADD",   0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VADDG },  "CSPICE_VADDG",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VALID },  "CSPICE_VALID",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VCRSS },  "CSPICE_VCRSS",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VEQU },   "CSPICE_VEQU",   0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VEQUG },  "CSPICE_VEQUG",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VHAT },   "CSPICE_VHAT",   0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VHATG },  "CSPICE_VHATG",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VLCOM },  "CSPICE_VLCOM",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VLCOM3 }, "CSPICE_VLCOM3", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VLCOMG }, "CSPICE_VLCOMG", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VMINUG }, "CSPICE_VMINUG", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VMINUS }, "CSPICE_VMINUS", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VPACK },  "CSPICE_VPACK",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VPERP },  "CSPICE_VPERP",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VPRJP },  "CSPICE_VPRJP",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VPRJPI }, "CSPICE_VPRJPI", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VPROJ },  "CSPICE_VPROJ",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VROTV },  "CSPICE_VROTV",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VSCL },   "CSPICE_VSCL",   0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VSCLG },  "CSPICE_VSCLG",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VSUB },   "CSPICE_VSUB",   0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VSUBG },  "CSPICE_VSUBG",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_VUPACK }, "CSPICE_VUPACK", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_WNCOMD }, "CSPICE_WNCOMD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_WNCOND }, "CSPICE_WNCOND", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_WNDIFD }, "CSPICE_WNDIFD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_WNEXPD }, "CSPICE_WNEXPD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_WNEXTD }, "CSPICE_WNEXTD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_WNFETD }, "CSPICE_WNFETD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_WNFILD }, "CSPICE_WNFILD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_WNFLTD }, "CSPICE_WNFLTD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_WNINSD }, "CSPICE_WNINSD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_WNINTD }, "CSPICE_WNINTD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_WNSUMD }, "CSPICE_WNSUMD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_WNUNID }, "CSPICE_WNUNID", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_WNVALD }, "CSPICE_WNVALD", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_XF2EUL }, "CSPICE_XF2EUL", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_XF2RAV }, "CSPICE_XF2RAV", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_XFMSTA }, "CSPICE_XFMSTA", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_XPOSE  }, "CSPICE_XPOSE",  0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_XPOSE6 }, "CSPICE_XPOSE6", 0, 30,0,0},
  { { (IDL_FUN_RET) CSPICE_ZZARGS},  "CSPICE_ZZARGS", 0, 30,0,0},
  };

/*
   When IDL loads a DLM it calls the routine IDL_Load associated with
   that DLM.

   Within IDL LOAD:

     1) Define all STRUCTs.
     2) Define a message block for SPICE errors.
     3) Set up error handling (so SPICE errors don't cause a crash)
     4) Call "IDL_SysRtnAdd()" to inform IDL of the FUNCs and PROCs
        defined above.

   IDL_Load() returns 1 on success, 0 on failure.
*/

int IDL_Load(void)
   {

   /*
   Define a the dimension setting for a 3-vector, vector[3].
   */
   static IDL_MEMINT  dims_3[] = { 1, 3 };

   /*

   IDL structure equivalents of structs defined by SPICE.

   Note that these _MUST_ be identical to those defined
   in SpicePln.h, SpiceEll.h.

   Plane. Based on definitions in SpicePln.h.
   */

   IDL_STRUCT_TAG_DEF s_tags_SpicePlane[] =
      {
      { "NORMAL",   dims_3, (void*)IDL_TYP_DOUBLE },
      { "CONSTANT",      0, (void*)IDL_TYP_DOUBLE },
      { 0 }
      };


   /*
   Ellipse. Based on definitions in SpiceEll.h.
   */

   IDL_STRUCT_TAG_DEF s_tags_SpiceEllipse[] =
      {
      { "CENTER",    dims_3, (void*)IDL_TYP_DOUBLE },
      { "SEMIMAJOR", dims_3, (void*)IDL_TYP_DOUBLE },
      { "SEMIMINOR", dims_3, (void*)IDL_TYP_DOUBLE },
      { 0 }
      };

   /*
   EK. Based on definitions in SpiceEK.h.
   SpiceInt        cclass;
   SpiceEKDataType dtype;
   SpiceInt        strlen;
   SpiceInt        size;
   SpiceBoolean    indexd;
   SpiceBoolean    nullok;
   */

   IDL_STRUCT_TAG_DEF s_tags_SpiceEKAttDsc[] =
      {
      { "CCLASS",  0, (void*)IDL_TYP_LONG },
      { "DTYPE",   0, (void*)IDL_TYP_LONG },
      { "STRLEN",  0, (void*)IDL_TYP_LONG },
      { "SIZE",    0, (void*)IDL_TYP_LONG },
      { "INDEXD",  0, (void*)IDL_TYP_LONG },
      { "NULLOK",  0, (void*)IDL_TYP_LONG },
      { 0 }
      };

   /*
   Create the required structs.  The "s_SpiceXxxx" vars are globals,
   declared above.
   */
   s_SpicePlane    = IDL_MakeStruct( "CSPICE_PLANE",    s_tags_SpicePlane   );
   s_SpiceEllipse  = IDL_MakeStruct( "CSPICE_ELLIPSE",  s_tags_SpiceEllipse );
   s_SpiceEKAttDsc = IDL_MakeStruct( "CSPICE_EKATTDSC", s_tags_SpiceEKAttDsc);

   /*
   Define the IDL message block for CSPICE.
   */
   define_message_block( "SPICE_MBLK" );

   /*
   By default, CSPICE calls exit() when an error occurs. This response
   causes the IDL application to exit (collapse).

   All interface functions immediately execute the CHECK_CALL_FAILURE
   macro after calling their CSPICE namesakes. This macro checks the failure_c
   state, making the needed calls to create an IDL error message
   if an error occurs.

   Set the error status to RETURN and the error device to NULL.
   */
   zzerrorinit();

   /*
   Tell IDL where to find the FUNCs and PROCs.
   */
   return IDL_SysRtnAdd(main_FUNC_def, TRUE,  IDL_CARRAY_ELTS(main_FUNC_def))
       && IDL_SysRtnAdd(main_PROC_def, FALSE, IDL_CARRAY_ELTS(main_PROC_def));

   }



